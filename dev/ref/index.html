<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference ¬∑ OpticSim.jl</title><meta name="title" content="Reference ¬∑ OpticSim.jl"/><meta property="og:title" content="Reference ¬∑ OpticSim.jl"/><meta property="twitter:title" content="Reference ¬∑ OpticSim.jl"/><meta name="description" content="Documentation for OpticSim.jl."/><meta property="og:description" content="Documentation for OpticSim.jl."/><meta property="twitter:description" content="Documentation for OpticSim.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/logo.svg" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img class="docs-light-only" src="../assets/logo.svg" alt="OpticSim.jl logo"/><img class="docs-dark-only" src="../assets/logo-dark.svg" alt="OpticSim.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">OpticSim.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Geometry</span><ul><li><a class="tocitem" href="../primitives/">Primitives</a></li><li><a class="tocitem" href="../transforms_and_vectors/">Transforms and Vectors</a></li><li><a class="tocitem" href="../csg/">CSG</a></li></ul></li><li><span class="tocitem">Optical</span><ul><li><a class="tocitem" href="../systems/">Systems</a></li><li><a class="tocitem" href="../emitters/">Emitters</a></li><li><a class="tocitem" href="../interfaces/">Interfaces</a></li><li><a class="tocitem" href="../lenses/">Lenses</a></li></ul></li><li class="is-active"><a class="tocitem" href>Reference</a><ul class="internal"><li><a class="tocitem" href="#Index"><span>Index</span></a></li><li><a class="tocitem" href="#OpticSim"><span>OpticSim</span></a></li><li><a class="tocitem" href="#Optical-Emitters"><span>Optical Emitters</span></a></li><li><a class="tocitem" href="#Geometry"><span>Geometry</span></a></li><li><a class="tocitem" href="#Zernike"><span>Zernike</span></a></li><li><a class="tocitem" href="#QType"><span>QType</span></a></li><li><a class="tocitem" href="#Chebyshev"><span>Chebyshev</span></a></li><li><a class="tocitem" href="#Data"><span>Data</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/brianguenter/OpticSim.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands">ÔÇõ</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/brianguenter/OpticSim.jl/blob/main/docs/src/ref.md" title="Edit source on GitHub"><span class="docs-icon fa-solid">ÔÅÑ</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Complete-Reference"><a class="docs-heading-anchor" href="#Complete-Reference">Complete Reference</a><a id="Complete-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Complete-Reference" title="Permalink"></a></h1><p>This page contains what should be a complete list of all docstrings in the OpticSim module, and its submodule.</p><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#OpticSim.Chebyshev"><code>OpticSim.Chebyshev</code></a></li><li><a href="#OpticSim.QType"><code>OpticSim.QType</code></a></li><li><a href="#OpticSim.Zernike"><code>OpticSim.Zernike</code></a></li><li><a href="#OpticSim.AbstractOpticalSystem"><code>OpticSim.AbstractOpticalSystem</code></a></li><li><a href="#OpticSim.AcceleratedParametricSurface"><code>OpticSim.AcceleratedParametricSurface</code></a></li><li><a href="#OpticSim.AsphericSurface"><code>OpticSim.AsphericSurface</code></a></li><li><a href="#OpticSim.AxisymmetricOpticalSystem"><code>OpticSim.AxisymmetricOpticalSystem</code></a></li><li><a href="#OpticSim.BSplineCurve"><code>OpticSim.BSplineCurve</code></a></li><li><a href="#OpticSim.BSplineSurface"><code>OpticSim.BSplineSurface</code></a></li><li><a href="#OpticSim.BeamState"><code>OpticSim.BeamState</code></a></li><li><a href="#OpticSim.BezierCurve"><code>OpticSim.BezierCurve</code></a></li><li><a href="#OpticSim.BezierSurface"><code>OpticSim.BezierSurface</code></a></li><li><a href="#OpticSim.BoundingBox"><code>OpticSim.BoundingBox</code></a></li><li><a href="#OpticSim.CSGGenerator"><code>OpticSim.CSGGenerator</code></a></li><li><a href="#OpticSim.CSGOpticalSystem"><code>OpticSim.CSGOpticalSystem</code></a></li><li><a href="#OpticSim.CSGTree"><code>OpticSim.CSGTree</code></a></li><li><a href="#OpticSim.ChebyshevSurface"><code>OpticSim.ChebyshevSurface</code></a></li><li><a href="#OpticSim.ConvexPolygon"><code>OpticSim.ConvexPolygon</code></a></li><li><a href="#OpticSim.CurveType"><code>OpticSim.CurveType</code></a></li><li><a href="#OpticSim.Cylinder"><code>OpticSim.Cylinder</code></a></li><li><a href="#OpticSim.DisjointUnion"><code>OpticSim.DisjointUnion</code></a></li><li><a href="#OpticSim.Ellipse"><code>OpticSim.Ellipse</code></a></li><li><a href="#OpticSim.Emitters.AngularPower.Cosine"><code>OpticSim.Emitters.AngularPower.Cosine</code></a></li><li><a href="#OpticSim.Emitters.AngularPower.Gaussian"><code>OpticSim.Emitters.AngularPower.Gaussian</code></a></li><li><a href="#OpticSim.Emitters.AngularPower.Lambertian"><code>OpticSim.Emitters.AngularPower.Lambertian</code></a></li><li><a href="#OpticSim.Emitters.Directions.Constant"><code>OpticSim.Emitters.Directions.Constant</code></a></li><li><a href="#OpticSim.Emitters.Directions.HexapolarCone"><code>OpticSim.Emitters.Directions.HexapolarCone</code></a></li><li><a href="#OpticSim.Emitters.Directions.RectGrid"><code>OpticSim.Emitters.Directions.RectGrid</code></a></li><li><a href="#OpticSim.Emitters.Directions.UniformCone"><code>OpticSim.Emitters.Directions.UniformCone</code></a></li><li><a href="#OpticSim.Emitters.Origins.Hexapolar"><code>OpticSim.Emitters.Origins.Hexapolar</code></a></li><li><a href="#OpticSim.Emitters.Origins.Point"><code>OpticSim.Emitters.Origins.Point</code></a></li><li><a href="#OpticSim.Emitters.Origins.RectGrid"><code>OpticSim.Emitters.Origins.RectGrid</code></a></li><li><a href="#OpticSim.Emitters.Origins.RectJitterGrid"><code>OpticSim.Emitters.Origins.RectJitterGrid</code></a></li><li><a href="#OpticSim.Emitters.Origins.RectUniform"><code>OpticSim.Emitters.Origins.RectUniform</code></a></li><li><a href="#OpticSim.Emitters.Sources.CompositeSource"><code>OpticSim.Emitters.Sources.CompositeSource</code></a></li><li><a href="#OpticSim.Emitters.Sources.Source"><code>OpticSim.Emitters.Sources.Source</code></a></li><li><a href="#OpticSim.Emitters.Spectrum.DeltaFunction"><code>OpticSim.Emitters.Spectrum.DeltaFunction</code></a></li><li><a href="#OpticSim.Emitters.Spectrum.Measured"><code>OpticSim.Emitters.Spectrum.Measured</code></a></li><li><a href="#OpticSim.Emitters.Spectrum.Uniform"><code>OpticSim.Emitters.Spectrum.Uniform</code></a></li><li><a href="#OpticSim.EmptyInterval"><code>OpticSim.EmptyInterval</code></a></li><li><a href="#OpticSim.FiniteStop"><code>OpticSim.FiniteStop</code></a></li><li><a href="#OpticSim.FresnelInterface"><code>OpticSim.FresnelInterface</code></a></li><li><a href="#OpticSim.GeometricRayGenerator"><code>OpticSim.GeometricRayGenerator</code></a></li><li><a href="#OpticSim.Geometry.Transform-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{T}}} where T&lt;:Real"><code>OpticSim.Geometry.Transform</code></a></li><li><a href="#OpticSim.Geometry.Transform-Union{Tuple{T}, Tuple{StaticArraysCore.SMatrix{3, 3, T}, StaticArraysCore.SVector{3, T}}} where T&lt;:Real"><code>OpticSim.Geometry.Transform</code></a></li><li><a href="#OpticSim.Geometry.Transform"><code>OpticSim.Geometry.Transform</code></a></li><li><a href="#OpticSim.Geometry.Transform-Union{Tuple{T}, Tuple{StaticArraysCore.SVector{3, T}, StaticArraysCore.SVector{3, T}, StaticArraysCore.SVector{3, T}}, NTuple{4, StaticArraysCore.SVector{3, T}}} where T&lt;:Real"><code>OpticSim.Geometry.Transform</code></a></li><li><a href="#OpticSim.Geometry.Transform-Union{Tuple{StaticArraysCore.SVector{3, T}}, Tuple{T}, Tuple{StaticArraysCore.SVector{3, T}, StaticArraysCore.SVector{3, T}}} where T&lt;:Real"><code>OpticSim.Geometry.Transform</code></a></li><li><a href="#OpticSim.Geometry.Transform-Union{Tuple{T}, NTuple{4, StaticArraysCore.SVector{4, T}}} where T&lt;:Real"><code>OpticSim.Geometry.Transform</code></a></li><li><a href="#OpticSim.Geometry.Transform-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T&lt;:Real"><code>OpticSim.Geometry.Transform</code></a></li><li><a href="#OpticSim.Geometry.Vec3"><code>OpticSim.Geometry.Vec3</code></a></li><li><a href="#OpticSim.Geometry.Vec4"><code>OpticSim.Geometry.Vec4</code></a></li><li><a href="#OpticSim.Geometry.Vec4-Union{Tuple{StaticArraysCore.SMatrix{3, N, T}}, Tuple{T}, Tuple{N}} where {N, T&lt;:Real}"><code>OpticSim.Geometry.Vec4</code></a></li><li><a href="#OpticSim.Geometry.Vec4-Union{Tuple{StaticArraysCore.SVector{3, T}}, Tuple{T}} where T&lt;:Real"><code>OpticSim.Geometry.Vec4</code></a></li><li><a href="#OpticSim.GridSagInterpolation"><code>OpticSim.GridSagInterpolation</code></a></li><li><a href="#OpticSim.GridSagSurface"><code>OpticSim.GridSagSurface</code></a></li><li><a href="#OpticSim.Hexagon"><code>OpticSim.Hexagon</code></a></li><li><a href="#OpticSim.HierarchicalImage"><code>OpticSim.HierarchicalImage</code></a></li><li><a href="#OpticSim.HologramInterface"><code>OpticSim.HologramInterface</code></a></li><li><a href="#OpticSim.HologramSurface"><code>OpticSim.HologramSurface</code></a></li><li><a href="#OpticSim.InfiniteStop"><code>OpticSim.InfiniteStop</code></a></li><li><a href="#OpticSim.Infinity"><code>OpticSim.Infinity</code></a></li><li><a href="#OpticSim.InterfaceMode"><code>OpticSim.InterfaceMode</code></a></li><li><a href="#OpticSim.Intersection"><code>OpticSim.Intersection</code></a></li><li><a href="#OpticSim.Interval"><code>OpticSim.Interval</code></a></li><li><a href="#OpticSim.KnotVector"><code>OpticSim.KnotVector</code></a></li><li><a href="#OpticSim.LensAssembly"><code>OpticSim.LensAssembly</code></a></li><li><a href="#OpticSim.LensTrace"><code>OpticSim.LensTrace</code></a></li><li><a href="#OpticSim.NullInterface"><code>OpticSim.NullInterface</code></a></li><li><a href="#OpticSim.OpticalInterface"><code>OpticSim.OpticalInterface</code></a></li><li><a href="#OpticSim.OpticalRay"><code>OpticSim.OpticalRay</code></a></li><li><a href="#OpticSim.OpticalRayGenerator"><code>OpticSim.OpticalRayGenerator</code></a></li><li><a href="#OpticSim.ParametricSurface"><code>OpticSim.ParametricSurface</code></a></li><li><a href="#OpticSim.ParaxialInterface"><code>OpticSim.ParaxialInterface</code></a></li><li><a href="#OpticSim.ParaxialLens"><code>OpticSim.ParaxialLens</code></a></li><li><a href="#OpticSim.Plane"><code>OpticSim.Plane</code></a></li><li><a href="#OpticSim.QTypeSurface"><code>OpticSim.QTypeSurface</code></a></li><li><a href="#OpticSim.Ray"><code>OpticSim.Ray</code></a></li><li><a href="#OpticSim.RayOrigin"><code>OpticSim.RayOrigin</code></a></li><li><a href="#OpticSim.Rectangle"><code>OpticSim.Rectangle</code></a></li><li><a href="#OpticSim.Sphere"><code>OpticSim.Sphere</code></a></li><li><a href="#OpticSim.SphericalCap"><code>OpticSim.SphericalCap</code></a></li><li><a href="#OpticSim.SphericalPolygon"><code>OpticSim.SphericalPolygon</code></a></li><li><a href="#OpticSim.Spline"><code>OpticSim.Spline</code></a></li><li><a href="#OpticSim.SplineSurface"><code>OpticSim.SplineSurface</code></a></li><li><a href="#OpticSim.Surface"><code>OpticSim.Surface</code></a></li><li><a href="#OpticSim.ThinGratingInterface"><code>OpticSim.ThinGratingInterface</code></a></li><li><a href="#OpticSim.ThinGratingSurface"><code>OpticSim.ThinGratingSurface</code></a></li><li><a href="#OpticSim.Triangle"><code>OpticSim.Triangle</code></a></li><li><a href="#OpticSim.TriangleMesh"><code>OpticSim.TriangleMesh</code></a></li><li><a href="#OpticSim.WrapperSurface"><code>OpticSim.WrapperSurface</code></a></li><li><a href="#OpticSim.ZernikeIndexType"><code>OpticSim.ZernikeIndexType</code></a></li><li><a href="#OpticSim.ZernikeSurface"><code>OpticSim.ZernikeSurface</code></a></li><li><a href="#OpticSim.Annulus-Union{Tuple{T}, Tuple{T, T, StaticArraysCore.SVector{3, T}, StaticArraysCore.SVector{3, T}}} where T&lt;:Real"><code>OpticSim.Annulus</code></a></li><li><a href="#OpticSim.AsphericLens-Union{Tuple{S}, Tuple{T}, Tuple{Q}, Tuple{R}, Tuple{T, S, S, S, Union{Nothing, Array{Pair{Int64, S}, 1}}, S, S, Union{Nothing, Array{Pair{Int64, S}, 1}}, S, S}} where {R&lt;:AbstractGlass, Q&lt;:AbstractGlass, T&lt;:AbstractGlass, S&lt;:Real}"><code>OpticSim.AsphericLens</code></a></li><li><a href="#OpticSim.BoundedCylinder-Union{Tuple{T}, Tuple{T, T}} where T&lt;:Real"><code>OpticSim.BoundedCylinder</code></a></li><li><a href="#OpticSim.Circle-Union{Tuple{T}, Tuple{T, StaticArraysCore.SVector{3, T}, StaticArraysCore.SVector{3, T}}} where T&lt;:Real"><code>OpticSim.Circle</code></a></li><li><a href="#OpticSim.CircularAperture-Union{Tuple{T}, Tuple{T, T, T, StaticArraysCore.SVector{3, T}, StaticArraysCore.SVector{3, T}}} where T&lt;:Real"><code>OpticSim.CircularAperture</code></a></li><li><a href="#OpticSim.CircularAperture-Union{Tuple{T}, Tuple{T, StaticArraysCore.SVector{3, T}, StaticArraysCore.SVector{3, T}}} where T&lt;:Real"><code>OpticSim.CircularAperture</code></a></li><li><a href="#OpticSim.ConicLens-Union{Tuple{S}, Tuple{T}, Tuple{Q}, Tuple{R}, Tuple{T, Vararg{S, 7}}} where {R&lt;:AbstractGlass, Q&lt;:AbstractGlass, T&lt;:AbstractGlass, S&lt;:Real}"><code>OpticSim.ConicLens</code></a></li><li><a href="#OpticSim.Cuboid-Union{Tuple{T}, Tuple{T, T, T}} where T&lt;:Real"><code>OpticSim.Cuboid</code></a></li><li><a href="#OpticSim.Data.ArizonaEye-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T&lt;:Real"><code>OpticSim.Data.ArizonaEye</code></a></li><li><a href="#OpticSim.Data.ModelEye-Union{Tuple{LensAssembly{T}}, Tuple{D}, Tuple{T}} where {T&lt;:Real, D&lt;:Real}"><code>OpticSim.Data.ModelEye</code></a></li><li><a href="#OpticSim.Data.comfortable_entrance_pupil_translation-Tuple{}"><code>OpticSim.Data.comfortable_entrance_pupil_translation</code></a></li><li><a href="#OpticSim.Data.cornea_to_eyecenter-Tuple{}"><code>OpticSim.Data.cornea_to_eyecenter</code></a></li><li><a href="#OpticSim.Data.entrancepupil_to_eyecenter-Tuple{}"><code>OpticSim.Data.entrancepupil_to_eyecenter</code></a></li><li><a href="#OpticSim.Data.eyefocallength-Tuple{}"><code>OpticSim.Data.eyefocallength</code></a></li><li><a href="#OpticSim.Data.ùêÉsd-Tuple{Any, Any}"><code>OpticSim.Data.ùêÉsd</code></a></li><li><a href="#OpticSim.Emitters.apply"><code>OpticSim.Emitters.apply</code></a></li><li><a href="#OpticSim.Emitters.collimatedemitter-Union{Tuple{T}, Tuple{AbstractVector{T}, Any}} where T&lt;:Real"><code>OpticSim.Emitters.collimatedemitter</code></a></li><li><a href="#OpticSim.Emitters.generate"><code>OpticSim.Emitters.generate</code></a></li><li><a href="#OpticSim.Emitters.pointemitter-Union{Tuple{T}, Tuple{AbstractVector{T}, Any}} where T&lt;:Real"><code>OpticSim.Emitters.pointemitter</code></a></li><li><a href="#OpticSim.Emitters.visual_size"><code>OpticSim.Emitters.visual_size</code></a></li><li><a href="#OpticSim.EvenAsphericSurface-Union{Tuple{T}, Tuple{T, T, T, Vector{T}}} where T&lt;:Real"><code>OpticSim.EvenAsphericSurface</code></a></li><li><a href="#OpticSim.FresnelLens-Union{Tuple{H}, Tuple{G}, Tuple{T}, Tuple{G, Vararg{T, 5}}} where {T&lt;:Real, G&lt;:AbstractGlass, H&lt;:AbstractGlass}"><code>OpticSim.FresnelLens</code></a></li><li><a href="#OpticSim.Geometry.decomposeRTS-Union{Tuple{OpticSim.Geometry.Transform{T}}, Tuple{T}} where T&lt;:Real"><code>OpticSim.Geometry.decomposeRTS</code></a></li><li><a href="#OpticSim.Geometry.forward-Tuple{OpticSim.Geometry.Transform{&lt;:Real}}"><code>OpticSim.Geometry.forward</code></a></li><li><a href="#OpticSim.Geometry.identitytransform-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T&lt;:Real"><code>OpticSim.Geometry.identitytransform</code></a></li><li><a href="#OpticSim.Geometry.local2world-Union{Tuple{OpticSim.Geometry.Transform{T}}, Tuple{T}} where T&lt;:Real"><code>OpticSim.Geometry.local2world</code></a></li><li><a href="#OpticSim.Geometry.right-Tuple{OpticSim.Geometry.Transform{&lt;:Real}}"><code>OpticSim.Geometry.right</code></a></li><li><a href="#OpticSim.Geometry.rotation-Union{Tuple{T}, Tuple{T, T, T}} where T&lt;:Number"><code>OpticSim.Geometry.rotation</code></a></li><li><a href="#OpticSim.Geometry.rotation-Union{Tuple{OpticSim.Geometry.Transform{T}}, Tuple{T}} where T&lt;:Real"><code>OpticSim.Geometry.rotation</code></a></li><li><a href="#OpticSim.Geometry.rotationX-Tuple{T} where T&lt;:Real"><code>OpticSim.Geometry.rotationX</code></a></li><li><a href="#OpticSim.Geometry.rotationY-Tuple{T} where T&lt;:Real"><code>OpticSim.Geometry.rotationY</code></a></li><li><a href="#OpticSim.Geometry.rotationZ-Tuple{T} where T&lt;:Real"><code>OpticSim.Geometry.rotationZ</code></a></li><li><a href="#OpticSim.Geometry.rotationd-Union{Tuple{T}, Tuple{T, T, T}} where T&lt;:Number"><code>OpticSim.Geometry.rotationd</code></a></li><li><a href="#OpticSim.Geometry.rotmat-Union{Tuple{T}, Tuple{T, T, T}} where T&lt;:Number"><code>OpticSim.Geometry.rotmat</code></a></li><li><a href="#OpticSim.Geometry.rotmatd-Union{Tuple{T}, Tuple{T, T, T}} where T&lt;:Number"><code>OpticSim.Geometry.rotmatd</code></a></li><li><a href="#OpticSim.Geometry.scale-Union{Tuple{StaticArraysCore.SVector{3, T}}, Tuple{T}} where T&lt;:Real"><code>OpticSim.Geometry.scale</code></a></li><li><a href="#OpticSim.Geometry.scale-Tuple{T} where T&lt;:Real"><code>OpticSim.Geometry.scale</code></a></li><li><a href="#OpticSim.Geometry.scale-Union{Tuple{T}, Tuple{T, T, T}} where T&lt;:Real"><code>OpticSim.Geometry.scale</code></a></li><li><a href="#OpticSim.Geometry.translation-Union{Tuple{StaticArraysCore.SVector{3, T}}, Tuple{T}} where T&lt;:Real"><code>OpticSim.Geometry.translation</code></a></li><li><a href="#OpticSim.Geometry.translation-Union{Tuple{S}, Tuple{T}, Tuple{Type{S}, T, T, T}} where {T&lt;:Number, S&lt;:Real}"><code>OpticSim.Geometry.translation</code></a></li><li><a href="#OpticSim.Geometry.unitW4-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T&lt;:Real"><code>OpticSim.Geometry.unitW4</code></a></li><li><a href="#OpticSim.Geometry.unitX3-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T&lt;:Real"><code>OpticSim.Geometry.unitX3</code></a></li><li><a href="#OpticSim.Geometry.unitX4-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T&lt;:Real"><code>OpticSim.Geometry.unitX4</code></a></li><li><a href="#OpticSim.Geometry.unitY3-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T&lt;:Real"><code>OpticSim.Geometry.unitY3</code></a></li><li><a href="#OpticSim.Geometry.unitY4-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T&lt;:Real"><code>OpticSim.Geometry.unitY4</code></a></li><li><a href="#OpticSim.Geometry.unitZ3-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T&lt;:Real"><code>OpticSim.Geometry.unitZ3</code></a></li><li><a href="#OpticSim.Geometry.unitZ4-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T&lt;:Real"><code>OpticSim.Geometry.unitZ4</code></a></li><li><a href="#OpticSim.Geometry.up-Tuple{OpticSim.Geometry.Transform{&lt;:Real}}"><code>OpticSim.Geometry.up</code></a></li><li><a href="#OpticSim.Geometry.world2local-Union{Tuple{OpticSim.Geometry.Transform{T}}, Tuple{T}} where T&lt;:Real"><code>OpticSim.Geometry.world2local</code></a></li><li><a href="#OpticSim.HexagonalPrism-Union{Tuple{T}, Tuple{T, T}} where T&lt;:Real"><code>OpticSim.HexagonalPrism</code></a></li><li><a href="#OpticSim.OddAsphericSurface-Union{Tuple{T}, Tuple{T, T, T, Vector{T}}} where T&lt;:Real"><code>OpticSim.OddAsphericSurface</code></a></li><li><a href="#OpticSim.OddEvenAsphericSurface-Union{Tuple{T}, Tuple{T, T, T, Vector{T}}} where T&lt;:Real"><code>OpticSim.OddEvenAsphericSurface</code></a></li><li><a href="#OpticSim.RectangularAperture-Union{Tuple{T}, Tuple{T, T, StaticArraysCore.SVector{3, T}, StaticArraysCore.SVector{3, T}}} where T&lt;:Real"><code>OpticSim.RectangularAperture</code></a></li><li><a href="#OpticSim.RectangularAperture-Union{Tuple{T}, Tuple{T, T, T, T, StaticArraysCore.SVector{3, T}, StaticArraysCore.SVector{3, T}}} where T&lt;:Real"><code>OpticSim.RectangularAperture</code></a></li><li><a href="#OpticSim.RectangularPrism-Union{Tuple{T}, Tuple{T, T}, Tuple{T, T, T}} where T&lt;:Real"><code>OpticSim.RectangularPrism</code></a></li><li><a href="#OpticSim.SphericalLens-Union{Tuple{S}, Tuple{T}, Tuple{Q}, Tuple{R}, Tuple{T, Vararg{S, 5}}} where {R&lt;:AbstractGlass, Q&lt;:AbstractGlass, T&lt;:AbstractGlass, S&lt;:Real}"><code>OpticSim.SphericalLens</code></a></li><li><a href="#OpticSim.Spider-Union{Tuple{T}, Tuple{Int64, T, T}, Tuple{Int64, T, T, StaticArraysCore.SVector{3, T}}, Tuple{Int64, T, T, StaticArraysCore.SVector{3, T}, StaticArraysCore.SVector{3, T}}} where T&lt;:Real"><code>OpticSim.Spider</code></a></li><li><a href="#OpticSim.TriangularPrism-Union{Tuple{T}, Tuple{T, T}} where T&lt;:Real"><code>OpticSim.TriangularPrism</code></a></li><li><a href="#OpticSim.asphericType-Union{Tuple{AsphericSurface{T, 3, Q, M}}, Tuple{M}, Tuple{Q}, Tuple{T}} where {T&lt;:Real, Q, M}"><code>OpticSim.asphericType</code></a></li><li><a href="#OpticSim.assembly-Union{Tuple{CSGOpticalSystem{T, D, S, L} where {D&lt;:Number, S&lt;:Surface{T}, L&lt;:LensAssembly{T}}}, Tuple{T}} where T&lt;:Real"><code>OpticSim.assembly</code></a></li><li><a href="#OpticSim.closestintersection"><code>OpticSim.closestintersection</code></a></li><li><a href="#OpticSim.closestpointonray-Union{Tuple{N}, Tuple{T}, Tuple{AbstractRay{T, N}, StaticArraysCore.SVector{N, T}}} where {T, N}"><code>OpticSim.closestpointonray</code></a></li><li><a href="#OpticSim.detectorimage-Tuple{CSGOpticalSystem}"><code>OpticSim.detectorimage</code></a></li><li><a href="#OpticSim.distancefromplane-Tuple{OpticSim.PlanarShape, StaticArraysCore.SVector{3}}"><code>OpticSim.distancefromplane</code></a></li><li><a href="#OpticSim.doesintersect-Union{Tuple{T}, Tuple{BoundingBox{T}, AbstractRay{T, 3}}} where T&lt;:Real"><code>OpticSim.doesintersect</code></a></li><li><a href="#OpticSim.inside-Union{Tuple{T}, Tuple{CSGTree{T}, T, T, T}} where T&lt;:Real"><code>OpticSim.inside</code></a></li><li><a href="#OpticSim.inside-Union{Tuple{T}, Tuple{ParametricSurface{T, 3}, T, T, T}} where T&lt;:Real"><code>OpticSim.inside</code></a></li><li><a href="#OpticSim.interface-Union{Tuple{AcceleratedParametricSurface{T, N, S} where {N, S&lt;:ParametricSurface{T, N}}}, Tuple{T}} where T&lt;:Real"><code>OpticSim.interface</code></a></li><li><a href="#OpticSim.intersections-Union{Tuple{N}, Tuple{T}, Tuple{AbstractRay{T, N}, Matrix{T}}} where {T&lt;:Real, N}"><code>OpticSim.intersections</code></a></li><li><a href="#OpticSim.leaf-Union{Tuple{ParametricSurface{T}}, Tuple{T}, Tuple{ParametricSurface{T}, OpticSim.Geometry.Transform{T}}} where T&lt;:Real"><code>OpticSim.leaf</code></a></li><li><a href="#OpticSim.makemesh-Union{Tuple{ConvexPolygon{N, T}}, Tuple{T}, Tuple{N}, Tuple{ConvexPolygon{N, T}, Int64}} where {N, T&lt;:Real}"><code>OpticSim.makemesh</code></a></li><li><a href="#OpticSim.makemesh-Union{Tuple{ParametricSurface{S, N}}, Tuple{N}, Tuple{S}, Tuple{ParametricSurface{S, N}, Int64}} where {S, N}"><code>OpticSim.makemesh</code></a></li><li><a href="#OpticSim.normal-Union{Tuple{T}, Tuple{ParametricSurface{T}, T, T}} where T&lt;:Real"><code>OpticSim.normal</code></a></li><li><a href="#OpticSim.onsurface-Union{Tuple{T}, Tuple{ParametricSurface{T, 3}, T, T, T}} where T&lt;:Real"><code>OpticSim.onsurface</code></a></li><li><a href="#OpticSim.onsurface-Union{Tuple{T}, Tuple{CSGTree{T}, T, T, T}} where T&lt;:Real"><code>OpticSim.onsurface</code></a></li><li><a href="#OpticSim.origin-Tuple{OpticSim.Geometry.Transform{&lt;:Real}}"><code>OpticSim.origin</code></a></li><li><a href="#OpticSim.partials-Union{Tuple{T}, Tuple{ParametricSurface{T}, T, T}} where T&lt;:Real"><code>OpticSim.partials</code></a></li><li><a href="#OpticSim.point-Union{Tuple{T}, Tuple{ParametricSurface{T}, T, T}} where T&lt;:Real"><code>OpticSim.point</code></a></li><li><a href="#OpticSim.point-Union{Tuple{T}, Tuple{N}, Tuple{Rectangle{T}, StaticArraysCore.SMatrix{2, N, T}}} where {N, T&lt;:Real}"><code>OpticSim.point</code></a></li><li><a href="#OpticSim.point-Union{Tuple{T}, Tuple{Rectangle{T}, T, T}} where T&lt;:Real"><code>OpticSim.point</code></a></li><li><a href="#OpticSim.point-Tuple{OpticSim.VirtualPoint}"><code>OpticSim.point</code></a></li><li><a href="#OpticSim.point-Union{Tuple{T}, Tuple{N}, Tuple{AbstractRay{T, N}, T}} where {N, T&lt;:Real}"><code>OpticSim.point</code></a></li><li><a href="#OpticSim.pressure-Union{Tuple{CSGOpticalSystem{T, D, S, L} where {D&lt;:Number, S&lt;:Surface{T}, L&lt;:LensAssembly{T}}}, Tuple{T}} where T&lt;:Real"><code>OpticSim.pressure</code></a></li><li><a href="#OpticSim.reset!-Union{Tuple{HierarchicalImage{T}}, Tuple{T}} where T"><code>OpticSim.reset!</code></a></li><li><a href="#OpticSim.resetdetector!-Union{Tuple{CSGOpticalSystem{T, D, S, L} where {D&lt;:Number, S&lt;:Surface{T}, L&lt;:LensAssembly{T}}}, Tuple{T}} where T&lt;:Real"><code>OpticSim.resetdetector!</code></a></li><li><a href="#OpticSim.samplesurface-Union{Tuple{N}, Tuple{T}, Tuple{ParametricSurface{T, N}, Function}, Tuple{ParametricSurface{T, N}, Function, Int64}} where {T&lt;:Real, N}"><code>OpticSim.samplesurface</code></a></li><li><a href="#OpticSim.semidiameter-Tuple{AxisymmetricOpticalSystem}"><code>OpticSim.semidiameter</code></a></li><li><a href="#OpticSim.sphericalcircle"><code>OpticSim.sphericalcircle</code></a></li><li><a href="#OpticSim.sum!-Union{Tuple{T}, Tuple{HierarchicalImage{T}, HierarchicalImage{T}}} where T"><code>OpticSim.sum!</code></a></li><li><a href="#OpticSim.surfaceintersection-Union{Tuple{N}, Tuple{T}, Tuple{CSGTree{T}, AbstractRay{T, N}}} where {T&lt;:Real, N}"><code>OpticSim.surfaceintersection</code></a></li><li><a href="#OpticSim.surfaceintersection-Union{Tuple{N}, Tuple{T}, Tuple{AcceleratedParametricSurface{T, N, S} where S&lt;:ParametricSurface{T, N}, AbstractRay{T, N}}} where {T, N}"><code>OpticSim.surfaceintersection</code></a></li><li><a href="#OpticSim.surfaceintersection-Union{Tuple{T}, Tuple{BoundingBox{T}, AbstractRay{T, 3}}} where T&lt;:Real"><code>OpticSim.surfaceintersection</code></a></li><li><a href="#OpticSim.temperature-Union{Tuple{CSGOpticalSystem{T, D, S, L} where {D&lt;:Number, S&lt;:Surface{T}, L&lt;:LensAssembly{T}}}, Tuple{T}} where T&lt;:Real"><code>OpticSim.temperature</code></a></li><li><a href="#OpticSim.trace-Union{Tuple{N}, Tuple{T}, Tuple{LensAssembly{T}, OpticalRay{T, N}}, Tuple{LensAssembly{T}, OpticalRay{T, N}, T}, Tuple{LensAssembly{T}, OpticalRay{T, N}, T, T}} where {T&lt;:Real, N}"><code>OpticSim.trace</code></a></li><li><a href="#OpticSim.trace-Union{Tuple{D}, Tuple{N}, Tuple{T}, Tuple{CSGOpticalSystem{T, D, S, L} where {S&lt;:Surface{T}, L&lt;:LensAssembly{T}}, OpticalRay{T, N}}} where {T&lt;:Real, N, D&lt;:Number}"><code>OpticSim.trace</code></a></li><li><a href="#OpticSim.trace-Union{Tuple{T}, Tuple{CSGOpticalSystem{T, D, S, L} where {D&lt;:Number, S&lt;:Surface{T}, L&lt;:LensAssembly{T}}, OpticalRayGenerator{T}}} where T&lt;:Real"><code>OpticSim.trace</code></a></li><li><a href="#OpticSim.traceMT-Union{Tuple{S}, Tuple{T}, Tuple{CSGOpticalSystem{T, S, S1, L} where {S1&lt;:Surface{T}, L&lt;:LensAssembly{T}}, OpticalRayGenerator{T}}} where {T&lt;:Real, S&lt;:Number}"><code>OpticSim.traceMT</code></a></li><li><a href="#OpticSim.tracehits-Union{Tuple{T}, Tuple{CSGOpticalSystem{T, D, S, L} where {D&lt;:Number, S&lt;:Surface{T}, L&lt;:LensAssembly{T}}, OpticalRayGenerator{T}}} where T&lt;:Real"><code>OpticSim.tracehits</code></a></li><li><a href="#OpticSim.tracehitsMT-Union{Tuple{T}, Tuple{CSGOpticalSystem{T, D, S, L} where {D&lt;:Number, S&lt;:Surface{T}, L&lt;:LensAssembly{T}}, OpticalRayGenerator{T}}} where T&lt;:Real"><code>OpticSim.tracehitsMT</code></a></li><li><a href="#OpticSim.triangulate-Union{Tuple{N}, Tuple{T}, Tuple{ParametricSurface{T, N}, Int64}, Tuple{ParametricSurface{T, N}, Int64, Bool}, Tuple{ParametricSurface{T, N}, Int64, Bool, Bool}, Tuple{ParametricSurface{T, N}, Int64, Bool, Bool, Bool}, Tuple{ParametricSurface{T, N}, Int64, Vararg{Bool, 4}}} where {T, N}"><code>OpticSim.triangulate</code></a></li><li><a href="#OpticSim.uv-Union{Tuple{T}, Tuple{ParametricSurface{T, 3}, T, T, T}} where T&lt;:Real"><code>OpticSim.uv</code></a></li><li><a href="#OpticSim.uvrange-Tuple{S} where S&lt;:ParametricSurface"><code>OpticSim.uvrange</code></a></li><li><a href="#OpticSim.vertices-Tuple{OpticSim.PlanarShape}"><code>OpticSim.vertices</code></a></li><li><a href="#OpticSim.vertices-Tuple{ParaxialLens}"><code>OpticSim.vertices</code></a></li><li><a href="#OpticSim.vertices-Union{Tuple{Rectangle{T}}, Tuple{T}, Tuple{Rectangle{T}, Int64}} where T&lt;:Real"><code>OpticSim.vertices</code></a></li><li><a href="#OpticSim.vertices3d-Union{Tuple{Hexagon{T}}, Tuple{T}} where T&lt;:Real"><code>OpticSim.vertices3d</code></a></li><li><a href="#OpticSim.vertices3d-Union{Tuple{Rectangle{T}}, Tuple{T}, Tuple{Rectangle{T}, Int64}} where T&lt;:Real"><code>OpticSim.vertices3d</code></a></li><li><a href="#OpticSim.virtualpoint-Union{Tuple{T}, Tuple{ParaxialLens{T}, AbstractVector{T}}} where T"><code>OpticSim.virtualpoint</code></a></li></ul><h2 id="OpticSim"><a class="docs-heading-anchor" href="#OpticSim">OpticSim</a><a id="OpticSim-1"></a><a class="docs-heading-anchor-permalink" href="#OpticSim" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.AbstractOpticalSystem" href="#OpticSim.AbstractOpticalSystem"><code>OpticSim.AbstractOpticalSystem</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractOpticalSystem{T&lt;:Real}</code></pre><p>Abstract type for any optical system, must parameterized by the datatype of entities within the system <code>T</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Optical/OpticalSystem.jl#L14-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.AcceleratedParametricSurface" href="#OpticSim.AcceleratedParametricSurface"><code>OpticSim.AcceleratedParametricSurface</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AcceleratedParametricSurface{T,N,S} &lt;: ParametricSurface{T,N}</code></pre><p>Wrapper class for <a href="#OpticSim.ParametricSurface"><code>ParametricSurface</code></a>s where analytical intersection isn&#39;t feasible (e.g. <a href="#OpticSim.ZernikeSurface"><code>ZernikeSurface</code></a>, <a href="#OpticSim.ChebyshevSurface"><code>ChebyshevSurface</code></a>). The surface is instead triangulated and an iterative (newton raphson) process carried out to determine precise ray intersection points. <code>S</code> is the type of the ParametricSurface being wrapped.</p><pre><code class="language-julia hljs">AcceleratedParametricSurface(surf::ParametricSurface{T,N}, numsamples::Int = 17; interface::NullOrFresnel{T} = nullinterface(T))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/AccelSurface.jl#L5-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.AsphericSurface" href="#OpticSim.AsphericSurface"><code>OpticSim.AsphericSurface</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AsphericSurface{T,N,Q,M} &lt;: ParametricSurface{T,N}</code></pre><p>Surface incorporating an aspheric polynomial - radius, conic and aspherics are defined relative to absolute semi-diameter,. <code>T</code> is the datatype, <code>N</code> is the dimensionality, <code>Q</code> is the number of aspheric terms, and <code>M</code> is the type of aspheric polynomial. </p><pre><code class="language-julia hljs">AsphericSurface(semidiameter; radius, conic, aspherics=nothing, normradius = semidiameter)</code></pre><p>The surface is centered at the origin and treated as being the cap of an infinite cylinder, thus creating a true half-space. Outside of <code>0 &lt;= œÅ &lt;= 1</code> the height of the surface is not necessarily well defined, so NaN may be returned.</p><p><code>aspherics</code>  aspherics should be vectors containing tuples of the form (i, v) where i is the polynomial power of the aspheric term. An empty vector is not permitted. Use <code>nothing</code> instead.</p><p>The sag is defined by the equation</p><p class="math-container">\[z(r,\phi) = \frac{cr^2}{1 + \sqrt{1 - (1+k)c^2r^2}} + \sum_{i}^{Q}\alpha_ir^{i}\]</p><p>where <span>$\rho = \frac{r}{\texttt{normradius}}$</span>, <span>$c = \frac{1}{\texttt{radius}}$</span>, and <span>$k = \texttt{conic}$</span> .</p><p>The function checks if the aspheric terms are missing, even, odd or both and uses an efficient polynomial evaluation strategy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/Primitives/AsphericSurface.jl#L16-L43">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.AxisymmetricOpticalSystem" href="#OpticSim.AxisymmetricOpticalSystem"><code>OpticSim.AxisymmetricOpticalSystem</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AxisymmetricOpticalSystem{T,C&lt;:CSGOpticalSystem{T}} &lt;: AbstractOpticalSystem{T}</code></pre><p>Optical system which has lens elements and an image detector, created from a <code>DataFrame</code> containing prescription data.</p><p>These tags are supported for columns: <code>:Radius</code>, <code>:SemiDiameter</code>, <code>:SurfaceType</code>, <code>:Thickness</code>, <code>:Conic</code>, <code>:Parameters</code>, <code>:Reflectance</code>, <code>:Material</code>.</p><p>These tags are supported for entries in a <code>SurfaceType</code> column: <code>Object</code>, <code>Image</code>, <code>Stop</code>. Assumes the <code>Image</code> row will be the last row in the <code>DataFrame</code>.</p><p>In practice a <a href="#OpticSim.CSGOpticalSystem"><code>CSGOpticalSystem</code></a> is generated automatically and stored within this system.</p><pre><code class="language-julia hljs">AxisymmetricOpticalSystem{T}(
    prescription::DataFrame,
    detectorpixelsx = 1000,
    detectorpixelsy:: = 1000,
    ::Type{D} = Float32;
    temperature = AGFFileReader.TEMP_REF,
    pressure = AGFFileReader.PRESSURE_REF
)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Optical/OpticalSystem.jl#L284-L307">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.BSplineCurve" href="#OpticSim.BSplineCurve"><code>OpticSim.BSplineCurve</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BSplineCurve{P,S,N,M} &lt;: Spline{P,S,N,M}</code></pre><p><code>N</code> is the spatial dimension of the curve. <code>M</code> is the curve order, i.e., the highest power of the parameterizing variable, <code>u</code>. All curve segments are assumed to be of the same order.</p><pre><code class="language-julia hljs">BSplineCurve{P,S,N,M}(knots::KnotVector{S}, controlpoints::AbstractArray{MVector{N,S},1})</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/Primitives/Curves/BSpline.jl#L5-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.BSplineSurface" href="#OpticSim.BSplineSurface"><code>OpticSim.BSplineSurface</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BSplineSurface{P,S,N,M} &lt;: SplineSurface{P,S,N,M}</code></pre><p>Curve order is the same in the u and v direction and fixed over all spans. u and v knot vectors are allowed to be different - <em>may change this to make them both the same</em>.</p><p>Control points in the u direction correspond to columns, with the lowest value of u corresponding to row 1. Control points in the v direction correspond to rows, with the lowest value of v corresponding to col 1.</p><div class="admonition is-danger" id="Danger-3913cf312eff98c9"><header class="admonition-header">Danger<a class="admonition-anchor" href="#Danger-3913cf312eff98c9" title="Permalink"></a></header><div class="admonition-body"><p>This surface does not create a valid half-space, requires updates to function correctly.</p></div></div><pre><code class="language-julia hljs">BSplineSurface{P,S,N,M}(knots::KnotVector{S}, controlpoints::AbstractArray{&lt;:AbstractArray{S,1},2})
BSplineSurface{P,S,N,M}(uknots::KnotVector{S}, vknots::KnotVector{S}, controlpoints::AbstractArray{&lt;:AbstractArray{S,1},2})</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/Primitives/Curves/BSpline.jl#L58-L74">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.BeamState" href="#OpticSim.BeamState"><code>OpticSim.BeamState</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>ConvergingBeam</code>, <code>DivergingBeam</code> or <code>CollimatedBeam</code>, defines the behavior of a beam in a <a href="#OpticSim.HologramInterface"><code>HologramInterface</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Optical/OpticalInterface.jl#L196-L198">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.BezierCurve" href="#OpticSim.BezierCurve"><code>OpticSim.BezierCurve</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BezierCurve{P,S,N,M} &lt;: Spline{P,S,N,M}</code></pre><p><code>N</code> is the dimension of the curve, <code>M</code> is the curve order</p><pre><code class="language-julia hljs">BezierCurve{P,S,N,M}(controlpoints::AbstractArray{&lt;:AbstractArray{S,1},1})</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/Primitives/Curves/Bezier.jl#L5-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.BezierSurface" href="#OpticSim.BezierSurface"><code>OpticSim.BezierSurface</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BezierSurface{P,S,N,M} &lt;: SplineSurface{P,S,N,M}</code></pre><p>Bezier surface defined by grid of control points.</p><div class="admonition is-danger" id="Danger-3913cf312eff98c9"><header class="admonition-header">Danger<a class="admonition-anchor" href="#Danger-3913cf312eff98c9" title="Permalink"></a></header><div class="admonition-body"><p>This surface does not create a valid half-space, requires updates to function correctly.</p></div></div><pre><code class="language-julia hljs">BezierSurface{P,S,N,M}(controlpoints::AbstractArray{&lt;:AbstractArray{S,1},2})</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/Primitives/Curves/Bezier.jl#L61-L72">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.BoundingBox" href="#OpticSim.BoundingBox"><code>OpticSim.BoundingBox</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BoundingBox{T&lt;:Real}</code></pre><p>Axis-aligned three-dimensional bounding box.</p><pre><code class="language-julia hljs">BoundingBox(xmin::T, xmax::T, ymin::T, ymax::T, zmin::T, zmax::T)
BoundingBox(s::Surface{T})
BoundingBox(s::ParametricSurface{T,3}, transform::Transform{T} = identitytransform(T))
BoundingBox(c::CSGTree{T})
BoundingBox(tri::Triangle{T})
BoundingBox(triangles::AbstractVector{Triangle{T}})
BoundingBox(points::AbstractArray{SVector{3,T}})
BoundingBox(la::LensAssembly{T})</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/BoundingBox.jl#L5-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.CSGGenerator" href="#OpticSim.CSGGenerator"><code>OpticSim.CSGGenerator</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CSGGenerator{T&lt;:Real}</code></pre><p>This is the type you should use when making CSG objects. This type allows for the construction of <a href="#OpticSim.CSGTree"><code>CSGTree</code></a> objects with different transforms. When the generator is evaluated, all transforms are propagated down to the <a href="../csg/#OpticSim.LeafNode-csg"><code>LeafNode</code></a>s and stored there.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">a = Cylinder(1.0,1.0)
b = Plane([0.0,0.0,1.0], [0.0,0.0,0.0])
generator = a ‚à© b
# now make a csg object that can be ray traced
csgobj = generator(Transform(1.0,1.0,2.0))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/CSG/CSG.jl#L94-L109">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.CSGOpticalSystem" href="#OpticSim.CSGOpticalSystem"><code>OpticSim.CSGOpticalSystem</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CSGOpticalSystem{T,D&lt;:Real,S&lt;:Surface{T},L&lt;:LensAssembly{T}} &lt;: AbstractOpticalSystem{T}</code></pre><p>An optical system containing a lens assembly with all optical elements and a detector surface with associated image. The system can be at a specified temperature and pressure.</p><p>There are two number types in the type signature. The <code>T</code> type parameter is the numeric type for geometry in the optical system, the <code>D</code> type parameter is the numeric type of the pixels in the detector image. This way you can have <code>Float64</code> geometry, where high precision is essential, but the pixels in the detector can be <code>Float32</code> since precision is much less critical for image data, or Complex if doing wave optic simulations.</p><p>The detector can be any <a href="#OpticSim.Surface"><code>Surface</code></a> which implements <a href="../primitives/#OpticSim.uv-primitives"><code>uv</code></a>, <a href="../primitives/#OpticSim.uvtopix-primitives"><code>uvtopix</code></a> and <a href="../csg/#OpticSim.onsurface-Union{Tuple{T}, Tuple{CSGTree{T}, T, T, T}} where T&lt;:Real-csg"><code>onsurface</code></a>, typically this is one of <a href="#OpticSim.Rectangle"><code>Rectangle</code></a>, <a href="#OpticSim.Ellipse"><code>Ellipse</code></a> or <a href="#OpticSim.SphericalCap"><code>SphericalCap</code></a>.</p><pre><code class="language-julia hljs">CSGOpticalSystem(
    assembly::LensAssembly,
    detector::Surface,
    detectorpixelsx = 1000,
    detectorpixelsy = 1000, ::Type{D} = Float32;
    temperature = AGFFileReader.TEMP_REF,
    pressure = AGFFileReader.PRESSURE_REF
)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Optical/OpticalSystem.jl#L21-L45">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.CSGTree" href="#OpticSim.CSGTree"><code>OpticSim.CSGTree</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Abstract type representing any evaluated CSG structure.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/CSG/CSG.jl#L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.ChebyshevSurface" href="#OpticSim.ChebyshevSurface"><code>OpticSim.ChebyshevSurface</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ChebyshevSurface{T,N,P,Q} &lt;: ParametricSurface{T,N}</code></pre><p>Rectangular surface incorporating Chebyshev polynomials as well as radius and conic terms. <code>T</code> is the datatype, <code>N</code> is the dimensionality, <code>P</code> is the number of Chebyshev terms in u and <code>Q</code> is the number of Chebyshev terms in v.</p><p>The surface is centered at the origin and treated as being the cap of an infinite rectangular prism, thus creating a true half-space. <strong>Note that the surface is vertically offset so that the center (i.e., <code>(u,v) == (0,0)</code>) lies at 0 on the z-axis.</strong></p><pre><code class="language-julia hljs">ChebyshevSurface(halfsizeu, halfsizev, chebycoeff; radius = Inf, conic = 0)</code></pre><p><code>chebycoeff</code> is a vector containing tuples of the form <code>(i, j, v)</code> where <code>v</code> is the value of the coefficient <span>$c_{ij}$</span>.</p><p>The sag is defined by the equation</p><p class="math-container">\[z(u,v) = \frac{c(u^2 + v^2)^2}{1 + \sqrt{1 - (1+k)c^2(u^2 + v^2)}} + \sum_{i}^{P}\sum_{j}^{Q}c_{ij}T_i(u)T_j(v)\]</p><p>where <span>$c = \frac{1}{\texttt{radius}}$</span>, <span>$k = \texttt{conic}$</span> and <span>$T_n$</span> is the n·µó ∞ Chebyshev polynomial of the first kind.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/Primitives/Chebyshev.jl#L92-L114">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.ConvexPolygon" href="#OpticSim.ConvexPolygon"><code>OpticSim.ConvexPolygon</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ConvexPolygon{N, T&lt;:Real} &lt;: PlanarShape{T}</code></pre><p>General Convex Polygon surface, not a valid CSG object. The rotation of the polygon around its normal is defined by <code>rotationvec</code>. <code>rotationvec√ósurfacenormal</code> is taken as the vector along the u axis.</p><pre><code class="language-julia hljs">ConvexPolygon(local_frame::Transform{T}, local_polygon_points::Vector{SVector{2, T}}, interface::NullOrFresnel{T} = nullinterface(T))</code></pre><p>The local frame defines the plane (spans by the right and up vectors) with the plane normal given by the forward vector. the local<em>polygon</em>points are given with respect to the local frame and are 2D points. NOTE: This class uses static vectors to hold the points which will lead to more efficient performance, but should not be used with polygons with more than 20-30 points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/Primitives/NonCSG/ConvexPolygon.jl#L9-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.CurveType" href="#OpticSim.CurveType"><code>OpticSim.CurveType</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Either <code>Rational</code> or <code>Euclidean</code>, used for <a href="#OpticSim.Spline"><code>Spline</code></a>s and <a href="#OpticSim.SplineSurface"><code>SplineSurface</code></a>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/Primitives/Curves/Spline.jl#L5-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.Cylinder" href="#OpticSim.Cylinder"><code>OpticSim.Cylinder</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Cylinder{T,N} &lt;: ParametricSurface{T,N}</code></pre><p>Cylinder of infinite height centered at the origin, oriented along the z-axis. <code>visheight</code> is used for visualization purposes only, <strong>note that this does not fully represent the surface</strong>.</p><pre><code class="language-julia hljs">Cylinder(radius::T, visheight::T = 2.0; interface::NullOrFresnel{T} = nullinterface(T))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/Primitives/Cylinder.jl#L5-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.DisjointUnion" href="#OpticSim.DisjointUnion"><code>OpticSim.DisjointUnion</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Datatype representing an ordered series of disjoint intervals on a ray. An arbitrary array of <code>Interval</code>s can be input to the constructor and they will automatically be processed into a valid <code>DisjointUnion</code> (or a single <a href="#OpticSim.Interval"><code>Interval</code></a> if appropriate).</p><pre><code class="language-julia hljs">DisjointUnion(intervals::AbstractVector{Interval{R}})</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/CSG/Interval.jl#L151-L158">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.Ellipse" href="#OpticSim.Ellipse"><code>OpticSim.Ellipse</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Ellipse{T} &lt;: Surface{T}</code></pre><p>Elliptical surface, not a valid CSG object. The rotation of the rectangle around its normal is defined by <code>rotationvec</code>. <code>rotationvec√ósurfacenormal</code> is taken as the vector along the u axis.</p><p><strong>Can be used as a detector in <a href="#OpticSim.AbstractOpticalSystem"><code>AbstractOpticalSystem</code></a>s.</strong></p><pre><code class="language-julia hljs">Ellipse(halfsizeu::T, halfsizev::T, [surfacenormal::SVector{3,T}, centrepoint::SVector{3,T}]; interface::NullOrFresnel{T} = nullinterface(T))</code></pre><p>The minimal case returns an ellipse centered at the origin with <code>surfacenormal = [0, 0, 1]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/Primitives/NonCSG/Ellipse.jl#L5-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.EmptyInterval" href="#OpticSim.EmptyInterval"><code>OpticSim.EmptyInterval</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">EmptyInterval{T} &lt;: AbstractRayInterval{T}</code></pre><p>An interval with no <a href="#OpticSim.Intersection"><code>Intersection</code></a>s which is also not infinite.</p><pre><code class="language-julia hljs">EmptyInterval(T = Float64)
EmptyInterval{T}()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/CSG/Interval.jl#L7-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.FiniteStop" href="#OpticSim.FiniteStop"><code>OpticSim.FiniteStop</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FiniteStop{T,P&lt;:StopShape,Q&lt;:StopShape} &lt;: Surface{T}</code></pre><p>Stop surface with finite extent. <code>P</code> refers to the shape of the aperture and <code>Q</code> represents the shape of the bounds of the stop surface.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/Primitives/NonCSG/Stop.jl#L80-L85">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.FresnelInterface" href="#OpticSim.FresnelInterface"><code>OpticSim.FresnelInterface</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FresnelInterface{T} &lt;: OpticalInterface{T}</code></pre><p>Interface between two materials with behavior defined according to the <a href="https://en.wikipedia.org/wiki/Fresnel_equations">Fresnel equations</a>, with a specified reflectance and transmission. Assumes unpolarized light.</p><pre><code class="language-julia hljs">FresnelInterface{T}(insidematerial, outsidematerial; reflectance = 0, transmission = 1, interfacemode = ReflectOrTransmit)</code></pre><p>The interfacemode can be used to trace rays deterministically. Valid values are defined in the InterfaceMode enum. Reflect means that all values are reflected, Transmit means that all values are transmitted. ReflectOrTransmit will randomly reflect and transmit rays with the distribution given by the reflection and transmission arguments. This is also the default. In all cases the power recorded with the ray is correctly updated. This can be used to fake sequential raytracing. For example a beamsplitter surface may be set to either Reflect or Transmit to switch between the two outgoing ray paths.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Optical/OpticalInterface.jl#L90-L106">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.GeometricRayGenerator" href="#OpticSim.GeometricRayGenerator"><code>OpticSim.GeometricRayGenerator</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GeometricRayGenerator{T,O&lt;:RayOriginGenerator{T}} &lt;: AbstractRayGenerator{T}</code></pre><p>Generates geometric <a href="#OpticSim.Ray"><code>Ray</code></a>s according to the specific implementation of the subclass.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Optical/RayGenerator.jl#L7-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.GridSagInterpolation" href="#OpticSim.GridSagInterpolation"><code>OpticSim.GridSagInterpolation</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Either <code>GridSagLinear</code> or <code>GridSagBicubic</code> - determines the interpolation between sample points in the grid for a <a href="#OpticSim.GridSagSurface"><code>GridSagSurface</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/Primitives/GridSag.jl#L5-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.GridSagSurface" href="#OpticSim.GridSagSurface"><code>OpticSim.GridSagSurface</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GridSagSurface{T,N,S&lt;:Union{ZernikeSurface{T,N},ChebyshevSurface{T,N}},Nu,Nv} &lt;: ParametricSurface{T,N}</code></pre><p>Either a Zernike (circular) or Chebyshev (rectangular) surface with grid sag height added to the base sag. The surface shape is determined by either a linear or a bicubic spline interpolation of the <code>Nu√óNv</code> grid of sag values, set by the <code>interpolation</code> argument taking either <code>GridSagLinear</code> or <code>GridSagBicubic</code>.</p><p>Each entry in the grid is a vector of the form <span>$[z, \frac{\partial z}{\partial x}, \frac{\partial z}{\partial y}, \frac{\partial^2 z}{\partial x \partial y}]$</span>. The first data item corresponds to the lower left corner of the surface, that is, the corner defined by the -u and -v limit. Each point that follows is read across the face of the surface from left to right moving upwards. If zero is given for the partials (and using bicubic interpolation) then the partials will be approximated using finite differences.</p><p>The sag grid can be decentered from the surface in uv space, if so the surface may become wild outside of the area over which the grid is defined. It is advised to clip the surface to the valid area using CSG operations in this case.</p><p>A surface can also be generated from a <code>.GRD</code> file by passing in the filename as the first and only positional argument. In this case the surface will be rectangular with optional radius and conic.</p><p>See docs for <a href="#OpticSim.ZernikeSurface"><code>ZernikeSurface</code></a> and <a href="#OpticSim.ChebyshevSurface"><code>ChebyshevSurface</code></a> for details of the base surface.</p><pre><code class="language-julia hljs">GridSagSurface(basesurface::Union{ZernikeSurface{T,N},ChebyshevSurface{T,N}}, sag_grid::AbstractArray{T,3}; interpolation = GridSagBicubic, decenteruv = (0, 0))
GridSagSurface{T}(filename::String; radius = Inf, conic = 0, interpolation = GridSagBicubic)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/Primitives/GridSag.jl#L11-L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.Hexagon" href="#OpticSim.Hexagon"><code>OpticSim.Hexagon</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Hexagon{T} &lt;: Surface{T}</code></pre><p>Hexagonal surface, not a valid CSG object. The rotation of the hexagon around its normal is defined by <code>rotationvec</code>. <code>rotationvec√ósurfacenormal</code> is taken as the vector along the u axis.</p><pre><code class="language-julia hljs">Hexagon(side_length::T, [surfacenormal::SVector{3,T}, centrepoint::SVector{3,T}]; rotationvec::SVector{3,T} = [0.0, 1.0, 0.0], interface::NullOrFresnel{T} = nullinterface(T))</code></pre><p>The minimal case returns a rectangle centered at the origin with <code>surfacenormal = [0, 0, 1]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/Primitives/NonCSG/Hexagon.jl#L5-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.HierarchicalImage" href="#OpticSim.HierarchicalImage"><code>OpticSim.HierarchicalImage</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">HierarchicalImage{T&lt;:Number} &lt;: AbstractArray{T,2}</code></pre><p>Image type which dynamically allocated memory for pixels when their value is set, the value of unset pixels is assumed to be zero.</p><p>This is used for the detector image of <a href="#OpticSim.AbstractOpticalSystem"><code>AbstractOpticalSystem</code></a>s which can typically be very high resolution, but often have a large proportion of the image blank.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Optical/HierarchicalImage.jl#L7-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.HologramInterface" href="#OpticSim.HologramInterface"><code>OpticSim.HologramInterface</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">HologramInterface{T} &lt;: OpticalInterface{T}</code></pre><p>Interface representing a <em>thick</em> hologram (though geometrically thin). The efficiency, <code>Œ∑</code>, is calculated using Kogelnik&#39;s coupled wave theory so is only valid for the first order. If the zero order is included then it has efficiency <code>1 - Œ∑</code>. Also assumes that the HOE was recorded under similar conditions to the playback conditions, <code>thickness</code> is in microns.</p><p><code>BeatState</code> arguments can be one of <code>ConvergingBeam</code>, <code>DivergingBeam</code> and <code>CollimatedBeam</code>. In the first two cases <code>signalpointordir</code> and <code>referencepointordir</code> are 3D point in global coordinate space. For <code>CollimatedBeam</code> they are normalized direction vectors.</p><p>For reference, see:</p><ul><li><em>Coupled Wave Theory for Thick Hologram Gratings</em> - H Kogelnik, 1995</li><li><em>Sequential and non-sequential simulation of volume holographic gratings</em> - M Kick et al, 2018</li></ul><pre><code class="language-julia hljs">HologramInterface(signalpointordir::SVector{3,T}, signalbeamstate::BeamState, referencepointordir::SVector{3,T}, referencebeamstate::BeamState, recordingŒª::T, thickness::T, beforematerial, substratematerial, aftermaterial, signalrecordingmaterial, referencerecordingmaterial, RImodulation::T, include0order  = false)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Optical/OpticalInterface.jl#L202-L219">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.HologramSurface" href="#OpticSim.HologramSurface"><code>OpticSim.HologramSurface</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">HologramSurface{T,S} &lt;: WrapperSurface{T,S}</code></pre><p>Surface type for use with <a href="#OpticSim.HologramInterface"><code>HologramInterface</code></a>.</p><pre><code class="language-julia hljs">HologramSurface(surface::Surface{T}, interface::HologramInterface{T})</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Optical/Grating.jl#L139-L147">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.InfiniteStop" href="#OpticSim.InfiniteStop"><code>OpticSim.InfiniteStop</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">InfiniteStop{T,P&lt;:StopShape} &lt;: Surface{T}</code></pre><p>Stop surface with infinite extent (outside of the aperture). <code>P</code> refers to the shape of the aperture.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/Primitives/NonCSG/Stop.jl#L22-L27">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.Infinity" href="#OpticSim.Infinity"><code>OpticSim.Infinity</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Infinity{T} &lt;: IntervalPoint{T}</code></pre><p>Point representing ‚àû within an <a href="#OpticSim.Interval"><code>Interval</code></a>.</p><pre><code class="language-julia hljs">Infinity(T = Float64)
Infinity{T}()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/CSG/Intersection.jl#L82-L91">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.InterfaceMode" href="#OpticSim.InterfaceMode"><code>OpticSim.InterfaceMode</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Valid modes for deterministic raytracing</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Optical/OpticalInterface.jl#L23-L25">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.Intersection" href="#OpticSim.Intersection"><code>OpticSim.Intersection</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Intersection{T,N} &lt;: IntervalPoint{T}</code></pre><p>Represents the point at which an <a href="#OpticSim.Ray"><code>Ray</code></a> hits a <a href="#OpticSim.Surface"><code>Surface</code></a>. This consists of the distance along the ray, the intersection point in world space, the normal in world space, the UV on the surface and the <a href="#OpticSim.OpticalInterface"><code>OpticalInterface</code></a> hit.</p><p>Has the following accessor methods:</p><pre><code class="language-julia hljs">point(a::Intersection{T,N}) -&gt; SVector{N,T}
normal(a::Intersection{T,N}) -&gt; SVector{N,T}
uv(a::Intersection{T,N}) -&gt; SVector{2,T}
u(a::Intersection{T,N}) -&gt; T
v(a::Intersection{T,N}) -&gt; T
Œ±(a::Intersection{T,N}) -&gt; T
interface(a::Intersection{T,N}) -&gt; OpticalInterface{T}
flippednormal(a::Intersection{T,N}) -&gt; Bool</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/CSG/Intersection.jl#L14-L31">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.Interval" href="#OpticSim.Interval"><code>OpticSim.Interval</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Interval{T} &lt;: AbstractRayInterval{T}</code></pre><p>Datatype representing an interval between two <a href="../csg/#OpticSim.IntervalPoint-csg"><code>IntervalPoint</code></a>s on a ray.</p><p>The lower element can either be <a href="#OpticSim.RayOrigin"><code>RayOrigin</code></a> or an <a href="#OpticSim.Intersection"><code>Intersection</code></a>. The upper element can either be an <a href="#OpticSim.Intersection"><code>Intersection</code></a> or <a href="#OpticSim.Infinity"><code>Infinity</code></a>.</p><pre><code class="language-julia hljs">positivehalfspace(int::Intersection) -&gt; Interval with lower = int, upper = Infinity
rayorigininterval(int::Intersection) -&gt; Interval with lower = RayOrigin, upper = int
Interval(low, high)</code></pre><p>Has the following accessor methods:</p><pre><code class="language-julia hljs">lower(a::Interval{T}) -&gt; Union{RayOrigin{T},Intersection{T,3}}
upper(a::Interval{T}) -&gt; Union{Intersection{T,3},Infinity{T}}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/CSG/Interval.jl#L23-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.KnotVector" href="#OpticSim.KnotVector"><code>OpticSim.KnotVector</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">KnotVector{T&lt;:Number}</code></pre><p>Vector to define knots used for <a href="#OpticSim.BSplineCurve"><code>BSplineCurve</code></a> and <a href="#OpticSim.BSplineSurface"><code>BSplineSurface</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/Primitives/Curves/Knots.jl#L5-L9">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.LensAssembly" href="#OpticSim.LensAssembly"><code>OpticSim.LensAssembly</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LensAssembly{T&lt;:Real}</code></pre><p>Structure which contains the elements of the optical system, these can be <a href="#OpticSim.CSGTree"><code>CSGTree</code></a> or <a href="#OpticSim.Surface"><code>Surface</code></a> objects.</p><p>In order to prevent type ambiguities bespoke structs are created for each possible number of elements e.g. <code>LensAssembly3</code>. These are parameterized by the types of the elements to prevent ambiguities. Basic surface types such as <a href="#OpticSim.Rectangle"><code>Rectangle</code></a> (which can occur in large numbers) are stored independently in <code>Vector</code>s, so type parameters are only needed for CSG objects.</p><p>Each struct looks like this:</p><pre><code class="language-julia hljs">struct LensAssemblyN{T,T1,T2,...,TN} &lt;: LensAssembly{T}
    axis::SVector{3,T}
    rectangles::Vector{Rectangle{T}}
    ellipses::Vector{Ellipse{T}}
    hexagons::Vector{Hexagon{T}}
    paraxials::Vector{ParaxialLens{T}}
    E1::T1
    E2::T2
    ...
    EN::TN
end</code></pre><p>Where <code>Ti &lt;: Union{Surface{T},CSGTree{T}}</code>.</p><p>To create a LensAssembly object the following functions can be used:</p><pre><code class="language-julia hljs">LensAssembly(elements::Vararg{Union{Surface{T},CSGTree{T},LensAssembly{T}}}; axis = SVector(0.0, 0.0, 1.0)) where {T&lt;:Real}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Optical/LensAssembly.jl#L5-L35">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.LensTrace" href="#OpticSim.LensTrace"><code>OpticSim.LensTrace</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LensTrace{T&lt;:Real,N}</code></pre><p>Contains an intersection point and the ray segment leading to it from within an optical trace. The ray carries the path length, power, wavelength, number of intersections and source number, all of which are accessible directly on this class too.</p><p>Has the following accessor methods:</p><pre><code class="language-julia hljs">ray(a::LensTrace{T,N}) -&gt; OpticalRay{T,N}
intersection(a::LensTrace{T,N}) -&gt; Intersection{T,N}
power(a::LensTrace{T,N}) -&gt; T
wavelength(a::LensTrace{T,N}) -&gt; T
pathlength(a::LensTrace{T,N}) -&gt; T
point(a::LensTrace{T,N}) -&gt; SVector{N,T}
uv(a::LensTrace{T,N}) -&gt; SVector{2,T}
sourcenum(a::LensTrace{T,N}) -&gt; Int
nhits(a::LensTrace{T,N}) -&gt; Int</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Optical/LensAssembly.jl#L271-L290">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.NullInterface" href="#OpticSim.NullInterface"><code>OpticSim.NullInterface</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">NullInterface{T} &lt;: OpticalInterface{T}</code></pre><p>Interface which will be ignored totally by any rays, used only in construction of CSG objects.</p><pre><code class="language-julia hljs">NullInterface(T = Float64)
NullInterface{T}()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Optical/OpticalInterface.jl#L31-L40">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.OpticalInterface" href="#OpticSim.OpticalInterface"><code>OpticSim.OpticalInterface</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">OpticalInterface{T&lt;:Real}</code></pre><p>Any subclass of OpticalInterface <strong>must</strong> implement the following:</p><pre><code class="language-julia hljs">processintersection(opticalinterface::OpticalInterface{T}, point::SVector{N,T}, normal::SVector{N,T}, incidentray::OpticalRay{T,N}, temperature::T, pressure::T, ::Bool, firstray::Bool = false) -&gt; Tuple{SVector{N,T}, T, T}
insidematerial(i::OpticalInterface{T}) -&gt; AGFFileReader.AbstractGlass
outsidematerial(i::OpticalInterface{T}) -&gt; AGFFileReader.AbstractGlass
reflectance(i::OpticalInterface{T}) -&gt; T
transmission(i::OpticalInterface{T}) -&gt; T</code></pre><p>See documentation for <a href="../interfaces/#OpticSim.processintersection-interfaces"><code>processintersection</code></a> for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Optical/OpticalInterface.jl#L5-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.OpticalRay" href="#OpticSim.OpticalRay"><code>OpticSim.OpticalRay</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">OpticalRay{T,N} &lt;: AbstractRay{T,N}</code></pre><p>Ray with power, wavelength and optical path length.</p><p><strong>NOTE</strong>: we use monte carlo integration to get accurate results on the detector, this means that all rays essentially hit the detector with power = 1 and some rays are thrown away at any interface to correctly match the reflection/transmission at that interface. For inspection purposes we also track the &#39;instantaneous&#39; power of the ray in the <code>power</code> field of the <code>OpticalRay</code>.</p><pre><code class="language-julia hljs">OpticalRay(ray::Ray{T,N}, power::T, wavelength::T, opl=zero(T))
OpticalRay(origin::SVector{N,T}, direction::SVector{N,T}, power::T, wavelength::T, opl=zero(T))</code></pre><p>Has the following accessor methods:</p><pre><code class="language-julia hljs">ray(r::OpticalRay{T,N}) -&gt; Ray{T,N}
direction(r::OpticalRay{T,N}) -&gt; SVector{N,T}
origin(r::OpticalRay{T,N}) -&gt; SVector{N,T}
power(r::OpticalRay{T,N}) -&gt; T
wavelength(r::OpticalRay{T,N}) -&gt; T
pathlength(r::OpticalRay{T,N}) -&gt; T
sourcepower(r::OpticalRay{T,N}) -&gt; T
nhits(r::OpticalRay{T,N}) -&gt; Int
sourcenum(r::OpticalRay{T,N}) -&gt; Int</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Optical/OpticalRay.jl#L5-L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.OpticalRayGenerator" href="#OpticSim.OpticalRayGenerator"><code>OpticSim.OpticalRayGenerator</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">OpticalRayGenerator{T} &lt;: AbstractRayGenerator{T}</code></pre><p>Generates <a href="#OpticSim.OpticalRay"><code>OpticalRay</code></a>s according to the specific implementation of the subclass.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Optical/RayGenerator.jl#L14-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.ParametricSurface" href="#OpticSim.ParametricSurface"><code>OpticSim.ParametricSurface</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ParametricSurface{T,N} &lt;: Surface{T}</code></pre><p><code>T</code> is the number type used to represent the surface, e.g., <code>Float64</code>. <code>N</code> is the dimension of the space the surface is embedded in. <code>ParametricSurface</code>s are valid CSG objects, in some cases (where analytic intersection isn&#39;t possible) they must be wrapped in an <a href="#OpticSim.AcceleratedParametricSurface"><code>AcceleratedParametricSurface</code></a> for use.</p><p><strong>Must</strong> implement the following:</p><pre><code class="language-julia hljs">uv(surface::ParametricSurface{T,N}, p::SVector{N,T}) -&gt; SVector{2,T}
uvrange(surface::ParametricSurface{T,N}) -&gt; Tuple{Tuple{T,T},Tuple{T,T}}
point(surface::ParametricSurface{T,N}, u::T, v::T) -&gt; SVector{N,T}
partials(surface::ParametricSurface{T,N}, u::T, v::T) -&gt; Tuple{SVector{N,T}, SVector{N,T}}
normal(surface::ParametricSurface{T,N}, u::T, v::T) -&gt; SVector{N,T}
inside(surface::ParametricSurface{T,N}, p: :SVector{N,T}) -&gt; Bool
onsurface(surface::ParametricSurface{T,N}, p::SVector{N,T}) -&gt; Bool
surfaceintersection(surface::ParametricSurface{T,N}, AbstractRay::Ray{T,N}) -&gt; Union{EmptyInterval{T},Interval{T},DisjointUnion{T}}
interface(surface::ParametricSurface{T,N}) -&gt; OpticalInterface{T}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/Surface.jl#L60-L79">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.ParaxialInterface" href="#OpticSim.ParaxialInterface"><code>OpticSim.ParaxialInterface</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ParaxialInterface{T} &lt;: OpticalInterface{T}</code></pre><p>Interface describing an idealized planar lens, i.e. one that is thin and with no aberrations.</p><p><strong>In general this interface should not be constructed directly, the <code>ParaxialLensEllipse</code> and <code>ParaxialLensRect</code> functions should be used to create a <a href="#OpticSim.ParaxialLens"><code>ParaxialLens</code></a> object directly.</strong></p><pre><code class="language-julia hljs">ParaxialInterface(focallength::T, centroid::SVector{3,T}, outsidematerial::Y)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Optical/OpticalInterface.jl#L56-L66">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.ParaxialLens" href="#OpticSim.ParaxialLens"><code>OpticSim.ParaxialLens</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ParaxialLens{T} &lt;: Surface{T}</code></pre><p><code>surfacenormal</code> is the <strong>output</strong> direction of the lens. Paraxial lens cannot act as the interface between two materials, hence only a single outside material is specified, by default Air.</p><p>Create with the following functions</p><pre><code class="language-julia hljs">ParaxialLensEllipse(focaldistance, halfsizeu, halfsizev, surfacenormal, centrepoint; rotationvec = [0.0, 1.0, 0.0], outsidematerial = AGFFileReader.Air, decenteruv = (0.0, 0.0))
ParaxialLensRect(focaldistance, halfsizeu, halfsizev, surfacenormal, centrepoint; rotationvec = [0.0, 1.0, 0.0], outsidematerial = AGFFileReader.Air, decenteruv = (0.0, 0.0))
ParaxialLensHex(focaldistance, side_length, surfacenormal, centrepoint; rotationvec = [0.0, 1.0, 0.0], outsidematerial = AGFFileReader.Air, decenteruv = (0.0, 0.0))
ParaxialLensConvexPoly(focaldistance, local_frame, local_polygon_points, local_center_point; outsidematerial = AGFFileReader.Air)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Optical/Paraxial.jl#L5-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.Plane" href="#OpticSim.Plane"><code>OpticSim.Plane</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Plane{T,N} &lt;: ParametricSurface{T,N}</code></pre><p>Infinite planar surface where the positive normal side is outside the surface.</p><p>By default this will not create any geometry for visualization, the optional <code>vishalfsizeu</code> and <code>vishalfsizev</code> arguments can be used to draw the plane as a rectangle for visualization <strong>note that this does not fully represent the surface</strong>. In this case, the rotation of the rectangle around the normal to the plane is defined by <code>visvec</code> - <code>surfacenormal√óvisvec</code> is taken as the vector along the u axis.</p><pre><code class="language-julia hljs">Plane(surfacenormal::SVector{N,T}, pointonplane::SVector{N,T}; interface::NullOrFresnel{T} = nullinterface(T), vishalfsizeu::T = 0.0, vishalfsizev::T = 0.0, visvec::SVector{N,T} = [0.0, 1.0, 0.0])
Plane(nx::T, ny::T, nz::T, x::T, y::T, z::T; interface::NullOrFresnel{T} = nullinterface(T), vishalfsizeu::T = 0.0, vishalfsizev::T = 0.0, visvec::SVector{N,T} = [0.0, 1.0, 0.0])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/Primitives/Plane.jl#L5-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.QTypeSurface" href="#OpticSim.QTypeSurface"><code>OpticSim.QTypeSurface</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">QTypeSurface{T,D,M,N} &lt;: ParametricSurface{T,D}</code></pre><p>Surface incorporating the QType polynomials - radius and conic are defined relative to absolute semi-diameter, QType terms are normalized according to the <code>normradius</code> parameter. <code>T</code> is the datatype, <code>D</code> is the dimensionality, <code>M</code> and <code>N</code> are the maximum QType terms used.</p><p>The surface is centered at the origin and treated as being the cap of an infinite cylinder, thus creating a true half-space. Outside of 0 &lt;= œÅ &lt;= 1 the height of the surface is not necessarily well defined, so NaN may be returned.</p><pre><code class="language-julia hljs">QTypeSurface(semidiameter; radius = Inf, conic = 0.0, Œ±coeffs = nothing, Œ≤coeffs = nothing, normradius = semidiameter)</code></pre><p><code>Œ±coeffs</code> and <code>Œ≤coeffs</code> should be a vector of tuples of the form <code>(m, n, v)</code> where <code>v</code> is the value of the coefficient <span>$Œ±_n^m$</span> or <span>$Œ≤_n^m$</span> respectively.</p><p>The sag is defined by the equation</p><p class="math-container">\[\begin{aligned}
z(r,\phi) = &amp; \frac{cr^2}{1 + \sqrt{1 - (1+k)c^2r^2}} + \frac{\sqrt{1 + kc^2r^2}}{\sqrt{1-(1+k)c^2r^2}} \cdot \\
             &amp; \left\{ \rho^2(1-\rho^2)\sum_{n=0}^{N}\alpha_n^0 Q_n^0 (\rho^2) + \sum_{m=1}^{M}\rho^m\sum_{n=0}^N \left[ \alpha_n^m\cos{m\phi} +\beta_n^m\sin{m\phi}\right]Q_n^m(\rho^2) \right\}
\end{aligned}\]</p><p>where <span>$\rho = \frac{r}{\texttt{normradius}}$</span>, <span>$c = \frac{1}{\texttt{radius}}$</span>, <span>$k = \texttt{conic}$</span> and <span>$Q_n^m$</span> is the QType polynomial index <span>$m$</span>, <span>$n$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/Primitives/Qtype.jl#L397-L422">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.Ray" href="#OpticSim.Ray"><code>OpticSim.Ray</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Ray{T,N} &lt;: AbstractRay{T,N}</code></pre><p>Purely geometric ray, defined as <code>origin + alpha * direction</code>.</p><pre><code class="language-julia hljs">Ray(origin::SVector{N,T}, direction::SVector{N,T})</code></pre><p>Has the following accessor methods:</p><pre><code class="language-julia hljs">direction(ray::Ray{T,N}) -&gt; SVector{N,T}
origin(ray::Ray{T,N}) -&gt; SVector{N,T}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/Ray.jl#L8-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.RayOrigin" href="#OpticSim.RayOrigin"><code>OpticSim.RayOrigin</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RayOrigin{T} &lt;: IntervalPoint{T}</code></pre><p>Point representing 0 within an <a href="#OpticSim.Interval"><code>Interval</code></a>, i.e. the start of the ray.</p><pre><code class="language-julia hljs">RayOrigin(T = Float64)
RayOrigin{T}()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/CSG/Intersection.jl#L96-L105">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.Rectangle" href="#OpticSim.Rectangle"><code>OpticSim.Rectangle</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Rectangle{T} &lt;: Surface{T}</code></pre><p>Rectangular surface, not a valid CSG object. The rotation of the rectangle around its normal is defined by <code>rotationvec</code>. <code>rotationvec√ósurfacenormal</code> is taken as the vector along the u axis.</p><p><strong>Can be used as a detector in <a href="#OpticSim.AbstractOpticalSystem"><code>AbstractOpticalSystem</code></a>s.</strong></p><pre><code class="language-julia hljs">Rectangle(halfsizeu::T, halfsizev::T, [surfacenormal::SVector{3,T}, centrepoint::SVector{3,T}]; rotationvec::SVector{3,T} = [0.0, 1.0, 0.0], interface::NullOrFresnel{T} = nullinterface(T))</code></pre><p>The minimal case returns a rectangle centered at the origin with <code>surfacenormal = [0, 0, 1]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/Primitives/NonCSG/Rectangle.jl#L5-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.Sphere" href="#OpticSim.Sphere"><code>OpticSim.Sphere</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Sphere{T,N} &lt;: ParametricSurface{T,N}</code></pre><p>Spherical surface centered at the origin.</p><pre><code class="language-julia hljs">Sphere(radius::T = 1.0; interface::NullOrFresnel{T} = nullinterface(T))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/Primitives/Sphere.jl#L5-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.SphericalCap" href="#OpticSim.SphericalCap"><code>OpticSim.SphericalCap</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SphericalCap{T} &lt;: ParametricSurface{T}</code></pre><p>Spherical cap surface, creates a half-space which is essentially the subtraction of a sphere from an infinite plane. Only the spherical cap itself is visualized, not the plane. The positive normal side is outside the surface.</p><p><strong>Can be used as a detector in <a href="#OpticSim.AbstractOpticalSystem"><code>AbstractOpticalSystem</code></a>s.</strong></p><pre><code class="language-julia hljs">SphericalCap(radius::T, œïmax::T, [surfacenormal::SVector{3,T}, centrepoint::SVector{3,T}]; interface::NullOrFresnel{T} = nullinterface(T))</code></pre><p>The minimal case returns a spherical cap centered at the origin with <code>surfacenormal = [0, 0, 1]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/Primitives/SphericalCap.jl#L5-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.SphericalPolygon" href="#OpticSim.SphericalPolygon"><code>OpticSim.SphericalPolygon</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>SphericalPolygon uses StaticArrays to represent vertices. Expect performance degradation for polygons with large numbers of vertices. Performance appears to be good up to perhaps 100 vertices, perhaps as much as 1000 vertices. By 10,000 vertices performance is terrible.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/SphericalPolygon.jl#L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.Spline" href="#OpticSim.Spline"><code>OpticSim.Spline</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Spline{P&lt;:CurveType,S&lt;:Number,N,M}</code></pre><p><code>M</code> is the curve order, i.e., the highest power of the parameterizing variable, u. <code>P</code> determines the <a href="#OpticSim.CurveType"><code>CurveType</code></a>.</p><p>All Spline types must implement:</p><pre><code class="language-julia hljs">point(curve,u)</code></pre><p>and have field <code>controlpolygon</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/Primitives/Curves/Spline.jl#L13-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.SplineSurface" href="#OpticSim.SplineSurface"><code>OpticSim.SplineSurface</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SplineSurface{P,S,N,M} &lt;: ParametricSurface{S,N}</code></pre><p>Curve order, <code>M</code>, is the same in the u and v direction and fixed over all spans. <code>P</code> determines the <a href="#OpticSim.CurveType"><code>CurveType</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/Primitives/Curves/Spline.jl#L27-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.Surface" href="#OpticSim.Surface"><code>OpticSim.Surface</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Surface{T&lt;:Real}</code></pre><p><code>T</code> is the number type used to represent the surface, e.g., <code>Float64</code>. Basic <code>Surface</code>s are <em>not</em> valid CSG objects, they function only in a stand-alone capacity.</p><p><strong>Must</strong> implement the following:</p><pre><code class="language-julia hljs">surfaceintersection(surface::Surface{T}, ray::AbstractRay{T,3}) -&gt; Union{EmptyInterval{T},Interval{T}}
normal(surface::Surface{T}) -&gt; SVector{3,T}
interface(surface::Surface{T}) -&gt; OpticalInterface{T}
makemesh(surface::Surface{T}) -&gt; TriangleMesh{T}</code></pre><p>In a conventional ray tracer the surface intersection function would only return the first surface the ray intersects. Because our ray tracer does CSG operations the surface intersection function intersects the ray with all leaf surfaces which are part of the CSG tree. </p><p>Each leaf surface returns one or more 1D intervals along the ray. These intervals contain the part of the ray which is inside the surface. The intervals computed at the leaves are propagated upward through the CSG tree and the CSG operations of union, intersection, and difference are applied to generate new intervals which are themselves propagated upward.</p><p>The result is a union of 1D intervals, which may be disjoint, a single interval, or empty. The union of intervals represents the parts of the ray which are inside the CSG object.</p><p>Inside is well defined for halfspaces such as cylinders and spheres which divide space into two parts, but not for Bezier or NURBS patches which generally do not enclose a volume.  For surfaces which are not halfspaces the notion of inside is defined locally by computing the angle between the incoming ray and the normal of the surface at the point of intersection. All surfaces must be defined so that the normal points to the outside of the surface. </p><p>A negative dot product between the incoming ray and the normal indicates the ray is coming from the outside of the surface and heading toward the inside. A positive dot product indicates the ray is coming from the inside of the surface and heading toward the outside.</p><p>Intervals are defined along the ray which is being intersected with the surface, so they are one dimensional. For example, assume we have a ray with origin o on the outside of a plane and an intersection with the plane at point int = o + td where t is a scalar and d is the unit direction of the ray. The inside interval will be (Intersection(t),Infinity). This interval begins at the intersection point on the plane and continues to positive infinity. The Intersection struct stores both the parametric value t and the 3D point of intersection to make various operations more efficient. But the interval operations only depend on the parametric value t.</p><p>If the origin o is on the inside of the plane then the inside interval will be (RayOrigin,Intersection(t)). Only the part of the ray from the ray origin to the intersection point is inside the plane. </p><p>It is the programmer&#39;s responsibility to return Interval results from surfaceintersection that maintain these properties.</p><p>The following must be implemented only if the surface is being used as a detector</p><pre><code class="language-julia hljs">uv(surface::Surface{T}, p::SVector{3,T}) -&gt; SVector{2,T}
uvtopix(surface::Surface{T}, uv::SVector{2,T}, imsize::Tuple{Int,Int}) -&gt; Tuple{Int,Int}
onsurface(surface::Surface{T}, p::SVector{3,T}) -&gt; Bool</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/Surface.jl#L20-L56">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.ThinGratingInterface" href="#OpticSim.ThinGratingInterface"><code>OpticSim.ThinGratingInterface</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ThinGratingInterface{T} &lt;: OpticalInterface{T}</code></pre><p>Interface representing an idealized thin grating. <code>period</code> is in microns, <code>vector</code> should lie in the plane of the surface. Transmission and reflectance can be specified for an arbitrary number of orders up to 10, selected using the <code>maxorder</code> and <code>minorder</code> parameters. If <code>nothing</code> then <code>reflectance</code> is assumed to be <strong>0</strong> and <code>transmission</code> is assumed to be <strong>1</strong>.</p><pre><code class="language-julia hljs">ThinGratingInterface(vector, period, insidematerial, outsidematerial; maxorder = 1, minorder = -1, reflectance = nothing, transmission = nothing)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Optical/OpticalInterface.jl#L140-L150">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.ThinGratingSurface" href="#OpticSim.ThinGratingSurface"><code>OpticSim.ThinGratingSurface</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ThinGratingSurface{T,S} &lt;: WrapperSurface{T,S}</code></pre><p>Surface type for use with <a href="#OpticSim.ThinGratingInterface"><code>ThinGratingInterface</code></a>.</p><pre><code class="language-julia hljs">ThinGratingSurface(surface::Surface{T}, interface::ThinGratingInterface{T})</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Optical/Grating.jl#L52-L60">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.Triangle" href="#OpticSim.Triangle"><code>OpticSim.Triangle</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Triangle{T} &lt;: Surface{T}</code></pre><p>Triangular surface, not a valid CSG object. Primarily used as a component part of <a href="#OpticSim.TriangleMesh"><code>TriangleMesh</code></a> or to enable intersection of <a href="#OpticSim.AcceleratedParametricSurface"><code>AcceleratedParametricSurface</code></a>s. Can never be used directly as an optical surface as it doesn&#39;t have an <a href="#OpticSim.OpticalInterface"><code>OpticalInterface</code></a>.</p><pre><code class="language-julia hljs">Triangle(v1::SVector{3,T}, v2::SVector{3,T}, v3::SVector{3,T}, [uv1::SVector{2,T}, uv2::SVector{2,T}, uv3::SVector{2,T}])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/Primitives/NonCSG/Triangle.jl#L5-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.TriangleMesh" href="#OpticSim.TriangleMesh"><code>OpticSim.TriangleMesh</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">TriangleMesh{T} &lt;: Surface{T}</code></pre><p>An array of <a href="#OpticSim.Triangle"><code>Triangle</code></a>s forming a mesh. Used for visualization purposes only.</p><pre><code class="language-julia hljs">TriangleMesh(tris::Vector{Triangle{T}})</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/Primitives/NonCSG/Triangle.jl#L111-L120">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.WrapperSurface" href="#OpticSim.WrapperSurface"><code>OpticSim.WrapperSurface</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">WrapperSurface{T,S&lt;:Surface{T}} &lt;: Surface{T}</code></pre><p>A generic surface type which serves as a basis for extension of <a href="#OpticSim.Surface"><code>Surface</code></a>s for custom <a href="#OpticSim.OpticalInterface"><code>OpticalInterface</code></a> subclasses. Essentially just forwards all <code>Surface</code> and <code>ParametricSurface</code> methods to a field of the <code>WrapperSurface</code> named <code>surface</code>. Also provides a generic implementation of <a href="../csg/#OpticSim.surfaceintersection-Union{Tuple{N}, Tuple{T}, Tuple{CSGTree{T}, AbstractRay{T, N}}} where {T&lt;:Real, N}-csg"><code>surfaceintersection</code></a> which tests for an intersection with the underlying surface and returns either an <a href="#OpticSim.EmptyInterval"><code>EmptyInterval</code></a> or a half space (never a closed interval).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Optical/Grating.jl#L5-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.ZernikeIndexType" href="#OpticSim.ZernikeIndexType"><code>OpticSim.ZernikeIndexType</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Either <code>ZernikeIndexingOSA</code> or <code>ZernikeIndexingNoll</code>, see <a href="https://en.wikipedia.org/wiki/Zernike_polynomials">Zernike polynomials wikipedia entry</a> for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/Primitives/Zernike.jl#L112-L114">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.ZernikeSurface" href="#OpticSim.ZernikeSurface"><code>OpticSim.ZernikeSurface</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ZernikeSurface{T,N,P,Q,M} &lt;: ParametricSurface{T,N}</code></pre><p>Surface incorporating the Zernike polynomials - radius, conic and aspherics are defined relative to absolute semi-diameter, Zernike terms are normalized according to the <code>normradius</code> parameter. <code>T</code> is the datatype, <code>N</code> is the dimensionality, <code>P</code> is the number of Zernike terms, <code>Q</code> is the number of aspheric terms and <code>M</code> is the Aspheric Type.</p><p>The surface is centered at the origin and treated as being the cap of an infinite cylinder, thus creating a true half-space. Outside of <code>0 &lt;= œÅ &lt;= 1</code> the height of the surface is not necessarily well defined, so NaN may be returned.</p><p>For convenience the input <code>zcoeff</code> can be indexed using either OSA or Noll convention, indicated using the <code>indexing</code> argument as either <code>ZernikeIndexingOSA</code> or <code>ZernikeIndexingNoll</code>.</p><pre><code class="language-julia hljs">ZernikeSurface(semidiameter, radius = Inf, conic = 0, zcoeff = nothing, aspherics = nothing, normradius = semidiameter, indexing = ZernikeIndexingOSA)</code></pre><p><code>zcoeff</code> and <code>aspherics</code> should be vectors containing tuples of the form <code>(i, v)</code> where <code>i</code> is either the index of the Zernike term for the corresponding <code>indexing</code>, or the polynomial power of the aspheric term (may be even or odd) and  <code>v</code> is the corresponding coefficient <span>$A_i$</span> or <span>$\alpha_i$</span> respectively..  <code>M</code> will be determined from the terms entered to optimize the evaluation of the aspheric polynomial.</p><p>The sag is defined by the equation</p><p class="math-container">\[z(r,\phi) = \frac{cr^2}{1 + \sqrt{1 - (1+k)c^2r^2}} + \sum_{i}^{Q}\alpha_ir^{2i} + \sum_{i}^PA_iZ_i(\rho, \phi)\]</p><p>where <span>$\rho = \frac{r}{\texttt{normradius}}$</span>, <span>$c = \frac{1}{\texttt{radius}}$</span>, <span>$k = \texttt{conic}$</span> and <span>$Z_n$</span> is the n·µó ∞ Zernike polynomial.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/Primitives/Zernike.jl#L118-L145">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.Annulus-Union{Tuple{T}, Tuple{T, T, StaticArraysCore.SVector{3, T}, StaticArraysCore.SVector{3, T}}} where T&lt;:Real" href="#OpticSim.Annulus-Union{Tuple{T}, Tuple{T, T, StaticArraysCore.SVector{3, T}, StaticArraysCore.SVector{3, T}}} where T&lt;:Real"><code>OpticSim.Annulus</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Annulus(innerradius::T, outerradius::T, surfacenormal::SVector{3,T}, centrepoint::SVector{3,T})</code></pre><p>Creates a circular aperture in a circle i.e. <code>FiniteStop{T,CircularStopShape,CircularStopShape}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/Primitives/NonCSG/Stop.jl#L243-L247">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.AsphericLens-Union{Tuple{S}, Tuple{T}, Tuple{Q}, Tuple{R}, Tuple{T, S, S, S, Union{Nothing, Array{Pair{Int64, S}, 1}}, S, S, Union{Nothing, Array{Pair{Int64, S}, 1}}, S, S}} where {R&lt;:AbstractGlass, Q&lt;:AbstractGlass, T&lt;:AbstractGlass, S&lt;:Real}" href="#OpticSim.AsphericLens-Union{Tuple{S}, Tuple{T}, Tuple{Q}, Tuple{R}, Tuple{T, S, S, S, Union{Nothing, Array{Pair{Int64, S}, 1}}, S, S, Union{Nothing, Array{Pair{Int64, S}, 1}}, S, S}} where {R&lt;:AbstractGlass, Q&lt;:AbstractGlass, T&lt;:AbstractGlass, S&lt;:Real}"><code>OpticSim.AsphericLens</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AsphericLens(insidematerial, frontvertex, frontradius, frontconic, frontaspherics, backradius, backconic, backaspherics, thickness, semidiameter;  lastmaterial = AGFFileReader.Air, nextmaterial = AGFFileReader.Air, frontsurfacereflectance = 0.0, backsurfacereflectance = 0.0, frontdecenter = (0, 0), backdecenter = (0, 0), interfacemode = ReflectOrTransmit)</code></pre><p>Cosntructs a simple cylindrical lens with front and back surfaces with a radius, conic and apsheric terms. The side walls of the lens are absorbing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Optical/Lenses.jl#L33-L37">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.BoundedCylinder-Union{Tuple{T}, Tuple{T, T}} where T&lt;:Real" href="#OpticSim.BoundedCylinder-Union{Tuple{T}, Tuple{T, T}} where T&lt;:Real"><code>OpticSim.BoundedCylinder</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BoundedCylinder(radius::T, height::T; interface::NullOrFresnel{T} = nullinterface(T)) -&gt; CSGGenerator{T}</code></pre><p>Create a cylinder with planar caps on both ends centered at <code>(0, 0, 0)</code> with axis <code>(0, 0, 1)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/Geometry.jl#L67-L71">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.Circle-Union{Tuple{T}, Tuple{T, StaticArraysCore.SVector{3, T}, StaticArraysCore.SVector{3, T}}} where T&lt;:Real" href="#OpticSim.Circle-Union{Tuple{T}, Tuple{T, StaticArraysCore.SVector{3, T}, StaticArraysCore.SVector{3, T}}} where T&lt;:Real"><code>OpticSim.Circle</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Circle(radius, [surfacenormal, centrepoint]; interface = nullinterface(T))</code></pre><p>Shortcut method to create a circle. The minimal case returns a circle centered at the origin with <code>normal = [0, 0, 1]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/Primitives/NonCSG/Ellipse.jl#L141-L145">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.CircularAperture-Union{Tuple{T}, Tuple{T, StaticArraysCore.SVector{3, T}, StaticArraysCore.SVector{3, T}}} where T&lt;:Real" href="#OpticSim.CircularAperture-Union{Tuple{T}, Tuple{T, StaticArraysCore.SVector{3, T}, StaticArraysCore.SVector{3, T}}} where T&lt;:Real"><code>OpticSim.CircularAperture</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CircularAperture(radius::T, surfacenormal::SVector{3,T}, centrepoint::SVector{3,T})</code></pre><p>Creates a circular aperture in a plane i.e. <code>InfiniteStop{T,CircularStopShape}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/Primitives/NonCSG/Stop.jl#L212-L216">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.CircularAperture-Union{Tuple{T}, Tuple{T, T, T, StaticArraysCore.SVector{3, T}, StaticArraysCore.SVector{3, T}}} where T&lt;:Real" href="#OpticSim.CircularAperture-Union{Tuple{T}, Tuple{T, T, T, StaticArraysCore.SVector{3, T}, StaticArraysCore.SVector{3, T}}} where T&lt;:Real"><code>OpticSim.CircularAperture</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CircularAperture(radius::T, outerhalfsizeu::T, outerhalfsizev::T, surfacenormal::SVector{3,T}, centrepoint::SVector{3,T}; rotationvec::SVector{3,T} = [0.0, 1.0, 0.0])</code></pre><p>Creates a circular aperture in a rectangle i.e. <code>FiniteStop{T,CircularStopShape,RectangularStopShape}</code>. The rotation of the rectangle around its normal is defined by <code>rotationvec</code>. <code>rotationvec√ósurfacenormal</code> is taken as the vector along the u axis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/Primitives/NonCSG/Stop.jl#L223-L229">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.ConicLens-Union{Tuple{S}, Tuple{T}, Tuple{Q}, Tuple{R}, Tuple{T, Vararg{S, 7}}} where {R&lt;:AbstractGlass, Q&lt;:AbstractGlass, T&lt;:AbstractGlass, S&lt;:Real}" href="#OpticSim.ConicLens-Union{Tuple{S}, Tuple{T}, Tuple{Q}, Tuple{R}, Tuple{T, Vararg{S, 7}}} where {R&lt;:AbstractGlass, Q&lt;:AbstractGlass, T&lt;:AbstractGlass, S&lt;:Real}"><code>OpticSim.ConicLens</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ConicLens(insidematerial, frontvertex, frontradius, frontconic, backradius, backconic, thickness, semidiameter;  lastmaterial = AGFFileReader.Air, nextmaterial = AGFFileReader.Air, frontsurfacereflectance = 0.0, backsurfacereflectance = 0.0, frontdecenter = (0, 0), backdecenter = (0, 0), interfacemode = ReflectOrTransmit)</code></pre><p>Constructs a simple cylindrical lens with front and back surfaces with a radius and conic term. The side walls of the lens are absorbing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Optical/Lenses.jl#L20-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.Cuboid-Union{Tuple{T}, Tuple{T, T, T}} where T&lt;:Real" href="#OpticSim.Cuboid-Union{Tuple{T}, Tuple{T, T, T}} where T&lt;:Real"><code>OpticSim.Cuboid</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Cuboid(halfsizex::T, halfsizey::T, halfsizez::T; interface::NullOrFresnel{T} = nullinterface(T)) -&gt; CSGGenerator{T}</code></pre><p>Create a cuboid centered at <code>(0, 0, 0)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/Geometry.jl#L79-L83">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.EvenAsphericSurface-Union{Tuple{T}, Tuple{T, T, T, Vector{T}}} where T&lt;:Real" href="#OpticSim.EvenAsphericSurface-Union{Tuple{T}, Tuple{T, T, T, Vector{T}}} where T&lt;:Real"><code>OpticSim.EvenAsphericSurface</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">EvenAsphericSurface(semidiameter, curvature::T, conic::T, aspherics::Vector{T}; normradius::T=semidiameter)</code></pre><p>Surface incorporating an aspheric polynomial - radius, conic and aspherics are defined relative to absolute semi-diameter.</p><p><code>aspherics</code> should be an array of the even coefficients of the aspheric polynomial starting with A2</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/Primitives/AsphericSurface.jl#L96-L104">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.FresnelLens-Union{Tuple{H}, Tuple{G}, Tuple{T}, Tuple{G, Vararg{T, 5}}} where {T&lt;:Real, G&lt;:AbstractGlass, H&lt;:AbstractGlass}" href="#OpticSim.FresnelLens-Union{Tuple{H}, Tuple{G}, Tuple{T}, Tuple{G, Vararg{T, 5}}} where {T&lt;:Real, G&lt;:AbstractGlass, H&lt;:AbstractGlass}"><code>OpticSim.FresnelLens</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><strong>Code does not work.</strong></p><pre><code class="language-julia hljs">FresnelLens(insidematerial, frontvertex, radius, thickness, semidiameter, groovedepth; conic = 0.0, aspherics = nothing, outsidematerial = AGFFileReader.Air)</code></pre><p>Create a Fresnel lens as a CSG object, can be concave or convex. Groove positions are found iteratively based on <code>groovedepth</code>. For negative radii the vertex on the central surface is at <code>frontvertex</code>, so the total thickness of the lens is <code>thickness</code> + <code>groovedepth</code>. <strong>Aspherics currently not supported</strong>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Optical/Lenses.jl#L118-L125">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.HexagonalPrism-Union{Tuple{T}, Tuple{T, T}} where T&lt;:Real" href="#OpticSim.HexagonalPrism-Union{Tuple{T}, Tuple{T, T}} where T&lt;:Real"><code>OpticSim.HexagonalPrism</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">HexagonalPrism(side_length::T, visheight::T = 2.0; interface::NullOrFresnel{T} = nullinterface(T)) -&gt; CSGGenerator{T}</code></pre><p>Create an infinitely tall hexagonal prism with axis <code>(0, 0, 1)</code>, the longer hexagon diameter is along the x axis. For visualization <code>visheight</code> is used, <strong>note that this does not fully represent the surface</strong>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/Geometry.jl#L94-L99">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.OddAsphericSurface-Union{Tuple{T}, Tuple{T, T, T, Vector{T}}} where T&lt;:Real" href="#OpticSim.OddAsphericSurface-Union{Tuple{T}, Tuple{T, T, T, Vector{T}}} where T&lt;:Real"><code>OpticSim.OddAsphericSurface</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">OddAsphericSurface(semidiameter, curvature::T, conic::T, aspherics::Vector{T}; normradius::T=semidiameter)</code></pre><p>Surface incorporating an aspheric polynomial - radius, conic and aspherics are defined relative to absolute semi-diameter.</p><p><code>aspherics</code>  should be an array of the odd coefficients of the aspheric polynomial starting with A1</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/Primitives/AsphericSurface.jl#L110-L117">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.OddEvenAsphericSurface-Union{Tuple{T}, Tuple{T, T, T, Vector{T}}} where T&lt;:Real" href="#OpticSim.OddEvenAsphericSurface-Union{Tuple{T}, Tuple{T, T, T, Vector{T}}} where T&lt;:Real"><code>OpticSim.OddEvenAsphericSurface</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">OddEvenAsphericSurface(semidiameter, curvature::T, conic::T, aspherics::Vector{T}; normradius::T=semidiameter)</code></pre><p>Surface incorporating an aspheric polynomial - radius, conic and aspherics are defined relative to absolute semi-diameter.</p><p><code>aspherics</code> should be an array of the both odd and even coefficients of the aspheric polynomial starting with A1</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/Primitives/AsphericSurface.jl#L123-L130">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.RectangularAperture-Union{Tuple{T}, Tuple{T, T, StaticArraysCore.SVector{3, T}, StaticArraysCore.SVector{3, T}}} where T&lt;:Real" href="#OpticSim.RectangularAperture-Union{Tuple{T}, Tuple{T, T, StaticArraysCore.SVector{3, T}, StaticArraysCore.SVector{3, T}}} where T&lt;:Real"><code>OpticSim.RectangularAperture</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RectangularAperture(aphalfsizeu::T, aphalfsizev::T, surfacenormal::SVector{3,T}, centrepoint::SVector{3,T}; rotationvec::SVector{3,T} = [0.0, 1.0, 0.0])</code></pre><p>Creates a rectangular aperture in a plane i.e. <code>InfiniteStop{T,RectangularStopShape}</code>. The rotation of the rectangle around its normal is defined by <code>rotationvec</code>. <code>rotationvec√ósurfacenormal</code> is taken as the vector along the u axis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/Primitives/NonCSG/Stop.jl#L172-L178">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.RectangularAperture-Union{Tuple{T}, Tuple{T, T, T, T, StaticArraysCore.SVector{3, T}, StaticArraysCore.SVector{3, T}}} where T&lt;:Real" href="#OpticSim.RectangularAperture-Union{Tuple{T}, Tuple{T, T, T, T, StaticArraysCore.SVector{3, T}, StaticArraysCore.SVector{3, T}}} where T&lt;:Real"><code>OpticSim.RectangularAperture</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RectangularAperture(innerhalfsizeu::T, innerhalfsizev::T, outerhalfsizeu::T, outerhalfsizev::T, surfacenormal::SVector{3,T}, centrepoint::SVector{3,T}; rotationvec::SVector{3,T} = [0.0, 1.0, 0.0])</code></pre><p>Creates a rectangular aperture in a rectangle i.e. <code>FiniteStop{T,RectangularStopShape,RectangularStopShape}</code>. The rotation of the rectangle around its normal is defined by <code>rotationvec</code>. <code>rotationvec√ósurfacenormal</code> is taken as the vector along the u axis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/Primitives/NonCSG/Stop.jl#L191-L197">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.RectangularPrism-Union{Tuple{T}, Tuple{T, T}, Tuple{T, T, T}} where T&lt;:Real" href="#OpticSim.RectangularPrism-Union{Tuple{T}, Tuple{T, T}, Tuple{T, T, T}} where T&lt;:Real"><code>OpticSim.RectangularPrism</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RectangularPrism(halfsizex::T, halfsizey::T, visheight::T=2.0; interface::NullOrFresnel{T} = nullinterface(T)) -&gt; CSGGenerator{T}</code></pre><p>Create an infinitely tall rectangular prism with axis <code>(0, 0, 1)</code>. For visualization <code>visheight</code> is used, <strong>note that this does not fully represent the surface</strong>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/Geometry.jl#L115-L120">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.SphericalLens-Union{Tuple{S}, Tuple{T}, Tuple{Q}, Tuple{R}, Tuple{T, Vararg{S, 5}}} where {R&lt;:AbstractGlass, Q&lt;:AbstractGlass, T&lt;:AbstractGlass, S&lt;:Real}" href="#OpticSim.SphericalLens-Union{Tuple{S}, Tuple{T}, Tuple{Q}, Tuple{R}, Tuple{T, Vararg{S, 5}}} where {R&lt;:AbstractGlass, Q&lt;:AbstractGlass, T&lt;:AbstractGlass, S&lt;:Real}"><code>OpticSim.SphericalLens</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SphericalLens(insidematerial, frontvertex, frontradius, backradius, thickness, semidiameter;  lastmaterial = AGFFileReader.Air, nextmaterial = AGFFileReader.Air, frontsurfacereflectance = 0.0, backsurfacereflectance = 0.0, frontdecenter = (0, 0), backdecenter = (0, 0), interfacemode = ReflectOrTransmit)</code></pre><p>Constructs a simple cylindrical lens with spherical front and back surfaces. The side walls of the lens are absorbing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Optical/Lenses.jl#L7-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.Spider-Union{Tuple{T}, Tuple{Int64, T, T}, Tuple{Int64, T, T, StaticArraysCore.SVector{3, T}}, Tuple{Int64, T, T, StaticArraysCore.SVector{3, T}, StaticArraysCore.SVector{3, T}}} where T&lt;:Real" href="#OpticSim.Spider-Union{Tuple{T}, Tuple{Int64, T, T}, Tuple{Int64, T, T, StaticArraysCore.SVector{3, T}}, Tuple{Int64, T, T, StaticArraysCore.SVector{3, T}, StaticArraysCore.SVector{3, T}}} where T&lt;:Real"><code>OpticSim.Spider</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Spider(narms::Int, armwidth::T, radius::T, origin::SVector{3,T} = SVector{3,T}(0.0, 0.0, 0.0), normal::SVector{3,T} = SVector{3,T}(0.0, 0.0, 1.0)) -&gt; Vector{Rectangle{T}}</code></pre><p>Creates a &#39;spider&#39; obscuration with <code>narms</code> rectangular arms evenly spaced around a circle defined by <code>origin</code> and <code>normal</code>. Each arm is a rectangle <code>armwidth</code>√ó<code>radius</code>.</p><p>e.g. for 3 and 4 arms we get:</p><pre><code class="language-julia hljs">   |         _|_
  / \         |</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/Geometry.jl#L157-L168">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.TriangularPrism-Union{Tuple{T}, Tuple{T, T}} where T&lt;:Real" href="#OpticSim.TriangularPrism-Union{Tuple{T}, Tuple{T, T}} where T&lt;:Real"><code>OpticSim.TriangularPrism</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">TriangularPrism(side_length::T, visheight::T = 2.0; interface::NullOrFresnel{T} = nullinterface(T)) -&gt; CSGGenerator{T}</code></pre><p>Create an infinitely tall triangular prism with axis <code>(0, 0, 1)</code>. For visualization <code>visheight</code> is used, <strong>note that this does not fully represent the surface</strong>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/Geometry.jl#L130-L135">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.asphericType-Union{Tuple{AsphericSurface{T, 3, Q, M}}, Tuple{M}, Tuple{Q}, Tuple{T}} where {T&lt;:Real, Q, M}" href="#OpticSim.asphericType-Union{Tuple{AsphericSurface{T, 3, Q, M}}, Tuple{M}, Tuple{Q}, Tuple{T}} where {T&lt;:Real, Q, M}"><code>OpticSim.asphericType</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">asphericType(surf::AsphericSurface)</code></pre><p>Query the polynomial type of `asp.  Returns CONIC, ODD, EVEN, or ODDEVEN. CONIC corresponds to no aspheric terms, ODD  means it only has odd aspheric terms, EVEN means only even aspheric terms and ODDEVEN means both even and odd terms. </p><p>This function is to enable proper interpretation of <code>surf.aspherics</code> by any optimization routines that directly query the aspheric coefficients.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/Primitives/AsphericSurface.jl#L138-L145">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.assembly-Union{Tuple{CSGOpticalSystem{T, D, S, L} where {D&lt;:Number, S&lt;:Surface{T}, L&lt;:LensAssembly{T}}}, Tuple{T}} where T&lt;:Real" href="#OpticSim.assembly-Union{Tuple{CSGOpticalSystem{T, D, S, L} where {D&lt;:Number, S&lt;:Surface{T}, L&lt;:LensAssembly{T}}}, Tuple{T}} where T&lt;:Real"><code>OpticSim.assembly</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">assembly(system::AbstractOpticalSystem{T}) -&gt; LensAssembly{T}</code></pre><p>Get the <a href="#OpticSim.LensAssembly"><code>LensAssembly</code></a> of <code>system</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Optical/OpticalSystem.jl#L90-L94">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.closestintersection" href="#OpticSim.closestintersection"><code>OpticSim.closestintersection</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">closestintersection(a::Union{EmptyInterval{T},Interval{T},DisjointUnion{T}}, ignorenull::Bool = true) -&gt; Union{Nothing,Intersection{T,3}}</code></pre><p>Returns the closest <a href="#OpticSim.Intersection"><code>Intersection</code></a> from an <a href="#OpticSim.Interval"><code>Interval</code></a> or <a href="#OpticSim.DisjointUnion"><code>DisjointUnion</code></a>. Ignores intersection with null interfaces if <code>ignorenull</code> is true. Will return <code>nothing</code> if there is no valid intersection.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/CSG/Interval.jl#L274-L279">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.closestpointonray-Union{Tuple{N}, Tuple{T}, Tuple{AbstractRay{T, N}, StaticArraysCore.SVector{N, T}}} where {T, N}" href="#OpticSim.closestpointonray-Union{Tuple{N}, Tuple{T}, Tuple{AbstractRay{T, N}, StaticArraysCore.SVector{N, T}}} where {T, N}"><code>OpticSim.closestpointonray</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">closestpointonray(r::Ray{T,N}, point::SVector{N,T}) -&gt; SVector{T,N</code></pre><p>Returns the point on the ray closest to point.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/Ray.jl#L58-L62">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.detectorimage-Tuple{CSGOpticalSystem}" href="#OpticSim.detectorimage-Tuple{CSGOpticalSystem}"><code>OpticSim.detectorimage</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">detectorimage(system::AbstractOpticalSystem{T}) -&gt; HierarchicalImage{D}</code></pre><p>Get the detector image of <code>system</code>. <code>D</code> is the datatype of the detector image and is not necessarily the same as the datatype of the system <code>T</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Optical/OpticalSystem.jl#L99-L104">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.distancefromplane-Tuple{OpticSim.PlanarShape, StaticArraysCore.SVector{3}}" href="#OpticSim.distancefromplane-Tuple{OpticSim.PlanarShape, StaticArraysCore.SVector{3}}"><code>OpticSim.distancefromplane</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>All planar shapes lie on a plane. This function computes the distance from a point to that plane. This is a signed distance. If the point is on the positive side of the plane (the side the normal points toward) the distance will be positive, otherwise negative or 0 if the point lies in the plane.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/Primitives/NonCSG/PlanarShape.jl#L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.doesintersect-Union{Tuple{T}, Tuple{BoundingBox{T}, AbstractRay{T, 3}}} where T&lt;:Real" href="#OpticSim.doesintersect-Union{Tuple{T}, Tuple{BoundingBox{T}, AbstractRay{T, 3}}} where T&lt;:Real"><code>OpticSim.doesintersect</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">doesintersect(bbox::BoundingBox{T}, r::AbstractRay{T,3}) -&gt; Bool</code></pre><p>Tests whether <code>r</code> intersects an axis-aligned <a href="#OpticSim.BoundingBox"><code>BoundingBox</code></a>, <code>bbox</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/BoundingBox.jl#L125-L129">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.inside-Union{Tuple{T}, Tuple{CSGTree{T}, T, T, T}} where T&lt;:Real" href="#OpticSim.inside-Union{Tuple{T}, Tuple{CSGTree{T}, T, T, T}} where T&lt;:Real"><code>OpticSim.inside</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">inside(obj::CSGTree{T}, point::SVector{3,T}) -&gt; Bool
inside(obj::CSGTree{T}, x::T, y::T, z::T) -&gt; Bool</code></pre><p>Tests whether a 3D point in world space is <em>inside</em> <code>obj</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/CSG/CSG.jl#L333-L338">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.inside-Union{Tuple{T}, Tuple{ParametricSurface{T, 3}, T, T, T}} where T&lt;:Real" href="#OpticSim.inside-Union{Tuple{T}, Tuple{ParametricSurface{T, 3}, T, T, T}} where T&lt;:Real"><code>OpticSim.inside</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">inside(surf::ParametricSurface{T}, p::SVector{3,T}) -&gt; Bool
inside(surf::ParametricSurface{T}, x::T, y::T, z::T) -&gt; Bool</code></pre><p>Tests whether a 3D point in world space is <em>inside</em> <code>surf</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/Surface.jl#L117-L122">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.interface-Union{Tuple{AcceleratedParametricSurface{T, N, S} where {N, S&lt;:ParametricSurface{T, N}}}, Tuple{T}} where T&lt;:Real" href="#OpticSim.interface-Union{Tuple{AcceleratedParametricSurface{T, N, S} where {N, S&lt;:ParametricSurface{T, N}}}, Tuple{T}} where T&lt;:Real"><code>OpticSim.interface</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">interface(surf::Surface{T}) -&gt; OpticalInterface{T}</code></pre><p>Return the <a href="#OpticSim.OpticalInterface"><code>OpticalInterface</code></a> associated with <code>surf</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/AccelSurface.jl#L48-L52">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.intersections-Union{Tuple{N}, Tuple{T}, Tuple{AbstractRay{T, N}, Matrix{T}}} where {T&lt;:Real, N}" href="#OpticSim.intersections-Union{Tuple{N}, Tuple{T}, Tuple{AbstractRay{T, N}, Matrix{T}}} where {T&lt;:Real, N}"><code>OpticSim.intersections</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>returns an array of intersection points. Each element in the array is (<code>[x,y,...],alpha,theta)</code> where <code>[x,y,...]</code> is the n-dimensional intersection point, alpha is the line parameter value at the intersection point, and theta is the curve parameter value at the intersection point</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/AnalyticIntersection.jl#L151">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.leaf-Union{Tuple{ParametricSurface{T}}, Tuple{T}, Tuple{ParametricSurface{T}, OpticSim.Geometry.Transform{T}}} where T&lt;:Real" href="#OpticSim.leaf-Union{Tuple{ParametricSurface{T}}, Tuple{T}, Tuple{ParametricSurface{T}, OpticSim.Geometry.Transform{T}}} where T&lt;:Real"><code>OpticSim.leaf</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">leaf(surf::ParametricSurface{T}, transform::Transform{T} = identitytransform(T)) -&gt; CSGGenerator{T}</code></pre><p>Create a leaf node from a parametric surface with a given transform.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/CSG/CSG.jl#L121-L125">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.makemesh-Union{Tuple{ConvexPolygon{N, T}}, Tuple{T}, Tuple{N}, Tuple{ConvexPolygon{N, T}, Int64}} where {N, T&lt;:Real}" href="#OpticSim.makemesh-Union{Tuple{ConvexPolygon{N, T}}, Tuple{T}, Tuple{N}, Tuple{ConvexPolygon{N, T}, Int64}} where {N, T&lt;:Real}"><code>OpticSim.makemesh</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">makemesh(poly::ConvexPolygon{N, T}, ::Int = 0) where {N, T&lt;:Real} -&gt; TriangleMesh</code></pre><p>Create a triangle mesh that can be rendered by iterating on the polygon&#39;s edges and for each edge use the centroid as the third vertex of the triangle.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/Primitives/NonCSG/ConvexPolygon.jl#L143-L147">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.makemesh-Union{Tuple{ParametricSurface{S, N}}, Tuple{N}, Tuple{S}, Tuple{ParametricSurface{S, N}, Int64}} where {S, N}" href="#OpticSim.makemesh-Union{Tuple{ParametricSurface{S, N}}, Tuple{N}, Tuple{S}, Tuple{ParametricSurface{S, N}, Int64}} where {S, N}"><code>OpticSim.makemesh</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">makemesh(object, subdivisions::Int = 30) -&gt; TriangleMesh</code></pre><p>Creates a <a href="#OpticSim.TriangleMesh"><code>TriangleMesh</code></a> from an object, either a <a href="#OpticSim.ParametricSurface"><code>ParametricSurface</code></a>, <a href="#OpticSim.CSGTree"><code>CSGTree</code></a> or certain surfaces (e.g. <code>Circle</code>, <code>Rectangle</code>). This is used for visualization purposes only.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/Surface.jl#L233-L238">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.normal-Union{Tuple{T}, Tuple{ParametricSurface{T}, T, T}} where T&lt;:Real" href="#OpticSim.normal-Union{Tuple{T}, Tuple{ParametricSurface{T}, T, T}} where T&lt;:Real"><code>OpticSim.normal</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">normal(surf::ParametricSurface{T}, u::T, v::T) -&gt; SVector{3,T}
normal(surf::ParametricSurface{T}, uv::SVector{2,T}) -&gt; SVector{3,T}</code></pre><p>Returns the normal to <code>surf</code> at the given uv coordinate.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/Surface.jl#L92-L97">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.onsurface-Union{Tuple{T}, Tuple{CSGTree{T}, T, T, T}} where T&lt;:Real" href="#OpticSim.onsurface-Union{Tuple{T}, Tuple{CSGTree{T}, T, T, T}} where T&lt;:Real"><code>OpticSim.onsurface</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">onsurface(obj::CSGTree{T}, point::SVector{3,T}) -&gt; Bool
onsurface(obj::CSGTree{T}, x::T, y::T, z::T) -&gt; Bool</code></pre><p>Tests whether a 3D point in world space is <em>on</em> the surface (i.e. shell) of <code>obj</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/CSG/CSG.jl#L311-L316">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.onsurface-Union{Tuple{T}, Tuple{ParametricSurface{T, 3}, T, T, T}} where T&lt;:Real" href="#OpticSim.onsurface-Union{Tuple{T}, Tuple{ParametricSurface{T, 3}, T, T, T}} where T&lt;:Real"><code>OpticSim.onsurface</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">onsurface(surf::ParametricSurface{T}, p::SVector{3,T}) -&gt; Bool
onsurface(surf::ParametricSurface{T}, x::T, y::T, z::T) -&gt; Bool</code></pre><p>Tests whether a 3D point in world space is <em>on</em> <code>surf</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/Surface.jl#L125-L130">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.partials-Union{Tuple{T}, Tuple{ParametricSurface{T}, T, T}} where T&lt;:Real" href="#OpticSim.partials-Union{Tuple{T}, Tuple{ParametricSurface{T}, T, T}} where T&lt;:Real"><code>OpticSim.partials</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">partials(surf::ParametricSurface{T}, u::T, v::T) -&gt; (SVector{3,T}, SVector{3,T})
partials(surf::ParametricSurface{T}, uv::SVector{2,T}) -&gt; (SVector{3,T}, SVector{3,T})</code></pre><p>Returns a tuple of the 3D partial derivatives of <code>surf</code> with respect to u and v at the given uv coordinate.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/Surface.jl#L100-L105">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.point-Tuple{OpticSim.VirtualPoint}" href="#OpticSim.point-Tuple{OpticSim.VirtualPoint}"><code>OpticSim.point</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>This will return (Inf,Inf,Inf) if the point is at infinity. In this case you probably should be using the direction of the VirtualPoint rather than its position</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Optical/Paraxial.jl#L50">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.point-Union{Tuple{T}, Tuple{N}, Tuple{AbstractRay{T, N}, T}} where {N, T&lt;:Real}" href="#OpticSim.point-Union{Tuple{T}, Tuple{N}, Tuple{AbstractRay{T, N}, T}} where {N, T&lt;:Real}"><code>OpticSim.point</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">point(ray::AbstractRay{T,N}, alpha::T) -&gt; SVector{T, N}</code></pre><p>Returns a point on the ray at origin + alpha * direction. Alpha must be &gt;= 0.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/Ray.jl#L48-L52">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.point-Union{Tuple{T}, Tuple{N}, Tuple{Rectangle{T}, StaticArraysCore.SMatrix{2, N, T}}} where {N, T&lt;:Real}" href="#OpticSim.point-Union{Tuple{T}, Tuple{N}, Tuple{Rectangle{T}, StaticArraysCore.SMatrix{2, N, T}}} where {N, T&lt;:Real}"><code>OpticSim.point</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>returns a 3D point. This takes into account the offset of centerpoint and the rotation vector used to construct the Rectangle. u and v are scaled by the size of the rectangle so that u=0,v=0 is one corner and u=v=1 is the diagonal corner. This function should go away once we have a sensible object transform hierarchy system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/Primitives/NonCSG/Rectangle.jl#L60">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.point-Union{Tuple{T}, Tuple{ParametricSurface{T}, T, T}} where T&lt;:Real" href="#OpticSim.point-Union{Tuple{T}, Tuple{ParametricSurface{T}, T, T}} where T&lt;:Real"><code>OpticSim.point</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">point(surf::ParametricSurface{T}, u::T, v::T) -&gt; SVector{3,T}
point(surf::ParametricSurface{T}, uv::SVector{2,T}) -&gt; SVector{3,T}</code></pre><p>Returns the 3D point on <code>surf</code> at the given uv coordinate.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/Surface.jl#L84-L89">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.point-Union{Tuple{T}, Tuple{Rectangle{T}, T, T}} where T&lt;:Real" href="#OpticSim.point-Union{Tuple{T}, Tuple{Rectangle{T}, T, T}} where T&lt;:Real"><code>OpticSim.point</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>returns a 3D point in the plane of the rectangle. This takes into account the offset of centerpoint and the rotation vector used to construct the Rectangle. u and v are scaled by the size of the rectangle so that u=0,v=0 is one corner and u=v=1 is the diagonal corner. This function should go away once we have a sensible object transform hierarchy system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/Primitives/NonCSG/Rectangle.jl#L69">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.pressure-Union{Tuple{CSGOpticalSystem{T, D, S, L} where {D&lt;:Number, S&lt;:Surface{T}, L&lt;:LensAssembly{T}}}, Tuple{T}} where T&lt;:Real" href="#OpticSim.pressure-Union{Tuple{CSGOpticalSystem{T, D, S, L} where {D&lt;:Number, S&lt;:Surface{T}, L&lt;:LensAssembly{T}}}, Tuple{T}} where T&lt;:Real"><code>OpticSim.pressure</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">pressure(system::AbstractOpticalSystem{T}) -&gt; T</code></pre><p>Get the pressure of <code>system</code> in Atm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Optical/OpticalSystem.jl#L116-L120">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.reset!-Union{Tuple{HierarchicalImage{T}}, Tuple{T}} where T" href="#OpticSim.reset!-Union{Tuple{HierarchicalImage{T}}, Tuple{T}} where T"><code>OpticSim.reset!</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">reset!(a::HierarchicalImage{T})</code></pre><p>Resets the pixels in the image to <code>zero(T)</code>. Do this rather than <code>image .= zero(T)</code> because that will cause every pixel to be accessed, and therefore allocated. For large images this can cause huge memory traffic.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Optical/HierarchicalImage.jl#L94-L100">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.resetdetector!-Union{Tuple{CSGOpticalSystem{T, D, S, L} where {D&lt;:Number, S&lt;:Surface{T}, L&lt;:LensAssembly{T}}}, Tuple{T}} where T&lt;:Real" href="#OpticSim.resetdetector!-Union{Tuple{CSGOpticalSystem{T, D, S, L} where {D&lt;:Number, S&lt;:Surface{T}, L&lt;:LensAssembly{T}}}, Tuple{T}} where T&lt;:Real"><code>OpticSim.resetdetector!</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">resetdetector!(system::AbstractOpticalSystem{T})</code></pre><p>Reset the deterctor image of <code>system</code> to zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Optical/OpticalSystem.jl#L122-L126">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.samplesurface-Union{Tuple{N}, Tuple{T}, Tuple{ParametricSurface{T, N}, Function}, Tuple{ParametricSurface{T, N}, Function, Int64}} where {T&lt;:Real, N}" href="#OpticSim.samplesurface-Union{Tuple{N}, Tuple{T}, Tuple{ParametricSurface{T, N}, Function}, Tuple{ParametricSurface{T, N}, Function, Int64}} where {T&lt;:Real, N}"><code>OpticSim.samplesurface</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">samplesurface(surf::ParametricSurface{T,N}, samplefunction::Function, numsamples::Int = 30)</code></pre><p>Sample a parametric surface on an even <code>numsamples</code>√ó<code>numsamples</code> grid in UV space with provided function</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/Surface.jl#L142-L146">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.semidiameter-Tuple{AxisymmetricOpticalSystem}" href="#OpticSim.semidiameter-Tuple{AxisymmetricOpticalSystem}"><code>OpticSim.semidiameter</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">semidiameter(system::AxisymmetricOpticalSystem{T}) -&gt; T</code></pre><p>Get the semidiameter of <code>system</code>, that is the semidiameter of the entrance pupil (i.e. first surface) of the system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Optical/OpticalSystem.jl#L455-L459">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.sphericalcircle" href="#OpticSim.sphericalcircle"><code>OpticSim.sphericalcircle</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>creates a circular polygon that subtends a half angle of Œ∏</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/SphericalPolygon.jl#L104">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.sum!-Union{Tuple{T}, Tuple{HierarchicalImage{T}, HierarchicalImage{T}}} where T" href="#OpticSim.sum!-Union{Tuple{T}, Tuple{HierarchicalImage{T}, HierarchicalImage{T}}} where T"><code>OpticSim.sum!</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sum!(a::HierarchicalImage{T}, b::HierarchicalImage{T})</code></pre><p>Add the contents of <code>b</code> to <code>a</code> in an efficient way.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Optical/HierarchicalImage.jl#L112-L116">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.surfaceintersection-Union{Tuple{N}, Tuple{T}, Tuple{AcceleratedParametricSurface{T, N, S} where S&lt;:ParametricSurface{T, N}, AbstractRay{T, N}}} where {T, N}" href="#OpticSim.surfaceintersection-Union{Tuple{N}, Tuple{T}, Tuple{AcceleratedParametricSurface{T, N, S} where S&lt;:ParametricSurface{T, N}, AbstractRay{T, N}}} where {T, N}"><code>OpticSim.surfaceintersection</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">surfaceintersection(surf::Surface{T}, r::AbstractRay{T}) where {T}</code></pre><p>Calculates the intersection of <code>r</code> with a surface of any type, <code>surf</code>. Note that some surfaces cannot be intersected analytically so must be wrapped in an <a href="#OpticSim.AcceleratedParametricSurface"><code>AcceleratedParametricSurface</code></a> in order to be intersected.</p><p>Returns an <a href="#OpticSim.EmptyInterval"><code>EmptyInterval</code></a> if there is no <a href="#OpticSim.Intersection"><code>Intersection</code></a>, an <a href="#OpticSim.Interval"><code>Interval</code></a> if there is one or two intersections and a <a href="#OpticSim.DisjointUnion"><code>DisjointUnion</code></a> if there are more than two intersections.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/AccelSurface.jl#L74-L81">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.surfaceintersection-Union{Tuple{N}, Tuple{T}, Tuple{CSGTree{T}, AbstractRay{T, N}}} where {T&lt;:Real, N}" href="#OpticSim.surfaceintersection-Union{Tuple{N}, Tuple{T}, Tuple{CSGTree{T}, AbstractRay{T, N}}} where {T&lt;:Real, N}"><code>OpticSim.surfaceintersection</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">surfaceintersection(obj::CSGTree{T}, r::AbstractRay{T,N})</code></pre><p>Calculates the intersection of <code>r</code> with CSG object, <code>obj</code>.</p><p>Returns an <a href="#OpticSim.EmptyInterval"><code>EmptyInterval</code></a> if there is no intersection, an <a href="#OpticSim.Interval"><code>Interval</code></a> if there is one or two intersections and a <a href="#OpticSim.DisjointUnion"><code>DisjointUnion</code></a> if there are more than two intersections.</p><p>The ray is intersected with the <a href="../csg/#OpticSim.LeafNode-csg"><code>LeafNode</code></a>s that make up the CSG object and the resulting <code>Interval</code>s and <code>DisjointUnion</code>s are composed with the same boolean operations to give a final result. The ray is transformed by the inverse of the transform associated with the leaf node to put it in <em>object space</em> for that node before the intersection is carried out, typically this <em>object space</em> is centered at the origin, but may differ for each primitive.</p><p>Some intersections are culled without actually evaluating them by first checking if the ray intersects the <a href="#OpticSim.BoundingBox"><code>BoundingBox</code></a> of each node in the <a href="#OpticSim.CSGTree"><code>CSGTree</code></a>, this can substantially improve performance in some cases.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/CSG/CSG.jl#L285-L301">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.surfaceintersection-Union{Tuple{T}, Tuple{BoundingBox{T}, AbstractRay{T, 3}}} where T&lt;:Real" href="#OpticSim.surfaceintersection-Union{Tuple{T}, Tuple{BoundingBox{T}, AbstractRay{T, 3}}} where T&lt;:Real"><code>OpticSim.surfaceintersection</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">surfaceintersection(bbox::BoundingBox{T}, r::AbstractRay{T,3}) -&gt; Union{EmptyInterval{T},Interval{T}}</code></pre><p>Calculates the intersection of <code>r</code> with an axis-aligned <a href="#OpticSim.BoundingBox"><code>BoundingBox</code></a>, <code>bbox</code>.</p><p>Returns an <a href="#OpticSim.EmptyInterval"><code>EmptyInterval</code></a> if there is no intersection or an <a href="#OpticSim.Interval"><code>Interval</code></a> if there is one or two intersections. Note that the uv of the returned intersection is always <strong>0</strong>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/BoundingBox.jl#L241-L248">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.temperature-Union{Tuple{CSGOpticalSystem{T, D, S, L} where {D&lt;:Number, S&lt;:Surface{T}, L&lt;:LensAssembly{T}}}, Tuple{T}} where T&lt;:Real" href="#OpticSim.temperature-Union{Tuple{CSGOpticalSystem{T, D, S, L} where {D&lt;:Number, S&lt;:Surface{T}, L&lt;:LensAssembly{T}}}, Tuple{T}} where T&lt;:Real"><code>OpticSim.temperature</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">temperature(system::AbstractOpticalSystem{T}) -&gt; T</code></pre><p>Get the temperature of <code>system</code> in ¬∞C.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Optical/OpticalSystem.jl#L109-L113">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.trace-Union{Tuple{D}, Tuple{N}, Tuple{T}, Tuple{CSGOpticalSystem{T, D, S, L} where {S&lt;:Surface{T}, L&lt;:LensAssembly{T}}, OpticalRay{T, N}}} where {T&lt;:Real, N, D&lt;:Number}" href="#OpticSim.trace-Union{Tuple{D}, Tuple{N}, Tuple{T}, Tuple{CSGOpticalSystem{T, D, S, L} where {S&lt;:Surface{T}, L&lt;:LensAssembly{T}}, OpticalRay{T, N}}} where {T&lt;:Real, N, D&lt;:Number}"><code>OpticSim.trace</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">trace(system::AbstractOpticalSystem{T}, ray::OpticalRay{T}; trackrays = nothing, test = false)</code></pre><p>Traces <code>system</code> with <code>ray</code>, if <code>test</code> is enabled then fresnel reflections are disabled and the power distribution will not be correct. Returns either a <a href="#OpticSim.LensTrace"><code>LensTrace</code></a> if the ray hits the detector or <code>nothing</code> otherwise.</p><p><code>trackrays</code> can be passed an empty vector to accumulate the <code>LensTrace</code> objects at each intersection of <code>ray</code> with a surface in the system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Optical/OpticalSystem.jl#L130-L138">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.trace-Union{Tuple{N}, Tuple{T}, Tuple{LensAssembly{T}, OpticalRay{T, N}}, Tuple{LensAssembly{T}, OpticalRay{T, N}, T}, Tuple{LensAssembly{T}, OpticalRay{T, N}, T, T}} where {T&lt;:Real, N}" href="#OpticSim.trace-Union{Tuple{N}, Tuple{T}, Tuple{LensAssembly{T}, OpticalRay{T, N}}, Tuple{LensAssembly{T}, OpticalRay{T, N}, T}, Tuple{LensAssembly{T}, OpticalRay{T, N}, T, T}} where {T&lt;:Real, N}"><code>OpticSim.trace</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">trace(assembly::LensAssembly{T}, r::OpticalRay{T}, temperature::T = 20.0, pressure::T = 1.0; trackrays = nothing, test = false)</code></pre><p>Returns the ray as it exits the assembly in the form of a <a href="#OpticSim.LensTrace"><code>LensTrace</code></a> object if it hits any element in the assembly, otherwise <code>nothing</code>. Recursive rays are offset by a small amount (<code>RAY_OFFSET</code>) to prevent it from immediately reintersecting the same lens element.</p><p><code>trackrays</code> can be passed an empty vector to accumulate the <code>LensTrace</code> objects at each intersection of <code>ray</code> with a surface in the assembly.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Optical/LensAssembly.jl#L321-L328">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.trace-Union{Tuple{T}, Tuple{CSGOpticalSystem{T, D, S, L} where {D&lt;:Number, S&lt;:Surface{T}, L&lt;:LensAssembly{T}}, OpticalRayGenerator{T}}} where T&lt;:Real" href="#OpticSim.trace-Union{Tuple{T}, Tuple{CSGOpticalSystem{T, D, S, L} where {D&lt;:Number, S&lt;:Surface{T}, L&lt;:LensAssembly{T}}, OpticalRayGenerator{T}}} where T&lt;:Real"><code>OpticSim.trace</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">trace(system::AbstractOpticalSystem{T}, raygenerator::OpticalRayGenerator{T}; printprog = true, test = false)</code></pre><p>Traces <code>system</code> with rays generated by <code>raygenerator</code> on a single thread. Optionally the progress can be printed to the REPL. If <code>test</code> is enabled then fresnel reflections are disabled and the power distribution will not be correct. If <code>outpath</code> is specified then the result will be saved to this path.</p><p>Returns the detector image of the system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Optical/OpticalSystem.jl#L481-L490">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.traceMT-Union{Tuple{S}, Tuple{T}, Tuple{CSGOpticalSystem{T, S, S1, L} where {S1&lt;:Surface{T}, L&lt;:LensAssembly{T}}, OpticalRayGenerator{T}}} where {T&lt;:Real, S&lt;:Number}" href="#OpticSim.traceMT-Union{Tuple{S}, Tuple{T}, Tuple{CSGOpticalSystem{T, S, S1, L} where {S1&lt;:Surface{T}, L&lt;:LensAssembly{T}}, OpticalRayGenerator{T}}} where {T&lt;:Real, S&lt;:Number}"><code>OpticSim.traceMT</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">traceMT(system::AbstractOpticalSystem{T}, raygenerator::OpticalRayGenerator{T}; printprog = true, test = false)</code></pre><p>Traces <code>system</code> with rays generated by <code>raygenerator</code> using as many threads as possible. Optionally the progress can be printed to the REPL. If <code>test</code> is enabled then fresnel reflections are disabled and the power distribution will not be correct. If <code>outpath</code> is specified then the result will be saved to this path.</p><p>Returns the accumulated detector image from all threads.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Optical/OpticalSystem.jl#L541-L550">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.tracehits-Union{Tuple{T}, Tuple{CSGOpticalSystem{T, D, S, L} where {D&lt;:Number, S&lt;:Surface{T}, L&lt;:LensAssembly{T}}, OpticalRayGenerator{T}}} where T&lt;:Real" href="#OpticSim.tracehits-Union{Tuple{T}, Tuple{CSGOpticalSystem{T, D, S, L} where {D&lt;:Number, S&lt;:Surface{T}, L&lt;:LensAssembly{T}}, OpticalRayGenerator{T}}} where T&lt;:Real"><code>OpticSim.tracehits</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">tracehits(system::AbstractOpticalSystem{T}, raygenerator::OpticalRayGenerator{T}; printprog = true, test = false)</code></pre><p>Traces <code>system</code> with rays generated by <code>raygenerator</code> on a single thread. Optionally the progress can be printed to the REPL. If <code>test</code> is enabled then fresnel reflections are disabled and the power distribution will not be correct.</p><p>Returns a list of <a href="#OpticSim.LensTrace"><code>LensTrace</code></a>s which hit the detector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Optical/OpticalSystem.jl#L777-L785">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.tracehitsMT-Union{Tuple{T}, Tuple{CSGOpticalSystem{T, D, S, L} where {D&lt;:Number, S&lt;:Surface{T}, L&lt;:LensAssembly{T}}, OpticalRayGenerator{T}}} where T&lt;:Real" href="#OpticSim.tracehitsMT-Union{Tuple{T}, Tuple{CSGOpticalSystem{T, D, S, L} where {D&lt;:Number, S&lt;:Surface{T}, L&lt;:LensAssembly{T}}, OpticalRayGenerator{T}}} where T&lt;:Real"><code>OpticSim.tracehitsMT</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">tracehitsMT(system::AbstractOpticalSystem{T}, raygenerator::OpticalRayGenerator{T}; printprog = true, test = false)</code></pre><p>Traces <code>system</code> with rays generated by <code>raygenerator</code> using as many threads as possible. Optionally the progress can be printed to the REPL. If <code>test</code> is enabled then fresnel reflections are disabled and the power distribution will not be correct.</p><p>Returns a list of <a href="#OpticSim.LensTrace"><code>LensTrace</code></a>s which hit the detector, accumulated from all threads.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Optical/OpticalSystem.jl#L657-L665">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.triangulate-Union{Tuple{N}, Tuple{T}, Tuple{ParametricSurface{T, N}, Int64}, Tuple{ParametricSurface{T, N}, Int64, Bool}, Tuple{ParametricSurface{T, N}, Int64, Bool, Bool}, Tuple{ParametricSurface{T, N}, Int64, Bool, Bool, Bool}, Tuple{ParametricSurface{T, N}, Int64, Vararg{Bool, 4}}} where {T, N}" href="#OpticSim.triangulate-Union{Tuple{N}, Tuple{T}, Tuple{ParametricSurface{T, N}, Int64}, Tuple{ParametricSurface{T, N}, Int64, Bool}, Tuple{ParametricSurface{T, N}, Int64, Bool, Bool}, Tuple{ParametricSurface{T, N}, Int64, Bool, Bool, Bool}, Tuple{ParametricSurface{T, N}, Int64, Vararg{Bool, 4}}} where {T, N}"><code>OpticSim.triangulate</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">triangulate(surf::ParametricSurface{S,N}, quads_per_row::Int, extensionu::Bool = false, extensionv::Bool = false, radialu::Bool = false, radialv::Bool = false)</code></pre><p>Create an array of triangles representing the parametric surface where vertices are sampled on an even grid in UV space. The surface can be extended by 1% in u and v separately, and specifying either u or v as being radial - i.e. determining the radius on the surface e.g. rho for zernike - will result in that dimension being sampled using sqwrt so that area of triangles is uniform. The extension will also only apply to the maximum in this case.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/Surface.jl#L164-L169">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.uv-Union{Tuple{T}, Tuple{ParametricSurface{T, 3}, T, T, T}} where T&lt;:Real" href="#OpticSim.uv-Union{Tuple{T}, Tuple{ParametricSurface{T, 3}, T, T, T}} where T&lt;:Real"><code>OpticSim.uv</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">uv(surf::ParametricSurface{T}, p::SVector{3,T}) -&gt; SVector{2,T}
uv(surf::ParametricSurface{T}, x::T, y::T, z::T) -&gt; SVector{2,T}</code></pre><p>Returns the uv coordinate on <code>surf</code> of a point, <code>p</code>, in 3D space. If <code>onsurface(surf, p)</code> is false then the behavior is undefined, it may return an inorrect uv, an invalid uv, NaN or crash.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/Surface.jl#L108-L114">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.uvrange-Tuple{S} where S&lt;:ParametricSurface" href="#OpticSim.uvrange-Tuple{S} where S&lt;:ParametricSurface"><code>OpticSim.uvrange</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">uvrange(s::ParametricSurface)
uvrange(::Type{S}) where {S&lt;:ParametricSurface}</code></pre><p>Returns a tuple of the form: <code>((umin, umax), (vmin, vmax))</code> specifying the limits of the parameterisation for this surface type. Also implemented for some <code>Surface</code>s which are not <code>ParametricSurface</code>s (e.g. <code>Rectangle</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/Surface.jl#L133-L139">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.vertices-Tuple{OpticSim.PlanarShape}" href="#OpticSim.vertices-Tuple{OpticSim.PlanarShape}"><code>OpticSim.vertices</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>The vertices of planar shapes are defined in a plane so they are two dimensional. In the local coordinate frame this is the x,y plane, so the implied z coordinate is 0</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/Primitives/NonCSG/PlanarShape.jl#L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.vertices-Tuple{ParaxialLens}" href="#OpticSim.vertices-Tuple{ParaxialLens}"><code>OpticSim.vertices</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>returns the 2 dimensional vertex points of the shape defining the lens aperture. These points lie in the plane of the shape</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Optical/Paraxial.jl#L34">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.vertices-Union{Tuple{Rectangle{T}}, Tuple{T}, Tuple{Rectangle{T}, Int64}} where T&lt;:Real" href="#OpticSim.vertices-Union{Tuple{Rectangle{T}}, Tuple{T}, Tuple{Rectangle{T}, Int64}} where T&lt;:Real"><code>OpticSim.vertices</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>returns the 2D vertices in the plane of the rectangle</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/Primitives/NonCSG/Rectangle.jl#L115">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.vertices3d-Union{Tuple{Hexagon{T}}, Tuple{T}} where T&lt;:Real" href="#OpticSim.vertices3d-Union{Tuple{Hexagon{T}}, Tuple{T}} where T&lt;:Real"><code>OpticSim.vertices3d</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Returns the vertices of the Hexagon represented in the local coordinate frame. The vertices lie in the z = 0 plane and are 2D</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/Primitives/NonCSG/Hexagon.jl#L77">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.vertices3d-Union{Tuple{Rectangle{T}}, Tuple{T}, Tuple{Rectangle{T}, Int64}} where T&lt;:Real" href="#OpticSim.vertices3d-Union{Tuple{Rectangle{T}}, Tuple{T}, Tuple{Rectangle{T}, Int64}} where T&lt;:Real"><code>OpticSim.vertices3d</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>returns the vertices of the rectangle in 3D</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/Primitives/NonCSG/Rectangle.jl#L119">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.virtualpoint-Union{Tuple{T}, Tuple{ParaxialLens{T}, AbstractVector{T}}} where T" href="#OpticSim.virtualpoint-Union{Tuple{T}, Tuple{ParaxialLens{T}, AbstractVector{T}}} where T"><code>OpticSim.virtualpoint</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>computes the virtual point position corresponding to the input <code>point</code>, or returns nothing for points at infinity. <code>point</code> is specified in the lens coordinate frame</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Optical/Paraxial.jl#L65">source</a></section></article><h2 id="Optical-Emitters"><a class="docs-heading-anchor" href="#Optical-Emitters">Optical Emitters</a><a id="Optical-Emitters-1"></a><a class="docs-heading-anchor-permalink" href="#Optical-Emitters" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.Emitters.apply" href="#OpticSim.Emitters.apply"><code>OpticSim.Emitters.apply</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">apply(???)</code></pre><p>[TODO] Returns ray power</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Optical/Emitters/Emitters.jl#L37-L41">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.Emitters.collimatedemitter-Union{Tuple{T}, Tuple{AbstractVector{T}, Any}} where T&lt;:Real" href="#OpticSim.Emitters.collimatedemitter-Union{Tuple{T}, Tuple{AbstractVector{T}, Any}} where T&lt;:Real"><code>OpticSim.Emitters.collimatedemitter</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">collimatedemitter(origin::AbstractVector{T}, halfsquaresize; Œª::Length = 500nm, numrays = 100) where {T&lt;:Real}</code></pre><p>Creates a square collimated emitter, emitting rays in the -z direction. Rays are emitted on a square grid with sqrt(numrays) on a side. Œª can be a unitful quantity, e.g., 550nm, or a number. In the latter case the units are implicitly microns.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Optical/Emitters/StandardEmitters.jl#L25-L31">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.Emitters.generate" href="#OpticSim.Emitters.generate"><code>OpticSim.Emitters.generate</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">generate(???)</code></pre><p>[TODO]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Optical/Emitters/Emitters.jl#L23-L27">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.Emitters.pointemitter-Union{Tuple{T}, Tuple{AbstractVector{T}, Any}} where T&lt;:Real" href="#OpticSim.Emitters.pointemitter-Union{Tuple{T}, Tuple{AbstractVector{T}, Any}} where T&lt;:Real"><code>OpticSim.Emitters.pointemitter</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">pointemitter(origin::AbstractVector{T}, coneangle; Œª::Length = 500nm, numrays = 100) where {T&lt;:Real}</code></pre><p>Creates a point source with Lambertian emission power and cone distribution of rays, emitting in the -z direction. Œª is a unitful Length quantity, e.g., 550nm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Optical/Emitters/StandardEmitters.jl#L7-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.Emitters.visual_size" href="#OpticSim.Emitters.visual_size"><code>OpticSim.Emitters.visual_size</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">visual_size(???)</code></pre><p>[TODO]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Optical/Emitters/Emitters.jl#L30-L34">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.Emitters.AngularPower.Cosine" href="#OpticSim.Emitters.AngularPower.Cosine"><code>OpticSim.Emitters.AngularPower.Cosine</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Cosine{T} &lt;: AbstractAngularPowerDistribution{T}</code></pre><p>Cosine power distribution. Ray power is calculated by:</p><p><code>power = power * (cosine_angle ^ cosine_exp)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Optical/Emitters/AngularPower.jl#L26-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.Emitters.AngularPower.Gaussian" href="#OpticSim.Emitters.AngularPower.Gaussian"><code>OpticSim.Emitters.AngularPower.Gaussian</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Gaussian{T} &lt;: AbstractAngularPowerDistribution{T}</code></pre><p>GGaussian power distribution. Ray power is calculated by:</p><p><code>power = power * exp(-(gaussianu * l^2 + gaussianv * m^2))</code> where l and m are the cos_angles between the two axes respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Optical/Emitters/AngularPower.jl#L46-L53">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.Emitters.AngularPower.Lambertian" href="#OpticSim.Emitters.AngularPower.Lambertian"><code>OpticSim.Emitters.AngularPower.Lambertian</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Lambertian{T} &lt;: AbstractAngularPowerDistribution{T}</code></pre><p>Ray power is unaffected by angle.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Optical/Emitters/AngularPower.jl#L15-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.Emitters.Directions.Constant" href="#OpticSim.Emitters.Directions.Constant"><code>OpticSim.Emitters.Directions.Constant</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Constant{T} &lt;: AbstractDirectionDistribution{T}</code></pre><p>Encapsulates a single ray direction, where the default direction is unitZ3 [0, 0, 1].</p><pre><code class="language-julia hljs">Constant(direction::Vec3{T}) where {T&lt;:Real}
Constant(::Type{T} = Float64) where {T&lt;:Real}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Optical/Emitters/Directions.jl#L22-L31">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.Emitters.Directions.HexapolarCone" href="#OpticSim.Emitters.Directions.HexapolarCone"><code>OpticSim.Emitters.Directions.HexapolarCone</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">HexapolarCone{T} &lt;: AbstractDirectionDistribution{T}</code></pre><p>Rays are generated by sampling a cone with Œ∏max angle in an hexapolar fashion. The number of rays depends on the requested rings and is computed using the following formula: <code>1 + round(Int64, (nrings * (nrings + 1) / 2) * 6)</code></p><pre><code class="language-julia hljs">HexapolarCone(direction::Vec3{T}, Œ∏max::T, nrings::Int64) where {T&lt;:Real}
HexapolarCone(Œ∏max::T, nrings::Int64 = 3) where {T&lt;:Real}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Optical/Emitters/Directions.jl#L139-L149">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.Emitters.Directions.RectGrid" href="#OpticSim.Emitters.Directions.RectGrid"><code>OpticSim.Emitters.Directions.RectGrid</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RectGrid{T} &lt;: AbstractDirectionDistribution{T}</code></pre><p>Encapsulates a single ray direction, where the default direction is unitZ3 [0, 0, 1].</p><pre><code class="language-julia hljs">Constant(direction::Vec3{T}) where {T&lt;:Real}
Constant(::Type{T} = Float64) where {T&lt;:Real}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Optical/Emitters/Directions.jl#L52-L61">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.Emitters.Directions.UniformCone" href="#OpticSim.Emitters.Directions.UniformCone"><code>OpticSim.Emitters.Directions.UniformCone</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">UniformCone{T} &lt;: AbstractDirectionDistribution{T}</code></pre><p>Encapsulates <code>numsamples</code> rays sampled uniformly from a cone with max angle Œ∏max.</p><pre><code class="language-julia hljs">UniformCone(direction::Vec3{T}, Œ∏max::T, numsamples::Int64) where {T&lt;:Real}
UniformCone(Œ∏max::T, numsamples::Int64) where {T&lt;:Real}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Optical/Emitters/Directions.jl#L98-L107">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.Emitters.Origins.Hexapolar" href="#OpticSim.Emitters.Origins.Hexapolar"><code>OpticSim.Emitters.Origins.Hexapolar</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Hexapolar{T} &lt;: AbstractOriginDistribution{T}</code></pre><p>Encapsulates an ellipse (or a circle where halfsizeu=halfsizev) sampled in an hexapolar fashion (rings).</p><pre><code class="language-julia hljs">Hexapolar(nrings::Int64, halfsizeu::T, halfsizev::T) where {T&lt;:Real} </code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Optical/Emitters/Origins.jl#L163-L171">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.Emitters.Origins.Point" href="#OpticSim.Emitters.Origins.Point"><code>OpticSim.Emitters.Origins.Point</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Point{T} &lt;: AbstractOriginDistribution{T}</code></pre><p>Encapsulates a single point origin.</p><pre><code class="language-julia hljs">Point(position::Vec3{T}) where {T&lt;:Real}
Point(x::T, y::T, z::T) where {T&lt;:Real}
Point(::Type{T} = Float64) where {T&lt;:Real}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Optical/Emitters/Origins.jl#L23-L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.Emitters.Origins.RectGrid" href="#OpticSim.Emitters.Origins.RectGrid"><code>OpticSim.Emitters.Origins.RectGrid</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RectGrid{T} &lt;: AbstractOriginDistribution{T}</code></pre><p>Encapsulates a rectangle sampled in a grid fashion.</p><pre><code class="language-julia hljs">RectGrid(width::T, height::T, usamples::Int64, vsamples::Int64) where {T&lt;:Real} </code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Optical/Emitters/Origins.jl#L85-L93">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.Emitters.Origins.RectJitterGrid" href="#OpticSim.Emitters.Origins.RectJitterGrid"><code>OpticSim.Emitters.Origins.RectJitterGrid</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RectJitterGrid{T} &lt;: AbstractOriginDistribution{T}</code></pre><p>Encapsulates a rectangle sampled in a grid fashion with jitter.</p><pre><code class="language-julia hljs">RectGrid(width::T, height::T, ures::Int64, vres::Int64, samplesPerRegion::Int64) where {T&lt;:Real} </code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Optical/Emitters/Origins.jl#L118-L126">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.Emitters.Origins.RectUniform" href="#OpticSim.Emitters.Origins.RectUniform"><code>OpticSim.Emitters.Origins.RectUniform</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RectUniform{T} &lt;: AbstractOriginDistribution{T}</code></pre><p>Encapsulates a uniformly sampled rectangle with user defined number of samples.</p><pre><code class="language-julia hljs">RectUniform(width::T, height::T, samples_count::Int64) where {T&lt;:Real}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Optical/Emitters/Origins.jl#L54-L62">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.Emitters.Sources.CompositeSource" href="#OpticSim.Emitters.Sources.CompositeSource"><code>OpticSim.Emitters.Sources.CompositeSource</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CompositeSource{T} &lt;: AbstractSource{T}</code></pre><p>This data-type represents the composite emitter (Source) which is constructed with a list of basic or composite emitters and a 3D Transform.</p><pre><code class="language-julia hljs">CompositeSource(transform::Transform{T}, sources::Vector{&lt;:AbstractSource}) where {T&lt;:Real} </code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Optical/Emitters/Sources.jl#L175-L183">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.Emitters.Sources.Source" href="#OpticSim.Emitters.Sources.Source"><code>OpticSim.Emitters.Sources.Source</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Source{T&lt;:Real, Tr&lt;:Transform{T}, S&lt;:Spectrum.AbstractSpectrum{T}, O&lt;:Origins.AbstractOriginDistribution{T}, D&lt;:Directions.AbstractDirectionDistribution{T}, P&lt;:AngularPower.AbstractAngularPowerDistribution{T}} &lt;: AbstractSource{T}</code></pre><p>This data-type represents the basic emitter (Source), which is a combination of a Spectrum, Angular Power Distribution, Origins and Directions distribution and a 3D Transform.</p><pre><code class="language-julia hljs">Source(::Type{T} = Float64;
       transform::Tr = Transform(),
       spectrum::S = Spectrum.Uniform(),
       origins::O = Origins.Point(),
       directions::D = Directions.Constant(),
       power::P = AngularPower.Lambertian(),
       sourcenum::Int64 = 0) where {
            Tr&lt;:Transform,
            S&lt;:Spectrum.AbstractSpectrum,
            O&lt;:Origins.AbstractOriginDistribution,
            D&lt;:Directions.AbstractDirectionDistribution,
            P&lt;:AngularPower.AbstractAngularPowerDistribution,
            T&lt;:Real}

Source(transform::Tr, spectrum::S, origins::O, directions::D, power::P, ::Type{T} = Float64; sourcenum::Int64 = 0) where {   
            Tr&lt;:Transform,
            S&lt;:Spectrum.AbstractSpectrum,
            O&lt;:Origins.AbstractOriginDistribution,
            D&lt;:Directions.AbstractDirectionDistribution,
            P&lt;:AngularPower.AbstractAngularPowerDistribution,
            T&lt;:Real}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Optical/Emitters/Sources.jl#L46-L74">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.Emitters.Spectrum.DeltaFunction" href="#OpticSim.Emitters.Spectrum.DeltaFunction"><code>OpticSim.Emitters.Spectrum.DeltaFunction</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DeltaFunction{T} &lt;: AbstractSpectrum{T}</code></pre><p>Encapsulates a constant spectrum.</p><pre><code class="language-julia hljs">DeltaFunction{T&lt;:Real}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Optical/Emitters/Spectrum.jl#L49-L57">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.Emitters.Spectrum.Measured" href="#OpticSim.Emitters.Spectrum.Measured"><code>OpticSim.Emitters.Spectrum.Measured</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Measured{T} &lt;: AbstractSpectrum{T}</code></pre><p>Encapsulates a measured spectrum to compute emitter power. Create spectrum by reading CSV files. Assumes spectrum samples are evenly spaced - exception otherwise. Evaluate spectrum at arbitrary wavelength with <a href="../emitters/#OpticSim.Emitters.Spectrum.spectrumpower-emitters"><code>spectrumpower</code></a> (<strong>more technical details coming soon</strong>)</p><pre><code class="language-julia hljs">Measured(samples::DataFrame)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Optical/Emitters/Spectrum.jl#L66-L75">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.Emitters.Spectrum.Uniform" href="#OpticSim.Emitters.Spectrum.Uniform"><code>OpticSim.Emitters.Spectrum.Uniform</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Uniform{T} &lt;: AbstractSpectrum{T}</code></pre><p>Encapsulates a flat spectrum range which is sampled uniformly. Unless stated diferrently, the range used will be 450nm to 680nm.</p><pre><code class="language-julia hljs">Uniform(low_end::T, high_end::T) where {T&lt;:Real}
Uniform(::Type{T} = Float64) where {T&lt;:Real}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Optical/Emitters/Spectrum.jl#L21-L30">source</a></section></article><h2 id="Geometry"><a class="docs-heading-anchor" href="#Geometry">Geometry</a><a id="Geometry-1"></a><a class="docs-heading-anchor-permalink" href="#Geometry" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.Geometry.Transform" href="#OpticSim.Geometry.Transform"><code>OpticSim.Geometry.Transform</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Transform{S&lt;:Real}</code></pre><p>Transform encapsulating rotation, translation and scale in 3D space. Translation happens <strong>after</strong> rotation.</p><pre><code class="language-julia hljs">Transform{S}(Œ∏::T, œï::T, œà::T, x::T, y::T, z::T)
Transform(rotation::SMatrix{3,3,S}, translation::SVector{3,S})
Transform(rotation::AbstractArray{S,2}, translation::AbstractArray{S,1})</code></pre><p><code>Œ∏</code>, <code>œï</code> and <code>œà</code> in first constructor are in <strong>radians</strong>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/Transform.jl#L124-L135">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.Geometry.Transform-Union{Tuple{StaticArraysCore.SVector{3, T}}, Tuple{T}, Tuple{StaticArraysCore.SVector{3, T}, StaticArraysCore.SVector{3, T}}} where T&lt;:Real" href="#OpticSim.Geometry.Transform-Union{Tuple{StaticArraysCore.SVector{3, T}}, Tuple{T}, Tuple{StaticArraysCore.SVector{3, T}, StaticArraysCore.SVector{3, T}}} where T&lt;:Real"><code>OpticSim.Geometry.Transform</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Transform(origin, forward) -&gt; Transform{S}</code></pre><p>Returns the <a href="../transforms_and_vectors/#Transform"><code>Transform</code></a> of type <code>S</code> (default <code>Float64</code>) representing the local frame with origin and forward direction. the other 2 axes are computed automatically.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/Transform.jl#L259-L263">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.Geometry.Transform-Union{Tuple{T}, NTuple{4, StaticArraysCore.SVector{4, T}}} where T&lt;:Real" href="#OpticSim.Geometry.Transform-Union{Tuple{T}, NTuple{4, StaticArraysCore.SVector{4, T}}} where T&lt;:Real"><code>OpticSim.Geometry.Transform</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Transform(colx::Vec3{T}, coly::Vec3{T},colz::Vec3{T}, colw::Vec3{T}, ::Type{T} = Float64) where {T&lt;:Real}</code></pre><p>Construct a transform from the input columns.     </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/Transform.jl#L250-L254">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.Geometry.Transform-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{T}}} where T&lt;:Real" href="#OpticSim.Geometry.Transform-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{T}}} where T&lt;:Real"><code>OpticSim.Geometry.Transform</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Transform(rotation::AbstractArray{T,2}, translation::AbstractArray{T,1}) where {T&lt;:Real} -&gt; Transform{S}</code></pre><p>Returns the <a href="../transforms_and_vectors/#Transform"><code>Transform</code></a> of type <code>S</code> (default <code>Float64</code>) created by a rotation matrix (3x3) and translation vector of length 3.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/Transform.jl#L287-L291">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.Geometry.Transform-Union{Tuple{T}, Tuple{StaticArraysCore.SMatrix{3, 3, T}, StaticArraysCore.SVector{3, T}}} where T&lt;:Real" href="#OpticSim.Geometry.Transform-Union{Tuple{T}, Tuple{StaticArraysCore.SMatrix{3, 3, T}, StaticArraysCore.SVector{3, T}}} where T&lt;:Real"><code>OpticSim.Geometry.Transform</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Transform(rotation::SMatrix{3,3,T}, translation::SVector{3,T}) where {T&lt;:Real} -&gt; Transform{S}</code></pre><p>Returns the <a href="../transforms_and_vectors/#Transform"><code>Transform</code></a> of type <code>S</code> (default <code>Float64</code>) created by a rotation matrix and translation vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/Transform.jl#L274-L278">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.Geometry.Transform-Union{Tuple{T}, Tuple{StaticArraysCore.SVector{3, T}, StaticArraysCore.SVector{3, T}, StaticArraysCore.SVector{3, T}}, NTuple{4, StaticArraysCore.SVector{3, T}}} where T&lt;:Real" href="#OpticSim.Geometry.Transform-Union{Tuple{T}, Tuple{StaticArraysCore.SVector{3, T}, StaticArraysCore.SVector{3, T}, StaticArraysCore.SVector{3, T}}, NTuple{4, StaticArraysCore.SVector{3, T}}} where T&lt;:Real"><code>OpticSim.Geometry.Transform</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Transform(colx::Vec3{T}, coly::Vec3{T},colz::Vec3{T}, colw::Vec3{T}, ::Type{T} = Float64) where {T&lt;:Real}</code></pre><p>Construct a transform from the input columns.     </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/Transform.jl#L240-L244">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.Geometry.Transform-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T&lt;:Real" href="#OpticSim.Geometry.Transform-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T&lt;:Real"><code>OpticSim.Geometry.Transform</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Transform([S::Type]) -&gt; Transform{S}</code></pre><p>Returns the <a href="../transforms_and_vectors/#Transform"><code>Transform</code></a> of type <code>S</code> (default <code>Float64</code>) representing the identity transform.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/Transform.jl#L231-L235">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.Geometry.Vec3" href="#OpticSim.Geometry.Vec3"><code>OpticSim.Geometry.Vec3</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>Vec3{T}</code> provides an immutable vector of fixed length 3 and type <code>T</code>.</p><p><code>Vec3</code> defines a series of convenience constructors, so you can just type e.g. <code>Vec3(1, 2, 3)</code> or <code>Vec3([1.0, 2.0, 3.0])</code>.  It also supports comprehensions, and the <code>zeros()</code>, <code>ones()</code>, <code>fill()</code>, <code>rand()</code> and <code>randn()</code> functions, such as <code>Vec3(rand(3))</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/Transform.jl#L14-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.Geometry.Vec4" href="#OpticSim.Geometry.Vec4"><code>OpticSim.Geometry.Vec4</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>Vec4{T}</code> provides an immutable vector of fixed length 4 and type <code>T</code>.</p><p><code>Vec4</code> defines a series of convenience constructors, so you can just type e.g. <code>Vec3(1, 2, 3, 4)</code> or <code>Vec3([1.0, 2.0, 3.0, 4.0])</code>.  It also supports comprehensions, and the <code>zeros()</code>, <code>ones()</code>, <code>fill()</code>, <code>rand()</code> and <code>randn()</code> functions, such as <code>Vec4(rand(4))</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/Transform.jl#L45-L50">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.Geometry.Vec4-Union{Tuple{StaticArraysCore.SMatrix{3, N, T}}, Tuple{T}, Tuple{N}} where {N, T&lt;:Real}" href="#OpticSim.Geometry.Vec4-Union{Tuple{StaticArraysCore.SMatrix{3, N, T}}, Tuple{T}, Tuple{N}} where {N, T&lt;:Real}"><code>OpticSim.Geometry.Vec4</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Vec4(m::SMatrix{3,N,T} where{N,T&lt;:Real} -&gt; SMatrix{3,N,T})</code></pre><p>Input is matrix of 3d points, each column is one point. Returns matrix of 3d points with 1 appended in the last row.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/Transform.jl#L66-L70">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.Geometry.Vec4-Union{Tuple{StaticArraysCore.SVector{3, T}}, Tuple{T}} where T&lt;:Real" href="#OpticSim.Geometry.Vec4-Union{Tuple{StaticArraysCore.SVector{3, T}}, Tuple{T}} where T&lt;:Real"><code>OpticSim.Geometry.Vec4</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Vec4(v::SVector{3, T}) where {T&lt;:Real} -&gt; Vec4{T}</code></pre><p>Accept <code>SVector</code> and create a <code>Vec4</code> type [v[1], v[2], v[3], 1]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/Transform.jl#L57-L61">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.Geometry.decomposeRTS-Union{Tuple{OpticSim.Geometry.Transform{T}}, Tuple{T}} where T&lt;:Real" href="#OpticSim.Geometry.decomposeRTS-Union{Tuple{OpticSim.Geometry.Transform{T}}, Tuple{T}} where T&lt;:Real"><code>OpticSim.Geometry.decomposeRTS</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">decomposeRTS(tr::Transform{T}) where {T&lt;:Real}</code></pre><p>return a tuple containing the rotation matrix, the translation vector and the scale vecto represnting the transform.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/Transform.jl#L515-L519">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.Geometry.forward-Tuple{OpticSim.Geometry.Transform{&lt;:Real}}" href="#OpticSim.Geometry.forward-Tuple{OpticSim.Geometry.Transform{&lt;:Real}}"><code>OpticSim.Geometry.forward</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">forward(t::Transform{&lt;:Real}) -&gt; Vec3</code></pre><p>Assuming t is a 3D rigid transform representing a local left-handed coordinate system, this function will return the third column, representing the &quot;Z&quot; axis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/Transform.jl#L318-L322">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.Geometry.identitytransform-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T&lt;:Real" href="#OpticSim.Geometry.identitytransform-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T&lt;:Real"><code>OpticSim.Geometry.identitytransform</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>identitytransform([S::Type]) -&gt; Transform{S}</p><p>Returns the <a href="../transforms_and_vectors/#Transform"><code>Transform</code></a> of type <code>S</code> (default <code>Float64</code>) representing the identity transform.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/Transform.jl#L218-L222">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.Geometry.local2world-Union{Tuple{OpticSim.Geometry.Transform{T}}, Tuple{T}} where T&lt;:Real" href="#OpticSim.Geometry.local2world-Union{Tuple{OpticSim.Geometry.Transform{T}}, Tuple{T}} where T&lt;:Real"><code>OpticSim.Geometry.local2world</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">local2world(t::Transform{T}) where {T&lt;:Real}</code></pre><p>return the transform matrix that takes a point in the local coordinate system to the global one</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/Transform.jl#L493-L497">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.Geometry.right-Tuple{OpticSim.Geometry.Transform{&lt;:Real}}" href="#OpticSim.Geometry.right-Tuple{OpticSim.Geometry.Transform{&lt;:Real}}"><code>OpticSim.Geometry.right</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">right(t::Transform{&lt;:Real}) -&gt; Vec3</code></pre><p>Assuming t is a 3D rigid transform representing a local left-handed coordinate system, this function will return the first column, representing the &quot;X&quot; axis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/Transform.jl#L304-L308">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.Geometry.rotation-Union{Tuple{OpticSim.Geometry.Transform{T}}, Tuple{T}} where T&lt;:Real" href="#OpticSim.Geometry.rotation-Union{Tuple{OpticSim.Geometry.Transform{T}}, Tuple{T}} where T&lt;:Real"><code>OpticSim.Geometry.rotation</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rotation(t::Transform{T}) where {T&lt;:Real} -&gt; SMatrix{3,3,T}</code></pre><p>returns the rotation part of the transform <code>t</code> - a 3x3 matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/Transform.jl#L398-L402">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.Geometry.rotation-Union{Tuple{T}, Tuple{T, T, T}} where T&lt;:Number" href="#OpticSim.Geometry.rotation-Union{Tuple{T}, Tuple{T, T, T}} where T&lt;:Number"><code>OpticSim.Geometry.rotation</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rotation([S::Type], Œ∏::T, œï::T, œà::T) -&gt; Transform{S}</code></pre><p>Returns the <a href="../transforms_and_vectors/#Transform"><code>Transform</code></a> of type <code>S</code> (default <code>Float64</code>) representing the rotation by <code>Œ∏</code>, <code>œï</code> and <code>œà</code> around the <em>x</em>, <em>y</em> and <em>z</em> axes respectively <strong>in radians</strong>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/Transform.jl#L419-L423">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.Geometry.rotationX-Tuple{T} where T&lt;:Real" href="#OpticSim.Geometry.rotationX-Tuple{T} where T&lt;:Real"><code>OpticSim.Geometry.rotationX</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rotationX(angle::T) where {T&lt;:Real} -&gt; Transform</code></pre><p>Builds a rotation matrix for a rotation around the x-axis.  Parameters:     The counter-clockwise <code>angle</code> in radians.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/Transform.jl#L335-L341">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.Geometry.rotationY-Tuple{T} where T&lt;:Real" href="#OpticSim.Geometry.rotationY-Tuple{T} where T&lt;:Real"><code>OpticSim.Geometry.rotationY</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rotationY(angle::T) where {T&lt;:Real} -&gt; Transform</code></pre><p>Builds a rotation matrix for a rotation around the y-axis.  Parameters:     The counter-clockwise <code>angle</code> in radians.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/Transform.jl#L356-L362">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.Geometry.rotationZ-Tuple{T} where T&lt;:Real" href="#OpticSim.Geometry.rotationZ-Tuple{T} where T&lt;:Real"><code>OpticSim.Geometry.rotationZ</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rotationZ(angle::T) where {T&lt;:Real} -&gt; Transform</code></pre><p>Builds a rotation matrix for a rotation around the z-axis.  Parameters:     The counter-clockwise <code>angle</code> in radians.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/Transform.jl#L377-L383">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.Geometry.rotationd-Union{Tuple{T}, Tuple{T, T, T}} where T&lt;:Number" href="#OpticSim.Geometry.rotationd-Union{Tuple{T}, Tuple{T, T, T}} where T&lt;:Number"><code>OpticSim.Geometry.rotationd</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rotationd([S::Type], Œ∏::T, œï::T, œà::T) -&gt; Transform{S}</code></pre><p>Returns the <a href="../transforms_and_vectors/#Transform"><code>Transform</code></a> of type <code>S</code> (default <code>Float64</code>) representing the rotation by <code>Œ∏</code>, <code>œï</code> and <code>œà</code> around the <em>x</em>, <em>y</em> and <em>z</em> axes respectively <strong>in degrees</strong>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/Transform.jl#L426-L430">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.Geometry.rotmat-Union{Tuple{T}, Tuple{T, T, T}} where T&lt;:Number" href="#OpticSim.Geometry.rotmat-Union{Tuple{T}, Tuple{T, T, T}} where T&lt;:Number"><code>OpticSim.Geometry.rotmat</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rotmat([S::Type], Œ∏::T, œï::T, œà::T) -&gt; SMatrix{3,3,S}</code></pre><p>Returns the rotation matrix of type <code>S</code> (default <code>Float64</code>) representing the rotation by <code>Œ∏</code>, <code>œï</code> and <code>œà</code> around the <em>x</em>, <em>y</em> and <em>z</em> axes respectively <strong>in radians</strong>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/Transform.jl#L556-L560">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.Geometry.rotmatd-Union{Tuple{T}, Tuple{T, T, T}} where T&lt;:Number" href="#OpticSim.Geometry.rotmatd-Union{Tuple{T}, Tuple{T, T, T}} where T&lt;:Number"><code>OpticSim.Geometry.rotmatd</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rotmatd([S::Type], Œ∏::T, œï::T, œà::T) -&gt; SMatrix{3,3,S}</code></pre><p>Returns the rotation matrix of type <code>S</code> (default <code>Float64</code>) representing the rotation by <code>Œ∏</code>, <code>œï</code> and <code>œà</code> around the <em>x</em>, <em>y</em> and <em>z</em> axes respectively <strong>in degrees</strong>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/Transform.jl#L548-L552">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.Geometry.scale-Tuple{T} where T&lt;:Real" href="#OpticSim.Geometry.scale-Tuple{T} where T&lt;:Real"><code>OpticSim.Geometry.scale</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">scale(s::T) where {T&lt;:Real}</code></pre><p>Creates a uniform scaling transform</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/Transform.jl#L474-L478">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.Geometry.scale-Union{Tuple{StaticArraysCore.SVector{3, T}}, Tuple{T}} where T&lt;:Real" href="#OpticSim.Geometry.scale-Union{Tuple{StaticArraysCore.SVector{3, T}}, Tuple{T}} where T&lt;:Real"><code>OpticSim.Geometry.scale</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">scale(t::Vec3{T}) where {T&lt;:Real}</code></pre><p>Creates a scaling transform</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/Transform.jl#L483-L487">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.Geometry.scale-Union{Tuple{T}, Tuple{T, T, T}} where T&lt;:Real" href="#OpticSim.Geometry.scale-Union{Tuple{T}, Tuple{T, T, T}} where T&lt;:Real"><code>OpticSim.Geometry.scale</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">scale(x::T, y::T, z::T) where {T&lt;:Real}</code></pre><p>Creates a scaling transform</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/Transform.jl#L460-L464">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.Geometry.translation-Union{Tuple{StaticArraysCore.SVector{3, T}}, Tuple{T}} where T&lt;:Real" href="#OpticSim.Geometry.translation-Union{Tuple{StaticArraysCore.SVector{3, T}}, Tuple{T}} where T&lt;:Real"><code>OpticSim.Geometry.translation</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">translation(x::T, y::T, z::T) where {T&lt;:Real}</code></pre><p>Creates a translation transform</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/Transform.jl#L450-L454">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.Geometry.translation-Union{Tuple{S}, Tuple{T}, Tuple{Type{S}, T, T, T}} where {T&lt;:Number, S&lt;:Real}" href="#OpticSim.Geometry.translation-Union{Tuple{S}, Tuple{T}, Tuple{Type{S}, T, T, T}} where {T&lt;:Number, S&lt;:Real}"><code>OpticSim.Geometry.translation</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">translation(x::T, y::T, z::T) where {T&lt;:Real}</code></pre><p>Creates a translation transform</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/Transform.jl#L434-L438">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.Geometry.unitW4-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T&lt;:Real" href="#OpticSim.Geometry.unitW4-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T&lt;:Real"><code>OpticSim.Geometry.unitW4</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>returns the unit vector <code>[0, 0, 0, 1]</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/Transform.jl#L85-L87">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.Geometry.unitX3-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T&lt;:Real" href="#OpticSim.Geometry.unitX3-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T&lt;:Real"><code>OpticSim.Geometry.unitX3</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>returns the unit vector <code>[1, 0, 0]</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/Transform.jl#L26-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.Geometry.unitX4-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T&lt;:Real" href="#OpticSim.Geometry.unitX4-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T&lt;:Real"><code>OpticSim.Geometry.unitX4</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>returns the unit vector <code>[1, 0, 0, 0]</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/Transform.jl#L73-L75">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.Geometry.unitY3-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T&lt;:Real" href="#OpticSim.Geometry.unitY3-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T&lt;:Real"><code>OpticSim.Geometry.unitY3</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>returns the unit vector <code>[0, 1, 0]</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/Transform.jl#L30-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.Geometry.unitY4-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T&lt;:Real" href="#OpticSim.Geometry.unitY4-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T&lt;:Real"><code>OpticSim.Geometry.unitY4</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>returns the unit vector <code>[0, 1, 0, 0]</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/Transform.jl#L77-L79">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.Geometry.unitZ3-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T&lt;:Real" href="#OpticSim.Geometry.unitZ3-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T&lt;:Real"><code>OpticSim.Geometry.unitZ3</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>returns the unit vector <code>[0, 0, 1]</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/Transform.jl#L34-L36">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.Geometry.unitZ4-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T&lt;:Real" href="#OpticSim.Geometry.unitZ4-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T&lt;:Real"><code>OpticSim.Geometry.unitZ4</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>returns the unit vector <code>[0, 0, 1, 0]</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/Transform.jl#L81-L83">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.Geometry.up-Tuple{OpticSim.Geometry.Transform{&lt;:Real}}" href="#OpticSim.Geometry.up-Tuple{OpticSim.Geometry.Transform{&lt;:Real}}"><code>OpticSim.Geometry.up</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">up(t::Transform{&lt;:Real}) -&gt; Vec3</code></pre><p>Assuming t is a 3D rigid transform representing a local left-handed coordinate system, this function will return the second column, representing the &quot;Y&quot; axis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/Transform.jl#L311-L315">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.Geometry.world2local-Union{Tuple{OpticSim.Geometry.Transform{T}}, Tuple{T}} where T&lt;:Real" href="#OpticSim.Geometry.world2local-Union{Tuple{OpticSim.Geometry.Transform{T}}, Tuple{T}} where T&lt;:Real"><code>OpticSim.Geometry.world2local</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">world2local(t::Transform{T}) where {T&lt;:Real}</code></pre><p>return the transform matrix that takes a point in the global coordinate system to the local one</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/Transform.jl#L503-L507">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.origin-Tuple{OpticSim.Geometry.Transform{&lt;:Real}}" href="#OpticSim.origin-Tuple{OpticSim.Geometry.Transform{&lt;:Real}}"><code>OpticSim.origin</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">origin(t::Transform{&lt;:Real}) -&gt; Vec3</code></pre><p>Assuming t is a 3D rigid transform representing a local left-handed coordinate system, this function will return the fourth column, containing the translation part of the transform in 3D.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/Transform.jl#L325-L329">source</a></section></article><h2 id="Zernike"><a class="docs-heading-anchor" href="#Zernike">Zernike</a><a id="Zernike-1"></a><a class="docs-heading-anchor-permalink" href="#Zernike" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.Zernike" href="#OpticSim.Zernike"><code>OpticSim.Zernike</code></a> ‚Äî <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Module to enclose <a href="https://en.wikipedia.org/wiki/Zernike_polynomials">Zernike polynomial</a> specific functionality.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/Primitives/Zernike.jl#L5-L7">source</a></section></article><h2 id="QType"><a class="docs-heading-anchor" href="#QType">QType</a><a id="QType-1"></a><a class="docs-heading-anchor-permalink" href="#QType" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.QType" href="#OpticSim.QType"><code>OpticSim.QType</code></a> ‚Äî <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Module to enclose QType polynomial specific functionality. For reference see:</p><ol><li><a href="https://www.osapublishing.org/viewmedia.cfm?uri=oe-18-19-19700&amp;seq=0"><em>Robust, efficient computational methods for axially symmetric optical aspheres</em> - G. W. Forbes, 2010</a></li><li><a href="https://www.osapublishing.org/viewmedia.cfm?uri=oe-20-3-2483&amp;seq=0"><em>Characterizing the shape of freeform optics</em> - G. W. Forbes, 2012</a></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/Primitives/Qtype.jl#L5-L10">source</a></section></article><h2 id="Chebyshev"><a class="docs-heading-anchor" href="#Chebyshev">Chebyshev</a><a id="Chebyshev-1"></a><a class="docs-heading-anchor-permalink" href="#Chebyshev" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.Chebyshev" href="#OpticSim.Chebyshev"><code>OpticSim.Chebyshev</code></a> ‚Äî <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Module to enclose <a href="https://en.wikipedia.org/wiki/Chebyshev_polynomials">Chebyshev polynomial</a> specific functionality.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Geometry/Primitives/Chebyshev.jl#L5-L7">source</a></section></article><h2 id="Data"><a class="docs-heading-anchor" href="#Data">Data</a><a id="Data-1"></a><a class="docs-heading-anchor-permalink" href="#Data" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.Data.ArizonaEye-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T&lt;:Real" href="#OpticSim.Data.ArizonaEye-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T&lt;:Real"><code>OpticSim.Data.ArizonaEye</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ArizonaEye(::Type{T} = Float64; accommodation::T = 0.0)</code></pre><p>The popular Arizona eye model taken from <a href="https://photonengr.com/wp-content/uploads/kbasefiles/ArizonaEyeModel.pdf">this definition</a>. The <code>accommodation</code> of the eye can be varied in this model. Returns a <code>DataFrame</code> specifying the prescription of the eye model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Data/Data.jl#L130-L136">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.Data.ModelEye-Union{Tuple{LensAssembly{T}}, Tuple{D}, Tuple{T}} where {T&lt;:Real, D&lt;:Real}" href="#OpticSim.Data.ModelEye-Union{Tuple{LensAssembly{T}}, Tuple{D}, Tuple{T}} where {T&lt;:Real, D&lt;:Real}"><code>OpticSim.Data.ModelEye</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ModelEye(assembly::LensAssembly{T}, nsamples::Int = 17; pupil_radius::T = 3.0, detpixels::Int = 1000, transform::Transform{T} = identitytransform(T))</code></pre><p>Geometrically accurate model of the human eye focused at infinity with variable <code>pupil_radius</code>. The eye is added to the provided <code>assembly</code> to create a <a href="#OpticSim.CSGOpticalSystem"><code>CSGOpticalSystem</code></a> with the retina of the eye as the detector.</p><p>The eye can be positioned in the scene using the <code>transform</code> argument and the resolution of the detector specified with <code>detpixels</code>. By default the eye is directed along the positive z-axis with the vertex of the cornea at the origin.</p><p><code>nsamples</code> determines the resolution at which accelerated surfaces within the eye are triangulated.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Data/Data.jl#L78-L88">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.Data.comfortable_entrance_pupil_translation-Tuple{}" href="#OpticSim.Data.comfortable_entrance_pupil_translation-Tuple{}"><code>OpticSim.Data.comfortable_entrance_pupil_translation</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Average one sided translation of the entrance pupil associated with comfortable eye rotation. If you are using this to define an eyebox multiply this value by 2</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Data/Data.jl#L72">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.Data.cornea_to_eyecenter-Tuple{}" href="#OpticSim.Data.cornea_to_eyecenter-Tuple{}"><code>OpticSim.Data.cornea_to_eyecenter</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>distance from vertex of cornea to center of rotation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Data/Data.jl#L59">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.Data.entrancepupil_to_eyecenter-Tuple{}" href="#OpticSim.Data.entrancepupil_to_eyecenter-Tuple{}"><code>OpticSim.Data.entrancepupil_to_eyecenter</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>distance from entrance pupil to center of rotation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Data/Data.jl#L65">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.Data.eyefocallength-Tuple{}" href="#OpticSim.Data.eyefocallength-Tuple{}"><code>OpticSim.Data.eyefocallength</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Posterior focal length, i.e., optical distance from entrance pupil to the retina. Focal length will change depending on accommodation. This value is for focus at ‚àû. When the eye is focused at 25cm focal length will be ‚âà 22mm. Because the index of refraction of the vitreous humor is approximately 1.33 the physical distance from the entrance pupil to the retina will be 24mm/1.33 = 18mm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Data/Data.jl#L52">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OpticSim.Data.ùêÉsd-Tuple{Any, Any}" href="#OpticSim.Data.ùêÉsd-Tuple{Any, Any}"><code>OpticSim.Data.ùêÉsd</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>computes pupil diameter as a function of scene luminance <code>L</code>, in cd/m¬≤, and the angular area, <code>a</code>, over which this luminance is presented to the eye.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/92fcf0eafd89b32360372f47d48979c2a568f045/src/Data/Data.jl#L45">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../lenses/">¬´ Lenses</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.15.0 on <span class="colophon-date" title="Tuesday 11 November 2025 20:15">Tuesday 11 November 2025</span>. Using Julia version 1.12.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

var documenterSearchIndex = {"docs":
[{"location":"interfaces/#Optical-Interfaces","page":"Interfaces","title":"Optical Interfaces","text":"","category":"section"},{"location":"interfaces/","page":"Interfaces","title":"Interfaces","text":"Every Surface must have an OpticalInterface associated with it to defined the behavior of any ray when it intersects that surface.","category":"page"},{"location":"interfaces/#OpticSim.OpticalInterface-interfaces","page":"Interfaces","title":"OpticSim.OpticalInterface","text":"OpticalInterface{T<:Real}\n\nAny subclass of OpticalInterface must implement the following:\n\nprocessintersection(opticalinterface::OpticalInterface{T}, point::SVector{N,T}, normal::SVector{N,T}, incidentray::OpticalRay{T,N}, temperature::T, pressure::T, ::Bool, firstray::Bool = false) -> Tuple{SVector{N,T}, T, T}\ninsidematerial(i::OpticalInterface{T}) -> AGFFileReader.AbstractGlass\noutsidematerial(i::OpticalInterface{T}) -> AGFFileReader.AbstractGlass\nreflectance(i::OpticalInterface{T}) -> T\ntransmission(i::OpticalInterface{T}) -> T\n\nSee documentation for processintersection for details.\n\n\n\n\n\n","category":"type"},{"location":"interfaces/#OpticSim.NullInterface-interfaces","page":"Interfaces","title":"OpticSim.NullInterface","text":"NullInterface{T} <: OpticalInterface{T}\n\nInterface which will be ignored totally by any rays, used only in construction of CSG objects.\n\nNullInterface(T = Float64)\nNullInterface{T}()\n\n\n\n\n\n","category":"type"},{"location":"interfaces/#OpticSim.FresnelInterface-interfaces","page":"Interfaces","title":"OpticSim.FresnelInterface","text":"FresnelInterface{T} <: OpticalInterface{T}\n\nInterface between two materials with behavior defined according to the Fresnel equations, with a specified reflectance and transmission. Assumes unpolarized light.\n\nFresnelInterface{T}(insidematerial, outsidematerial; reflectance = 0, transmission = 1, interfacemode = ReflectOrTransmit)\n\nThe interfacemode can be used to trace rays deterministically. Valid values are defined in the InterfaceMode enum. Reflect means that all values are reflected, Transmit means that all values are transmitted. ReflectOrTransmit will randomly reflect and transmit rays with the distribution given by the reflection and transmission arguments. This is also the default. In all cases the power recorded with the ray is correctly updated. This can be used to fake sequential raytracing. For example a beamsplitter surface may be set to either Reflect or Transmit to switch between the two outgoing ray paths.\n\n\n\n\n\n","category":"type"},{"location":"interfaces/#OpticSim.ParaxialInterface-interfaces","page":"Interfaces","title":"OpticSim.ParaxialInterface","text":"ParaxialInterface{T} <: OpticalInterface{T}\n\nInterface describing an idealized planar lens, i.e. one that is thin and with no aberrations.\n\nIn general this interface should not be constructed directly, the ParaxialLensEllipse and ParaxialLensRect functions should be used to create a ParaxialLens object directly.\n\nParaxialInterface(focallength::T, centroid::SVector{3,T}, outsidematerial::Y)\n\n\n\n\n\n","category":"type"},{"location":"interfaces/#OpticSim.ThinGratingInterface-interfaces","page":"Interfaces","title":"OpticSim.ThinGratingInterface","text":"ThinGratingInterface{T} <: OpticalInterface{T}\n\nInterface representing an idealized thin grating. period is in microns, vector should lie in the plane of the surface. Transmission and reflectance can be specified for an arbitrary number of orders up to 10, selected using the maxorder and minorder parameters. If nothing then reflectance is assumed to be 0 and transmission is assumed to be 1.\n\nThinGratingInterface(vector, period, insidematerial, outsidematerial; maxorder = 1, minorder = -1, reflectance = nothing, transmission = nothing)\n\n\n\n\n\n","category":"type"},{"location":"interfaces/#OpticSim.HologramInterface-interfaces","page":"Interfaces","title":"OpticSim.HologramInterface","text":"HologramInterface{T} <: OpticalInterface{T}\n\nInterface representing a thick hologram (though geometrically thin). The efficiency, η, is calculated using Kogelnik's coupled wave theory so is only valid for the first order. If the zero order is included then it has efficiency 1 - η. Also assumes that the HOE was recorded under similar conditions to the playback conditions, thickness is in microns.\n\nBeatState arguments can be one of ConvergingBeam, DivergingBeam and CollimatedBeam. In the first two cases signalpointordir and referencepointordir are 3D point in global coordinate space. For CollimatedBeam they are normalized direction vectors.\n\nFor reference, see:\n\nCoupled Wave Theory for Thick Hologram Gratings - H Kogelnik, 1995\nSequential and non-sequential simulation of volume holographic gratings - M Kick et al, 2018\n\nHologramInterface(signalpointordir::SVector{3,T}, signalbeamstate::BeamState, referencepointordir::SVector{3,T}, referencebeamstate::BeamState, recordingλ::T, thickness::T, beforematerial, substratematerial, aftermaterial, signalrecordingmaterial, referencerecordingmaterial, RImodulation::T, include0order  = false)\n\n\n\n\n\n","category":"type"},{"location":"interfaces/","page":"Interfaces","title":"Interfaces","text":"The critical behavior of each interface is defined in the processintersection function:","category":"page"},{"location":"interfaces/#OpticSim.processintersection-interfaces","page":"Interfaces","title":"OpticSim.processintersection","text":"processintersection(opticalinterface::OpticalInterface{T}, point::SVector{N,T}, normal::SVector{N,T}, incidentray::OpticalRay{T,N}, temperature::T, pressure::T, ::Bool, firstray::Bool = false) -> Tuple{SVector{N,T}, T, T}\n\nProcesses an intersection of an OpticalRay with an OpticalInterface, distinct behaviors must be implemented for each subclass of OpticalInterface.\n\npoint is the 3D intersection point in global space, normal is the surface normal at the intersection point.\n\nIf test is true then the behavior of the ray should be deterministic. firstray indicates that this ray is the first segment of the trace and therefore the origin is not offset.\n\nThe values returned are the normalized direction of the ray after the intersection, the instantaneous power of the ray after the intersection and the optical path length of the ray up to the intersection.\n\nnothing is returned if the ray should stop here, in order to obtain the correct intensity on the detector through monte carlo integration nothing should be returned proportionally to create the correct power distribution. i.e. If the interface should modulate power to 76% then 24% of calls to this function should return nothing.\n\n\n\n\n\n","category":"function"},{"location":"systems/#Optical-Systems","page":"Systems","title":"Optical Systems","text":"","category":"section"},{"location":"systems/#Assemblies","page":"Systems","title":"Assemblies","text":"","category":"section"},{"location":"systems/","page":"Systems","title":"Systems","text":"All systems are made up of a LensAssembly which contains all the optical components in the system, excluding any sources (see Emitters) and the detector (see below).","category":"page"},{"location":"systems/#OpticSim.LensAssembly-systems","page":"Systems","title":"OpticSim.LensAssembly","text":"LensAssembly{T<:Real}\n\nStructure which contains the elements of the optical system, these can be CSGTree or Surface objects.\n\nIn order to prevent type ambiguities bespoke structs are created for each possible number of elements e.g. LensAssembly3. These are parameterized by the types of the elements to prevent ambiguities. Basic surface types such as Rectangle (which can occur in large numbers) are stored independently in Vectors, so type parameters are only needed for CSG objects.\n\nEach struct looks like this:\n\nstruct LensAssemblyN{T,T1,T2,...,TN} <: LensAssembly{T}\n    axis::SVector{3,T}\n    rectangles::Vector{Rectangle{T}}\n    ellipses::Vector{Ellipse{T}}\n    hexagons::Vector{Hexagon{T}}\n    paraxials::Vector{ParaxialLens{T}}\n    E1::T1\n    E2::T2\n    ...\n    EN::TN\nend\n\nWhere Ti <: Union{Surface{T},CSGTree{T}}.\n\nTo create a LensAssembly object the following functions can be used:\n\nLensAssembly(elements::Vararg{Union{Surface{T},CSGTree{T},LensAssembly{T}}}; axis = SVector(0.0, 0.0, 1.0)) where {T<:Real}\n\n\n\n\n\n","category":"type"},{"location":"systems/#Images","page":"Systems","title":"Images","text":"","category":"section"},{"location":"systems/","page":"Systems","title":"Systems","text":"The detector image is stored within the system as a HierarchicalImage for memory efficiency.","category":"page"},{"location":"systems/#OpticSim.HierarchicalImage-systems","page":"Systems","title":"OpticSim.HierarchicalImage","text":"HierarchicalImage{T<:Number} <: AbstractArray{T,2}\n\nImage type which dynamically allocated memory for pixels when their value is set, the value of unset pixels is assumed to be zero.\n\nThis is used for the detector image of AbstractOpticalSystems which can typically be very high resolution, but often have a large proportion of the image blank.\n\n\n\n\n\n","category":"type"},{"location":"systems/#OpticSim.reset!-systems","page":"Systems","title":"OpticSim.reset!","text":"reset!(a::HierarchicalImage{T})\n\nResets the pixels in the image to zero(T). Do this rather than image .= zero(T) because that will cause every pixel to be accessed, and therefore allocated. For large images this can cause huge memory traffic.\n\n\n\n\n\n","category":"function"},{"location":"systems/#OpticSim.sum!-systems","page":"Systems","title":"OpticSim.sum!","text":"sum!(a::HierarchicalImage{T}, b::HierarchicalImage{T})\n\nAdd the contents of b to a in an efficient way.\n\n\n\n\n\n","category":"function"},{"location":"systems/#Systems","page":"Systems","title":"Systems","text":"","category":"section"},{"location":"systems/","page":"Systems","title":"Systems","text":"There are two types of AbstractOpticalSystem which can be used depending on the requirements.","category":"page"},{"location":"systems/#OpticSim.AbstractOpticalSystem-systems","page":"Systems","title":"OpticSim.AbstractOpticalSystem","text":"AbstractOpticalSystem{T<:Real}\n\nAbstract type for any optical system, must parameterized by the datatype of entities within the system T.\n\n\n\n\n\n","category":"type"},{"location":"systems/#OpticSim.CSGOpticalSystem-systems","page":"Systems","title":"OpticSim.CSGOpticalSystem","text":"CSGOpticalSystem{T,D<:Real,S<:Surface{T},L<:LensAssembly{T}} <: AbstractOpticalSystem{T}\n\nAn optical system containing a lens assembly with all optical elements and a detector surface with associated image. The system can be at a specified temperature and pressure.\n\nThere are two number types in the type signature. The T type parameter is the numeric type for geometry in the optical system, the D type parameter is the numeric type of the pixels in the detector image. This way you can have Float64 geometry, where high precision is essential, but the pixels in the detector can be Float32 since precision is much less critical for image data, or Complex if doing wave optic simulations.\n\nThe detector can be any Surface which implements uv, uvtopix and onsurface, typically this is one of Rectangle, Ellipse or SphericalCap.\n\nCSGOpticalSystem(\n    assembly::LensAssembly,\n    detector::Surface,\n    detectorpixelsx = 1000,\n    detectorpixelsy = 1000, ::Type{D} = Float32;\n    temperature = AGFFileReader.TEMP_REF,\n    pressure = AGFFileReader.PRESSURE_REF\n)\n\n\n\n\n\n","category":"type"},{"location":"systems/#OpticSim.AxisymmetricOpticalSystem-systems","page":"Systems","title":"OpticSim.AxisymmetricOpticalSystem","text":"AxisymmetricOpticalSystem{T,C<:CSGOpticalSystem{T}} <: AbstractOpticalSystem{T}\n\nOptical system which has lens elements and an image detector, created from a DataFrame containing prescription data.\n\nThese tags are supported for columns: :Radius, :SemiDiameter, :SurfaceType, :Thickness, :Conic, :Parameters, :Reflectance, :Material.\n\nThese tags are supported for entries in a SurfaceType column: Object, Image, Stop. Assumes the Image row will be the last row in the DataFrame.\n\nIn practice a CSGOpticalSystem is generated automatically and stored within this system.\n\nAxisymmetricOpticalSystem{T}(\n    prescription::DataFrame,\n    detectorpixelsx = 1000,\n    detectorpixelsy:: = 1000,\n    ::Type{D} = Float32;\n    temperature = AGFFileReader.TEMP_REF,\n    pressure = AGFFileReader.PRESSURE_REF\n)\n\n\n\n\n\n","category":"type"},{"location":"systems/#OpticSim.temperature-systems","page":"Systems","title":"OpticSim.temperature","text":"temperature(system::AbstractOpticalSystem{T}) -> T\n\nGet the temperature of system in °C.\n\n\n\n\n\n","category":"function"},{"location":"systems/#OpticSim.pressure-systems","page":"Systems","title":"OpticSim.pressure","text":"pressure(system::AbstractOpticalSystem{T}) -> T\n\nGet the pressure of system in Atm.\n\n\n\n\n\n","category":"function"},{"location":"systems/#OpticSim.detectorimage-systems","page":"Systems","title":"OpticSim.detectorimage","text":"detectorimage(system::AbstractOpticalSystem{T}) -> HierarchicalImage{D}\n\nGet the detector image of system. D is the datatype of the detector image and is not necessarily the same as the datatype of the system T.\n\n\n\n\n\n","category":"function"},{"location":"systems/#OpticSim.resetdetector!-systems","page":"Systems","title":"OpticSim.resetdetector!","text":"resetdetector!(system::AbstractOpticalSystem{T})\n\nReset the deterctor image of system to zero.\n\n\n\n\n\n","category":"function"},{"location":"systems/#OpticSim.assembly-systems","page":"Systems","title":"OpticSim.assembly","text":"assembly(system::AbstractOpticalSystem{T}) -> LensAssembly{T}\n\nGet the LensAssembly of system.\n\n\n\n\n\n","category":"function"},{"location":"systems/#OpticSim.semidiameter-systems","page":"Systems","title":"OpticSim.semidiameter","text":"semidiameter(system::AxisymmetricOpticalSystem{T}) -> T\n\nGet the semidiameter of system, that is the semidiameter of the entrance pupil (i.e. first surface) of the system.\n\n\n\n\n\n","category":"function"},{"location":"systems/#Tracing","page":"Systems","title":"Tracing","text":"","category":"section"},{"location":"systems/","page":"Systems","title":"Systems","text":"We can trace an individual OpticalRay through the system (or directly through a LensAssembly), or we can trace using an OpticalRayGenerator to create a large number of rays.","category":"page"},{"location":"systems/#OpticSim.trace-systems","page":"Systems","title":"OpticSim.trace","text":"trace(assembly::LensAssembly{T}, r::OpticalRay{T}, temperature::T = 20.0, pressure::T = 1.0; trackrays = nothing, test = false)\n\nReturns the ray as it exits the assembly in the form of a LensTrace object if it hits any element in the assembly, otherwise nothing. Recursive rays are offset by a small amount (RAY_OFFSET) to prevent it from immediately reintersecting the same lens element.\n\ntrackrays can be passed an empty vector to accumulate the LensTrace objects at each intersection of ray with a surface in the assembly.\n\n\n\n\n\ntrace(system::AbstractOpticalSystem{T}, ray::OpticalRay{T}; trackrays = nothing, test = false)\n\nTraces system with ray, if test is enabled then fresnel reflections are disabled and the power distribution will not be correct. Returns either a LensTrace if the ray hits the detector or nothing otherwise.\n\ntrackrays can be passed an empty vector to accumulate the LensTrace objects at each intersection of ray with a surface in the system.\n\n\n\n\n\ntrace(system::AbstractOpticalSystem{T}, raygenerator::OpticalRayGenerator{T}; printprog = true, test = false)\n\nTraces system with rays generated by raygenerator on a single thread. Optionally the progress can be printed to the REPL. If test is enabled then fresnel reflections are disabled and the power distribution will not be correct. If outpath is specified then the result will be saved to this path.\n\nReturns the detector image of the system.\n\n\n\n\n\n","category":"function"},{"location":"systems/#OpticSim.traceMT-systems","page":"Systems","title":"OpticSim.traceMT","text":"traceMT(system::AbstractOpticalSystem{T}, raygenerator::OpticalRayGenerator{T}; printprog = true, test = false)\n\nTraces system with rays generated by raygenerator using as many threads as possible. Optionally the progress can be printed to the REPL. If test is enabled then fresnel reflections are disabled and the power distribution will not be correct. If outpath is specified then the result will be saved to this path.\n\nReturns the accumulated detector image from all threads.\n\n\n\n\n\n","category":"function"},{"location":"systems/#OpticSim.tracehits-systems","page":"Systems","title":"OpticSim.tracehits","text":"tracehits(system::AbstractOpticalSystem{T}, raygenerator::OpticalRayGenerator{T}; printprog = true, test = false)\n\nTraces system with rays generated by raygenerator on a single thread. Optionally the progress can be printed to the REPL. If test is enabled then fresnel reflections are disabled and the power distribution will not be correct.\n\nReturns a list of LensTraces which hit the detector.\n\n\n\n\n\n","category":"function"},{"location":"systems/#OpticSim.tracehitsMT-systems","page":"Systems","title":"OpticSim.tracehitsMT","text":"tracehitsMT(system::AbstractOpticalSystem{T}, raygenerator::OpticalRayGenerator{T}; printprog = true, test = false)\n\nTraces system with rays generated by raygenerator using as many threads as possible. Optionally the progress can be printed to the REPL. If test is enabled then fresnel reflections are disabled and the power distribution will not be correct.\n\nReturns a list of LensTraces which hit the detector, accumulated from all threads.\n\n\n\n\n\n","category":"function"},{"location":"systems/#OpticSim.LensTrace-systems","page":"Systems","title":"OpticSim.LensTrace","text":"LensTrace{T<:Real,N}\n\nContains an intersection point and the ray segment leading to it from within an optical trace. The ray carries the path length, power, wavelength, number of intersections and source number, all of which are accessible directly on this class too.\n\nHas the following accessor methods:\n\nray(a::LensTrace{T,N}) -> OpticalRay{T,N}\nintersection(a::LensTrace{T,N}) -> Intersection{T,N}\npower(a::LensTrace{T,N}) -> T\nwavelength(a::LensTrace{T,N}) -> T\npathlength(a::LensTrace{T,N}) -> T\npoint(a::LensTrace{T,N}) -> SVector{N,T}\nuv(a::LensTrace{T,N}) -> SVector{2,T}\nsourcenum(a::LensTrace{T,N}) -> Int\nnhits(a::LensTrace{T,N}) -> Int\n\n\n\n\n\n","category":"type"},{"location":"lenses/#Lenses-and-Other-Optical-Components","page":"Lenses","title":"Lenses and Other Optical Components","text":"","category":"section"},{"location":"lenses/#Lenses","page":"Lenses","title":"Lenses","text":"","category":"section"},{"location":"lenses/","page":"Lenses","title":"Lenses","text":"A number of helper functions are provided to make constructing simple lenses easier. Firstly ordinary thick lenses:","category":"page"},{"location":"lenses/#OpticSim.SphericalLens-lenses","page":"Lenses","title":"OpticSim.SphericalLens","text":"SphericalLens(insidematerial, frontvertex, frontradius, backradius, thickness, semidiameter;  lastmaterial = AGFFileReader.Air, nextmaterial = AGFFileReader.Air, frontsurfacereflectance = 0.0, backsurfacereflectance = 0.0, frontdecenter = (0, 0), backdecenter = (0, 0), interfacemode = ReflectOrTransmit)\n\nConstructs a simple cylindrical lens with spherical front and back surfaces. The side walls of the lens are absorbing.\n\n\n\n\n\n","category":"function"},{"location":"lenses/#OpticSim.ConicLens-lenses","page":"Lenses","title":"OpticSim.ConicLens","text":"ConicLens(insidematerial, frontvertex, frontradius, frontconic, backradius, backconic, thickness, semidiameter;  lastmaterial = AGFFileReader.Air, nextmaterial = AGFFileReader.Air, frontsurfacereflectance = 0.0, backsurfacereflectance = 0.0, frontdecenter = (0, 0), backdecenter = (0, 0), interfacemode = ReflectOrTransmit)\n\nConstructs a simple cylindrical lens with front and back surfaces with a radius and conic term. The side walls of the lens are absorbing.\n\n\n\n\n\n","category":"function"},{"location":"lenses/#OpticSim.AsphericLens-lenses","page":"Lenses","title":"OpticSim.AsphericLens","text":"AsphericLens(insidematerial, frontvertex, frontradius, frontconic, frontaspherics, backradius, backconic, backaspherics, thickness, semidiameter;  lastmaterial = AGFFileReader.Air, nextmaterial = AGFFileReader.Air, frontsurfacereflectance = 0.0, backsurfacereflectance = 0.0, frontdecenter = (0, 0), backdecenter = (0, 0), interfacemode = ReflectOrTransmit)\n\nCosntructs a simple cylindrical lens with front and back surfaces with a radius, conic and apsheric terms. The side walls of the lens are absorbing.\n\n\n\n\n\n","category":"function"},{"location":"lenses/#OpticSim.FresnelLens-lenses","page":"Lenses","title":"OpticSim.FresnelLens","text":"Code does not work.\n\nFresnelLens(insidematerial, frontvertex, radius, thickness, semidiameter, groovedepth; conic = 0.0, aspherics = nothing, outsidematerial = AGFFileReader.Air)\n\nCreate a Fresnel lens as a CSG object, can be concave or convex. Groove positions are found iteratively based on groovedepth. For negative radii the vertex on the central surface is at frontvertex, so the total thickness of the lens is thickness + groovedepth. Aspherics currently not supported.\n\n\n\n\n\n","category":"function"},{"location":"lenses/","page":"Lenses","title":"Lenses","text":"As well as idealized lenses:","category":"page"},{"location":"lenses/#OpticSim.ParaxialLens-lenses","page":"Lenses","title":"OpticSim.ParaxialLens","text":"ParaxialLens{T} <: Surface{T}\n\nsurfacenormal is the output direction of the lens. Paraxial lens cannot act as the interface between two materials, hence only a single outside material is specified, by default Air.\n\nCreate with the following functions\n\nParaxialLensEllipse(focaldistance, halfsizeu, halfsizev, surfacenormal, centrepoint; rotationvec = [0.0, 1.0, 0.0], outsidematerial = AGFFileReader.Air, decenteruv = (0.0, 0.0))\nParaxialLensRect(focaldistance, halfsizeu, halfsizev, surfacenormal, centrepoint; rotationvec = [0.0, 1.0, 0.0], outsidematerial = AGFFileReader.Air, decenteruv = (0.0, 0.0))\nParaxialLensHex(focaldistance, side_length, surfacenormal, centrepoint; rotationvec = [0.0, 1.0, 0.0], outsidematerial = AGFFileReader.Air, decenteruv = (0.0, 0.0))\nParaxialLensConvexPoly(focaldistance, local_frame, local_polygon_points, local_center_point; outsidematerial = AGFFileReader.Air)\n\n\n\n\n\n","category":"type"},{"location":"lenses/#Other-Components","page":"Lenses","title":"Other Components","text":"","category":"section"},{"location":"lenses/","page":"Lenses","title":"Lenses","text":"We also have some holographic elements implemented, note that these have not been extensively tested and should not be treated as wholely accurate at this stage.","category":"page"},{"location":"lenses/","page":"Lenses","title":"Lenses","text":"It is relatively simple to extend the existing code to add these kinds of specialized surfaces providing a paired OpticalInterface subclass is also defined. In this case the WrapperSurface can often serve as a suitable base for extension.","category":"page"},{"location":"lenses/#OpticSim.WrapperSurface-lenses","page":"Lenses","title":"OpticSim.WrapperSurface","text":"WrapperSurface{T,S<:Surface{T}} <: Surface{T}\n\nA generic surface type which serves as a basis for extension of Surfaces for custom OpticalInterface subclasses. Essentially just forwards all Surface and ParametricSurface methods to a field of the WrapperSurface named surface. Also provides a generic implementation of surfaceintersection which tests for an intersection with the underlying surface and returns either an EmptyInterval or a half space (never a closed interval).\n\n\n\n\n\n","category":"type"},{"location":"lenses/#OpticSim.ThinGratingSurface-lenses","page":"Lenses","title":"OpticSim.ThinGratingSurface","text":"ThinGratingSurface{T,S} <: WrapperSurface{T,S}\n\nSurface type for use with ThinGratingInterface.\n\nThinGratingSurface(surface::Surface{T}, interface::ThinGratingInterface{T})\n\n\n\n\n\n","category":"type"},{"location":"lenses/#OpticSim.HologramSurface-lenses","page":"Lenses","title":"OpticSim.HologramSurface","text":"HologramSurface{T,S} <: WrapperSurface{T,S}\n\nSurface type for use with HologramInterface.\n\nHologramSurface(surface::Surface{T}, interface::HologramInterface{T})\n\n\n\n\n\n","category":"type"},{"location":"lenses/#Eye-Models","page":"Lenses","title":"Eye Models","text":"","category":"section"},{"location":"lenses/","page":"Lenses","title":"Lenses","text":"Eye models are often very useful in simulation of head mounted display systems. We have two models implemented currently.","category":"page"},{"location":"lenses/#OpticSim.Data.ModelEye-lenses","page":"Lenses","title":"OpticSim.Data.ModelEye","text":"ModelEye(assembly::LensAssembly{T}, nsamples::Int = 17; pupil_radius::T = 3.0, detpixels::Int = 1000, transform::Transform{T} = identitytransform(T))\n\nGeometrically accurate model of the human eye focused at infinity with variable pupil_radius. The eye is added to the provided assembly to create a CSGOpticalSystem with the retina of the eye as the detector.\n\nThe eye can be positioned in the scene using the transform argument and the resolution of the detector specified with detpixels. By default the eye is directed along the positive z-axis with the vertex of the cornea at the origin.\n\nnsamples determines the resolution at which accelerated surfaces within the eye are triangulated.\n\n\n\n\n\n","category":"function"},{"location":"lenses/#OpticSim.Data.ArizonaEye-lenses","page":"Lenses","title":"OpticSim.Data.ArizonaEye","text":"ArizonaEye(::Type{T} = Float64; accommodation::T = 0.0)\n\nThe popular Arizona eye model taken from this definition. The accommodation of the eye can be varied in this model. Returns a DataFrame specifying the prescription of the eye model.\n\n\n\n\n\n","category":"function"},{"location":"transforms_and_vectors/#Transforms-and-Vectors","page":"Transforms and Vectors","title":"Transforms and Vectors","text":"","category":"section"},{"location":"transforms_and_vectors/","page":"Transforms and Vectors","title":"Transforms and Vectors","text":"The following are basic geometric types and utilities, such as vectors and transforms, that are used all acoross the package. Using these types requires, in addition to the using OpticSim statement to also use the OpticSim.Geoemtry module like:","category":"page"},{"location":"transforms_and_vectors/","page":"Transforms and Vectors","title":"Transforms and Vectors","text":"using OpticSim, OpticSim.Geometry","category":"page"},{"location":"transforms_and_vectors/#Vec3","page":"Transforms and Vectors","title":"Vec3","text":"","category":"section"},{"location":"transforms_and_vectors/","page":"Transforms and Vectors","title":"Transforms and Vectors","text":"Representing a 3D vector.","category":"page"},{"location":"transforms_and_vectors/#OpticSim.Geometry.Vec3-transforms_and_vectors","page":"Transforms and Vectors","title":"OpticSim.Geometry.Vec3","text":"Vec3{T} provides an immutable vector of fixed length 3 and type T.\n\nVec3 defines a series of convenience constructors, so you can just type e.g. Vec3(1, 2, 3) or Vec3([1.0, 2.0, 3.0]).  It also supports comprehensions, and the zeros(), ones(), fill(), rand() and randn() functions, such as Vec3(rand(3)).\n\n\n\n\n\n","category":"type"},{"location":"transforms_and_vectors/#OpticSim.Geometry.unitX3-transforms_and_vectors","page":"Transforms and Vectors","title":"OpticSim.Geometry.unitX3","text":"returns the unit vector [1, 0, 0]\n\n\n\n\n\n","category":"function"},{"location":"transforms_and_vectors/#OpticSim.Geometry.unitY3-transforms_and_vectors","page":"Transforms and Vectors","title":"OpticSim.Geometry.unitY3","text":"returns the unit vector [0, 1, 0]\n\n\n\n\n\n","category":"function"},{"location":"transforms_and_vectors/#OpticSim.Geometry.unitZ3-transforms_and_vectors","page":"Transforms and Vectors","title":"OpticSim.Geometry.unitZ3","text":"returns the unit vector [0, 0, 1]\n\n\n\n\n\n","category":"function"},{"location":"transforms_and_vectors/#Vec4","page":"Transforms and Vectors","title":"Vec4","text":"","category":"section"},{"location":"transforms_and_vectors/","page":"Transforms and Vectors","title":"Transforms and Vectors","text":"Representing a 4D vector ","category":"page"},{"location":"transforms_and_vectors/#OpticSim.Geometry.Vec4-transforms_and_vectors","page":"Transforms and Vectors","title":"OpticSim.Geometry.Vec4","text":"Vec4{T} provides an immutable vector of fixed length 4 and type T.\n\nVec4 defines a series of convenience constructors, so you can just type e.g. Vec3(1, 2, 3, 4) or Vec3([1.0, 2.0, 3.0, 4.0]).  It also supports comprehensions, and the zeros(), ones(), fill(), rand() and randn() functions, such as Vec4(rand(4)).\n\n\n\n\n\n","category":"type"},{"location":"transforms_and_vectors/#OpticSim.Geometry.unitX4-transforms_and_vectors","page":"Transforms and Vectors","title":"OpticSim.Geometry.unitX4","text":"returns the unit vector [1, 0, 0, 0]\n\n\n\n\n\n","category":"function"},{"location":"transforms_and_vectors/#OpticSim.Geometry.unitY4-transforms_and_vectors","page":"Transforms and Vectors","title":"OpticSim.Geometry.unitY4","text":"returns the unit vector [0, 1, 0, 0]\n\n\n\n\n\n","category":"function"},{"location":"transforms_and_vectors/#OpticSim.Geometry.unitZ4-transforms_and_vectors","page":"Transforms and Vectors","title":"OpticSim.Geometry.unitZ4","text":"returns the unit vector [0, 0, 1, 0]\n\n\n\n\n\n","category":"function"},{"location":"transforms_and_vectors/#OpticSim.Geometry.unitW4-transforms_and_vectors","page":"Transforms and Vectors","title":"OpticSim.Geometry.unitW4","text":"returns the unit vector [0, 0, 0, 1]\n\n\n\n\n\n","category":"function"},{"location":"transforms_and_vectors/#Transform","page":"Transforms and Vectors","title":"Transform","text":"","category":"section"},{"location":"transforms_and_vectors/","page":"Transforms and Vectors","title":"Transforms and Vectors","text":"Representing a general 3D transform (4x4 matrix). Currently only used as a rigid-body transform. Transforms are used to position surfaces within the CSG tree, position emitters in 3D, etc. ","category":"page"},{"location":"transforms_and_vectors/#OpticSim.Geometry.Transform-transforms_and_vectors","page":"Transforms and Vectors","title":"OpticSim.Geometry.Transform","text":"Transform{S<:Real}\n\nTransform encapsulating rotation, translation and scale in 3D space. Translation happens after rotation.\n\nTransform{S}(θ::T, ϕ::T, ψ::T, x::T, y::T, z::T)\nTransform(rotation::SMatrix{3,3,S}, translation::SVector{3,S})\nTransform(rotation::AbstractArray{S,2}, translation::AbstractArray{S,1})\n\nθ, ϕ and ψ in first constructor are in radians.\n\n\n\n\n\n","category":"type"},{"location":"transforms_and_vectors/#OpticSim.Geometry.identitytransform-transforms_and_vectors","page":"Transforms and Vectors","title":"OpticSim.Geometry.identitytransform","text":"identitytransform([S::Type]) -> Transform{S}\n\nReturns the Transform of type S (default Float64) representing the identity transform.\n\n\n\n\n\n","category":"function"},{"location":"transforms_and_vectors/#OpticSim.Geometry.rotationX-transforms_and_vectors","page":"Transforms and Vectors","title":"OpticSim.Geometry.rotationX","text":"rotationX(angle::T) where {T<:Real} -> Transform\n\nBuilds a rotation matrix for a rotation around the x-axis.  Parameters:     The counter-clockwise angle in radians.\n\n\n\n\n\n","category":"function"},{"location":"transforms_and_vectors/#OpticSim.Geometry.rotationY-transforms_and_vectors","page":"Transforms and Vectors","title":"OpticSim.Geometry.rotationY","text":"rotationY(angle::T) where {T<:Real} -> Transform\n\nBuilds a rotation matrix for a rotation around the y-axis.  Parameters:     The counter-clockwise angle in radians.\n\n\n\n\n\n","category":"function"},{"location":"transforms_and_vectors/#OpticSim.Geometry.rotationZ-transforms_and_vectors","page":"Transforms and Vectors","title":"OpticSim.Geometry.rotationZ","text":"rotationZ(angle::T) where {T<:Real} -> Transform\n\nBuilds a rotation matrix for a rotation around the z-axis.  Parameters:     The counter-clockwise angle in radians.\n\n\n\n\n\n","category":"function"},{"location":"transforms_and_vectors/#OpticSim.Geometry.rotation-transforms_and_vectors","page":"Transforms and Vectors","title":"OpticSim.Geometry.rotation","text":"rotation(t::Transform{T}) where {T<:Real} -> SMatrix{3,3,T}\n\nreturns the rotation part of the transform t - a 3x3 matrix.\n\n\n\n\n\nrotation([S::Type], θ::T, ϕ::T, ψ::T) -> Transform{S}\n\nReturns the Transform of type S (default Float64) representing the rotation by θ, ϕ and ψ around the x, y and z axes respectively in radians.\n\n\n\n\n\n","category":"function"},{"location":"transforms_and_vectors/#OpticSim.Geometry.rotationd-transforms_and_vectors","page":"Transforms and Vectors","title":"OpticSim.Geometry.rotationd","text":"rotationd([S::Type], θ::T, ϕ::T, ψ::T) -> Transform{S}\n\nReturns the Transform of type S (default Float64) representing the rotation by θ, ϕ and ψ around the x, y and z axes respectively in degrees.\n\n\n\n\n\n","category":"function"},{"location":"transforms_and_vectors/#OpticSim.Geometry.rotate-transforms_and_vectors","page":"Transforms and Vectors","title":"OpticSim.Geometry.rotate","text":"rotate(a::Transform{T}, vector::Union{Vec3{T}, SVector{3,T}}) where {T<:Real} -> Vec3{T}\n\napply the rotation part of the transform a to the vector vector - this operation is usually used to rotate direction vectors.\n\n\n\n\n\n","category":"function"},{"location":"transforms_and_vectors/#OpticSim.Geometry.translation-transforms_and_vectors","page":"Transforms and Vectors","title":"OpticSim.Geometry.translation","text":"translation(x::T, y::T, z::T) where {T<:Real}\n\nCreates a translation transform\n\n\n\n\n\ntranslation(x::T, y::T, z::T) where {T<:Real}\n\nCreates a translation transform\n\n\n\n\n\n","category":"function"},{"location":"transforms_and_vectors/#OpticSim.Geometry.rotmat-transforms_and_vectors","page":"Transforms and Vectors","title":"OpticSim.Geometry.rotmat","text":"rotmat([S::Type], θ::T, ϕ::T, ψ::T) -> SMatrix{3,3,S}\n\nReturns the rotation matrix of type S (default Float64) representing the rotation by θ, ϕ and ψ around the x, y and z axes respectively in radians.\n\n\n\n\n\n","category":"function"},{"location":"transforms_and_vectors/#OpticSim.Geometry.rotmatd-transforms_and_vectors","page":"Transforms and Vectors","title":"OpticSim.Geometry.rotmatd","text":"rotmatd([S::Type], θ::T, ϕ::T, ψ::T) -> SMatrix{3,3,S}\n\nReturns the rotation matrix of type S (default Float64) representing the rotation by θ, ϕ and ψ around the x, y and z axes respectively in degrees.\n\n\n\n\n\n","category":"function"},{"location":"transforms_and_vectors/#OpticSim.Geometry.rotmatbetween-transforms_and_vectors","page":"Transforms and Vectors","title":"OpticSim.Geometry.rotmatbetween","text":"rotmatbetween([S::Type], a::SVector{3,T}, b::SVector{3,T}) -> SMatrix{3,3,S}\n\nReturns the rotation matrix of type S (default Float64) representing the rotation between vetors a and b, i.e. rotation(a,b) * a = b.\n\n\n\n\n\n","category":"function"},{"location":"csg/#CSG","page":"CSG","title":"CSG","text":"","category":"section"},{"location":"csg/#CSG-Operations","page":"CSG","title":"CSG Operations","text":"","category":"section"},{"location":"csg/","page":"CSG","title":"CSG","text":"OpticSim represents objects as boolean combinations of halfspaces, a method of constructing solid objects known as Constructive Solid Geometry (CSG). A halfspace is a surface which divides 3D space into 3 regions: inside the halfspace,outside the halfspace, on the surface dividing inside from outside. ","category":"page"},{"location":"csg/","page":"CSG","title":"CSG","text":"A simple example of a halfspace is an infinite oriented plane, where oriented means we have defined a direction for the normal to the plane surface. Another simple example is a sphere, or a cylinder.","category":"page"},{"location":"csg/","page":"CSG","title":"CSG","text":"If the halfspaces have mathematically well difined inside and outside functions then except for edge cases, which are unlikely to occur in an optics setting, then any boolean combination of halfspaces will also have a well defined inside and outside.","category":"page"},{"location":"csg/","page":"CSG","title":"CSG","text":"You can define optical elements by combining the basic halfspace types defined for you in OpticSim:","category":"page"},{"location":"csg/","page":"CSG","title":"CSG","text":"sphere\ninfinite cylinder\nplane\nprism\nspherical cap","category":"page"},{"location":"csg/","page":"CSG","title":"CSG","text":"Many of the surfaces already defined for you in OpticSim, such as sphere, prism,plane, cylinder, describe well defined solid objects, i.e., there is a mathematically defined inside and outside. ","category":"page"},{"location":"csg/","page":"CSG","title":"CSG","text":"Unfortunately, many of the surfaces common in optics do not by themselves define solid objects. None of the parametric surfaces, which includes all the optical asphere types, define solid objects. ","category":"page"},{"location":"csg/","page":"CSG","title":"CSG","text":"Parametric surfaces do have a positive and negative side though determined by the direction of the surface normal. You can create a well defined solid object by taking the intersection of a cylinder with an asphere.","category":"page"},{"location":"csg/","page":"CSG","title":"CSG","text":"There are three binary csg operations which can construct extremely complex objects from very simple primitives: union (cup), intersection (cap) and subtraction (i.e. difference).","category":"page"},{"location":"csg/","page":"CSG","title":"CSG","text":"This diagram shows the basic idea: (Image: CSG Tree visualization)","category":"page"},{"location":"csg/","page":"CSG","title":"CSG","text":"The code for this in our system would look this this:","category":"page"},{"location":"csg/","page":"CSG","title":"CSG","text":"using OpticSim # hide\ncyl = Cylinder(0.7)\ncyl_cross = cyl ∪ leaf(cyl, Geometry.rotationd(90, 0, 0)) ∪ leaf(cyl, Geometry.rotationd(0, 90, 0))\n\ncube = Cuboid(1.0, 1.0, 1.0)\nsph = Sphere(1.3)\nrounded_cube = cube ∩ sph\n\nresult = rounded_cube - cyl_cross","category":"page"},{"location":"csg/#OpticSim.leaf-csg","page":"CSG","title":"OpticSim.leaf","text":"leaf(surf::ParametricSurface{T}, transform::Transform{T} = identitytransform(T)) -> CSGGenerator{T}\n\nCreate a leaf node from a parametric surface with a given transform.\n\n\n\n\n\n","category":"function"},{"location":"csg/#Base.:∪-csg","page":"CSG","title":"Base.:∪","text":"∪(a::Union{CSGGenerator{T},ParametricSurface{T}}, b::Union{CSGGenerator{T},ParametricSurface{T}}) where {T<:Real}\n\nCreate a binary node in the CSG tree representing a union between a and b.\n\n(Image: Union Image)\n\n\n\n\n\n","category":"function"},{"location":"csg/#Base.:∩-csg","page":"CSG","title":"Base.:∩","text":"∩(a::Union{CSGGenerator{T},ParametricSurface{T}}, b::Union{CSGGenerator{T},ParametricSurface{T}}) where {T<:Real}\n\nCreate a binary node in the CSG tree representing an intersection between a and b.\n\n(Image: Intersect Image)\n\n\n\n\n\n","category":"function"},{"location":"csg/#Base.:--csg","page":"CSG","title":"Base.:-","text":"-(a::Union{CSGGenerator{T},ParametricSurface{T}}, b::Union{CSGGenerator{T},ParametricSurface{T}}) where {T<:Real}\n\nCreate a binary node in the CSG tree representing the difference of a and b, essentially a - b.\n\n(Image: Difference Image)\n\n\n\n\n\n","category":"function"},{"location":"csg/#Pre-made-CSG-Shapes","page":"CSG","title":"Pre-made CSG Shapes","text":"","category":"section"},{"location":"csg/","page":"CSG","title":"CSG","text":"There are also some shortcut methods available to create common CSG objects more easily:","category":"page"},{"location":"csg/#OpticSim.BoundedCylinder-csg","page":"CSG","title":"OpticSim.BoundedCylinder","text":"BoundedCylinder(radius::T, height::T; interface::NullOrFresnel{T} = nullinterface(T)) -> CSGGenerator{T}\n\nCreate a cylinder with planar caps on both ends centered at (0, 0, 0) with axis (0, 0, 1).\n\n\n\n\n\n","category":"function"},{"location":"csg/#OpticSim.Cuboid-csg","page":"CSG","title":"OpticSim.Cuboid","text":"Cuboid(halfsizex::T, halfsizey::T, halfsizez::T; interface::NullOrFresnel{T} = nullinterface(T)) -> CSGGenerator{T}\n\nCreate a cuboid centered at (0, 0, 0).\n\n\n\n\n\n","category":"function"},{"location":"csg/#OpticSim.HexagonalPrism-csg","page":"CSG","title":"OpticSim.HexagonalPrism","text":"HexagonalPrism(side_length::T, visheight::T = 2.0; interface::NullOrFresnel{T} = nullinterface(T)) -> CSGGenerator{T}\n\nCreate an infinitely tall hexagonal prism with axis (0, 0, 1), the longer hexagon diameter is along the x axis. For visualization visheight is used, note that this does not fully represent the surface.\n\n\n\n\n\n","category":"function"},{"location":"csg/#OpticSim.RectangularPrism-csg","page":"CSG","title":"OpticSim.RectangularPrism","text":"RectangularPrism(halfsizex::T, halfsizey::T, visheight::T=2.0; interface::NullOrFresnel{T} = nullinterface(T)) -> CSGGenerator{T}\n\nCreate an infinitely tall rectangular prism with axis (0, 0, 1). For visualization visheight is used, note that this does not fully represent the surface.\n\n\n\n\n\n","category":"function"},{"location":"csg/#OpticSim.TriangularPrism-csg","page":"CSG","title":"OpticSim.TriangularPrism","text":"TriangularPrism(side_length::T, visheight::T = 2.0; interface::NullOrFresnel{T} = nullinterface(T)) -> CSGGenerator{T}\n\nCreate an infinitely tall triangular prism with axis (0, 0, 1). For visualization visheight is used, note that this does not fully represent the surface.\n\n\n\n\n\n","category":"function"},{"location":"csg/#OpticSim.Spider-csg","page":"CSG","title":"OpticSim.Spider","text":"Spider(narms::Int, armwidth::T, radius::T, origin::SVector{3,T} = SVector{3,T}(0.0, 0.0, 0.0), normal::SVector{3,T} = SVector{3,T}(0.0, 0.0, 1.0)) -> Vector{Rectangle{T}}\n\nCreates a 'spider' obscuration with narms rectangular arms evenly spaced around a circle defined by origin and normal. Each arm is a rectangle armwidth×radius.\n\ne.g. for 3 and 4 arms we get:\n\n   |         _|_\n  / \\         |\n\n\n\n\n\n","category":"function"},{"location":"csg/#CSG-Types","page":"CSG","title":"CSG Types","text":"","category":"section"},{"location":"csg/","page":"CSG","title":"CSG","text":"These are the types of the primary CSG elements, i.e. the nodes in the CSG tree.","category":"page"},{"location":"csg/#OpticSim.CSGTree-csg","page":"CSG","title":"OpticSim.CSGTree","text":"Abstract type representing any evaluated CSG structure.\n\n\n\n\n\n","category":"type"},{"location":"csg/#OpticSim.CSGGenerator-csg","page":"CSG","title":"OpticSim.CSGGenerator","text":"CSGGenerator{T<:Real}\n\nThis is the type you should use when making CSG objects. This type allows for the construction of CSGTree objects with different transforms. When the generator is evaluated, all transforms are propagated down to the LeafNodes and stored there.\n\nExample\n\na = Cylinder(1.0,1.0)\nb = Plane([0.0,0.0,1.0], [0.0,0.0,0.0])\ngenerator = a ∩ b\n# now make a csg object that can be ray traced\ncsgobj = generator(Transform(1.0,1.0,2.0))\n\n\n\n\n\n","category":"type"},{"location":"csg/#OpticSim.ComplementNode-csg","page":"CSG","title":"OpticSim.ComplementNode","text":"ComplementNode{T,C<:CSGTree{T}} <: CSGTree{T}\n\nAn evaluated complement node within the CSG tree, must be the second child of a IntersectionNode forming a subtraction.\n\n\n\n\n\n","category":"type"},{"location":"csg/#OpticSim.UnionNode-csg","page":"CSG","title":"OpticSim.UnionNode","text":"UnionNode{T,L<:CSGTree{T},R<:CSGTree{T}} <: CSGTree{T}\n\nAn evaluated union node within the CSG tree.\n\n\n\n\n\n","category":"type"},{"location":"csg/#OpticSim.IntersectionNode-csg","page":"CSG","title":"OpticSim.IntersectionNode","text":"IntersectionNode{T,L<:CSGTree{T},R<:CSGTree{T}} <: CSGTree{T}\n\nAn evaluated intersection node within the CSG tree.\n\n\n\n\n\n","category":"type"},{"location":"csg/#OpticSim.LeafNode-csg","page":"CSG","title":"OpticSim.LeafNode","text":"LeafNode{T,S<:ParametricSurface{T}} <: CSGTree{T}\n\nAn evaluated leaf node in the CSG tree, geometry attribute which contains a ParametricSurface of type S. The leaf node also has a transform associated which is the composition of all nodes above it in the tree. As such, transforming points from the geometry using this transform puts them in world space, and transforming rays by the inverse transform puts them in object space.\n\n\n\n\n\n","category":"type"},{"location":"csg/#Additional-Functions-and-Types","page":"CSG","title":"Additional Functions and Types","text":"","category":"section"},{"location":"csg/","page":"CSG","title":"CSG","text":"These are the internal types and functions used for geometric/CSG operations.","category":"page"},{"location":"csg/#Functions","page":"CSG","title":"Functions","text":"","category":"section"},{"location":"csg/#OpticSim.surfaceintersection-Union{Tuple{N}, Tuple{T}, Tuple{CSGTree{T}, AbstractRay{T, N}}} where {T<:Real, N}-csg","page":"CSG","title":"OpticSim.surfaceintersection","text":"surfaceintersection(obj::CSGTree{T}, r::AbstractRay{T,N})\n\nCalculates the intersection of r with CSG object, obj.\n\nReturns an EmptyInterval if there is no intersection, an Interval if there is one or two intersections and a DisjointUnion if there are more than two intersections.\n\nThe ray is intersected with the LeafNodes that make up the CSG object and the resulting Intervals and DisjointUnions are composed with the same boolean operations to give a final result. The ray is transformed by the inverse of the transform associated with the leaf node to put it in object space for that node before the intersection is carried out, typically this object space is centered at the origin, but may differ for each primitive.\n\nSome intersections are culled without actually evaluating them by first checking if the ray intersects the BoundingBox of each node in the CSGTree, this can substantially improve performance in some cases.\n\n\n\n\n\n","category":"method"},{"location":"csg/#OpticSim.inside-Union{Tuple{T}, Tuple{CSGTree{T}, T, T, T}} where T<:Real-csg","page":"CSG","title":"OpticSim.inside","text":"inside(obj::CSGTree{T}, point::SVector{3,T}) -> Bool\ninside(obj::CSGTree{T}, x::T, y::T, z::T) -> Bool\n\nTests whether a 3D point in world space is inside obj.\n\n\n\n\n\n","category":"method"},{"location":"csg/#OpticSim.onsurface-Union{Tuple{T}, Tuple{CSGTree{T}, T, T, T}} where T<:Real-csg","page":"CSG","title":"OpticSim.onsurface","text":"onsurface(obj::CSGTree{T}, point::SVector{3,T}) -> Bool\nonsurface(obj::CSGTree{T}, x::T, y::T, z::T) -> Bool\n\nTests whether a 3D point in world space is on the surface (i.e. shell) of obj.\n\n\n\n\n\n","category":"method"},{"location":"csg/#Intervals","page":"CSG","title":"Intervals","text":"","category":"section"},{"location":"csg/#OpticSim.Interval-csg","page":"CSG","title":"OpticSim.Interval","text":"Interval{T} <: AbstractRayInterval{T}\n\nDatatype representing an interval between two IntervalPoints on a ray.\n\nThe lower element can either be RayOrigin or an Intersection. The upper element can either be an Intersection or Infinity.\n\npositivehalfspace(int::Intersection) -> Interval with lower = int, upper = Infinity\nrayorigininterval(int::Intersection) -> Interval with lower = RayOrigin, upper = int\nInterval(low, high)\n\nHas the following accessor methods:\n\nlower(a::Interval{T}) -> Union{RayOrigin{T},Intersection{T,3}}\nupper(a::Interval{T}) -> Union{Intersection{T,3},Infinity{T}}\n\n\n\n\n\n","category":"type"},{"location":"csg/#OpticSim.EmptyInterval-csg","page":"CSG","title":"OpticSim.EmptyInterval","text":"EmptyInterval{T} <: AbstractRayInterval{T}\n\nAn interval with no Intersections which is also not infinite.\n\nEmptyInterval(T = Float64)\nEmptyInterval{T}()\n\n\n\n\n\n","category":"type"},{"location":"csg/#OpticSim.DisjointUnion-csg","page":"CSG","title":"OpticSim.DisjointUnion","text":"Datatype representing an ordered series of disjoint intervals on a ray. An arbitrary array of Intervals can be input to the constructor and they will automatically be processed into a valid DisjointUnion (or a single Interval if appropriate).\n\nDisjointUnion(intervals::AbstractVector{Interval{R}})\n\n\n\n\n\n","category":"type"},{"location":"csg/#OpticSim.isemptyinterval-csg","page":"CSG","title":"OpticSim.isemptyinterval","text":"isemptyinterval(a) -> Bool\n\nReturns true if a is an EmptyInterval. In performance critical contexts use a isa EmptyInterval{T}.\n\n\n\n\n\n","category":"function"},{"location":"csg/#OpticSim.ispositivehalfspace-csg","page":"CSG","title":"OpticSim.ispositivehalfspace","text":"ispositivehalfspace(a) -> Bool\n\nReturns true if upper(a) is Infinity. In performance critical contexts check directly i.e. upper(a) isa Infinity{T}.\n\n\n\n\n\n","category":"function"},{"location":"csg/#OpticSim.israyorigininterval-csg","page":"CSG","title":"OpticSim.israyorigininterval","text":"israyorigininterval(a) -> Bool\n\nReturns true if lower(a) is RayOrigin. In performance critical contexts check directly i.e. lower(a) isa RayOrigin{T}.\n\n\n\n\n\n","category":"function"},{"location":"csg/#OpticSim.halfspaceintersection-csg","page":"CSG","title":"OpticSim.halfspaceintersection","text":"halfspaceintersection(a::Interval{T}) -> Intersection{T,3}\n\nReturns the Intersection from a half space Interval, throws an error if not a half space.\n\n\n\n\n\n","category":"function"},{"location":"csg/#OpticSim.closestintersection-csg","page":"CSG","title":"OpticSim.closestintersection","text":"closestintersection(a::Union{EmptyInterval{T},Interval{T},DisjointUnion{T}}, ignorenull::Bool = true) -> Union{Nothing,Intersection{T,3}}\n\nReturns the closest Intersection from an Interval or DisjointUnion. Ignores intersection with null interfaces if ignorenull is true. Will return nothing if there is no valid intersection.\n\n\n\n\n\n","category":"function"},{"location":"csg/#OpticSim.IntervalPool-csg","page":"CSG","title":"OpticSim.IntervalPool","text":"To prevent allocations we have a manually managed pool of arrays of Intervals which are used to store values during execution. The memory is kept allocated and reused across runs of functions like trace.\n\nthreadedintervalpool is a global threadsafe pool which is accessed through the functions:\n\nnewinintervalpool!(::Type{T} = Float64, tid::Int = Threads.threadid()) -> Vector{Interval{T}}\nindexednewinintervalpool!(::Type{T} = Float64, tid::Int = Threads.threadid()) -> Tuple{Int,Vector{Interval{T}}}\nemptyintervalpool!(::Type{T} = Float64, tid::Int = Threads.threadid())\ngetfromintervalpool([::Type{T} = Float64], id::Int, tid::Int = Threads.threadid()) -> Vector{Interval{T}}\n\n\n\n\n\n","category":"type"},{"location":"csg/#Intersections","page":"CSG","title":"Intersections","text":"","category":"section"},{"location":"csg/#OpticSim.IntervalPoint-csg","page":"CSG","title":"OpticSim.IntervalPoint","text":"Each Interval consists of two IntervalPoints, one of RayOrigin, Intersection or Infinity.\n\n\n\n\n\n","category":"type"},{"location":"csg/#OpticSim.RayOrigin-csg","page":"CSG","title":"OpticSim.RayOrigin","text":"RayOrigin{T} <: IntervalPoint{T}\n\nPoint representing 0 within an Interval, i.e. the start of the ray.\n\nRayOrigin(T = Float64)\nRayOrigin{T}()\n\n\n\n\n\n","category":"type"},{"location":"csg/#OpticSim.Infinity-csg","page":"CSG","title":"OpticSim.Infinity","text":"Infinity{T} <: IntervalPoint{T}\n\nPoint representing ∞ within an Interval.\n\nInfinity(T = Float64)\nInfinity{T}()\n\n\n\n\n\n","category":"type"},{"location":"csg/#OpticSim.Intersection-csg","page":"CSG","title":"OpticSim.Intersection","text":"Intersection{T,N} <: IntervalPoint{T}\n\nRepresents the point at which an Ray hits a Surface. This consists of the distance along the ray, the intersection point in world space, the normal in world space, the UV on the surface and the OpticalInterface hit.\n\nHas the following accessor methods:\n\npoint(a::Intersection{T,N}) -> SVector{N,T}\nnormal(a::Intersection{T,N}) -> SVector{N,T}\nuv(a::Intersection{T,N}) -> SVector{2,T}\nu(a::Intersection{T,N}) -> T\nv(a::Intersection{T,N}) -> T\nα(a::Intersection{T,N}) -> T\ninterface(a::Intersection{T,N}) -> OpticalInterface{T}\nflippednormal(a::Intersection{T,N}) -> Bool\n\n\n\n\n\n","category":"type"},{"location":"csg/#OpticSim.isinfinity-csg","page":"CSG","title":"OpticSim.isinfinity","text":"isinfinity(a) -> Bool\n\nReturns true if a is Infinity. In performance critical contexts use a isa Infinity{T}.\n\n\n\n\n\n","category":"function"},{"location":"csg/#OpticSim.israyorigin-csg","page":"CSG","title":"OpticSim.israyorigin","text":"israyorigin(a) -> Bool\n\nReturns true if a is RayOrigin. In performance critical contexts use a isa RayOrigin{T}.\n\n\n\n\n\n","category":"function"},{"location":"primitives/#Primitives","page":"Primitives","title":"Primitives","text":"","category":"section"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":"All geometry is built up from a small(ish) number of primitives and a number of constructive solid geometry (CSG) operations (see CSG). Primitives are split into two types, Surfaces and ParametricSurfaces, the latter being a subset of the former. Surfaces are standalone surfaces which cannot be used in CSG operations, e.g. an aperture or rectangle. ParametricSurfaces are valid csg objects and can be composed into very complex structures.","category":"page"},{"location":"primitives/#Surfaces","page":"Primitives","title":"Surfaces","text":"","category":"section"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":"A surface can be any surface in 3D space, it can be bounded and not create a half-space (i.e. not partition space into inside and outside).","category":"page"},{"location":"primitives/#OpticSim.Surface-primitives","page":"Primitives","title":"OpticSim.Surface","text":"Surface{T<:Real}\n\nT is the number type used to represent the surface, e.g., Float64. Basic Surfaces are not valid CSG objects, they function only in a stand-alone capacity.\n\nMust implement the following:\n\nsurfaceintersection(surface::Surface{T}, ray::AbstractRay{T,3}) -> Union{EmptyInterval{T},Interval{T}}\nnormal(surface::Surface{T}) -> SVector{3,T}\ninterface(surface::Surface{T}) -> OpticalInterface{T}\nmakemesh(surface::Surface{T}) -> TriangleMesh{T}\n\nIn a conventional ray tracer the surface intersection function would only return the first surface the ray intersects. Because our ray tracer does CSG operations the surface intersection function intersects the ray with all leaf surfaces which are part of the CSG tree. \n\nEach leaf surface returns one or more 1D intervals along the ray. These intervals contain the part of the ray which is inside the surface. The intervals computed at the leaves are propagated upward through the CSG tree and the CSG operations of union, intersection, and difference are applied to generate new intervals which are themselves propagated upward.\n\nThe result is a union of 1D intervals, which may be disjoint, a single interval, or empty. The union of intervals represents the parts of the ray which are inside the CSG object.\n\nInside is well defined for halfspaces such as cylinders and spheres which divide space into two parts, but not for Bezier or NURBS patches which generally do not enclose a volume.  For surfaces which are not halfspaces the notion of inside is defined locally by computing the angle between the incoming ray and the normal of the surface at the point of intersection. All surfaces must be defined so that the normal points to the outside of the surface. \n\nA negative dot product between the incoming ray and the normal indicates the ray is coming from the outside of the surface and heading toward the inside. A positive dot product indicates the ray is coming from the inside of the surface and heading toward the outside.\n\nIntervals are defined along the ray which is being intersected with the surface, so they are one dimensional. For example, assume we have a ray with origin o on the outside of a plane and an intersection with the plane at point int = o + td where t is a scalar and d is the unit direction of the ray. The inside interval will be (Intersection(t),Infinity). This interval begins at the intersection point on the plane and continues to positive infinity. The Intersection struct stores both the parametric value t and the 3D point of intersection to make various operations more efficient. But the interval operations only depend on the parametric value t.\n\nIf the origin o is on the inside of the plane then the inside interval will be (RayOrigin,Intersection(t)). Only the part of the ray from the ray origin to the intersection point is inside the plane. \n\nIt is the programmer's responsibility to return Interval results from surfaceintersection that maintain these properties.\n\nThe following must be implemented only if the surface is being used as a detector\n\nuv(surface::Surface{T}, p::SVector{3,T}) -> SVector{2,T}\nuvtopix(surface::Surface{T}, uv::SVector{2,T}, imsize::Tuple{Int,Int}) -> Tuple{Int,Int}\nonsurface(surface::Surface{T}, p::SVector{3,T}) -> Bool\n\n\n\n\n\n","category":"type"},{"location":"primitives/#Basic-Shapes","page":"Primitives","title":"Basic Shapes","text":"","category":"section"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":"These are the simple shapes with are provided already, they act only as standalone objects and cannot be used in CSG objects. Adding a new Surface is easy, the new structure must simply follow the interface defined above.","category":"page"},{"location":"primitives/#OpticSim.Ellipse-primitives","page":"Primitives","title":"OpticSim.Ellipse","text":"Ellipse{T} <: Surface{T}\n\nElliptical surface, not a valid CSG object. The rotation of the rectangle around its normal is defined by rotationvec. rotationvec×surfacenormal is taken as the vector along the u axis.\n\nCan be used as a detector in AbstractOpticalSystems.\n\nEllipse(halfsizeu::T, halfsizev::T, [surfacenormal::SVector{3,T}, centrepoint::SVector{3,T}]; interface::NullOrFresnel{T} = nullinterface(T))\n\nThe minimal case returns an ellipse centered at the origin with surfacenormal = [0, 0, 1].\n\n\n\n\n\n","category":"type"},{"location":"primitives/#OpticSim.Circle-primitives","page":"Primitives","title":"OpticSim.Circle","text":"Circle(radius, [surfacenormal, centrepoint]; interface = nullinterface(T))\n\nShortcut method to create a circle. The minimal case returns a circle centered at the origin with normal = [0, 0, 1].\n\n\n\n\n\n","category":"function"},{"location":"primitives/#OpticSim.Rectangle-primitives","page":"Primitives","title":"OpticSim.Rectangle","text":"Rectangle{T} <: Surface{T}\n\nRectangular surface, not a valid CSG object. The rotation of the rectangle around its normal is defined by rotationvec. rotationvec×surfacenormal is taken as the vector along the u axis.\n\nCan be used as a detector in AbstractOpticalSystems.\n\nRectangle(halfsizeu::T, halfsizev::T, [surfacenormal::SVector{3,T}, centrepoint::SVector{3,T}]; rotationvec::SVector{3,T} = [0.0, 1.0, 0.0], interface::NullOrFresnel{T} = nullinterface(T))\n\nThe minimal case returns a rectangle centered at the origin with surfacenormal = [0, 0, 1].\n\n\n\n\n\n","category":"type"},{"location":"primitives/#OpticSim.Hexagon-primitives","page":"Primitives","title":"OpticSim.Hexagon","text":"Hexagon{T} <: Surface{T}\n\nHexagonal surface, not a valid CSG object. The rotation of the hexagon around its normal is defined by rotationvec. rotationvec×surfacenormal is taken as the vector along the u axis.\n\nHexagon(side_length::T, [surfacenormal::SVector{3,T}, centrepoint::SVector{3,T}]; rotationvec::SVector{3,T} = [0.0, 1.0, 0.0], interface::NullOrFresnel{T} = nullinterface(T))\n\nThe minimal case returns a rectangle centered at the origin with surfacenormal = [0, 0, 1].\n\n\n\n\n\n","category":"type"},{"location":"primitives/#OpticSim.Triangle-primitives","page":"Primitives","title":"OpticSim.Triangle","text":"Triangle{T} <: Surface{T}\n\nTriangular surface, not a valid CSG object. Primarily used as a component part of TriangleMesh or to enable intersection of AcceleratedParametricSurfaces. Can never be used directly as an optical surface as it doesn't have an OpticalInterface.\n\nTriangle(v1::SVector{3,T}, v2::SVector{3,T}, v3::SVector{3,T}, [uv1::SVector{2,T}, uv2::SVector{2,T}, uv3::SVector{2,T}])\n\n\n\n\n\n","category":"type"},{"location":"primitives/#OpticSim.TriangleMesh-primitives","page":"Primitives","title":"OpticSim.TriangleMesh","text":"TriangleMesh{T} <: Surface{T}\n\nAn array of Triangles forming a mesh. Used for visualization purposes only.\n\nTriangleMesh(tris::Vector{Triangle{T}})\n\n\n\n\n\n","category":"type"},{"location":"primitives/#Stops","page":"Primitives","title":"Stops","text":"","category":"section"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":"A number of simple occlusive apertures are provided as constructing such objects using CSG can be inefficient and error-prone.","category":"page"},{"location":"primitives/#OpticSim.InfiniteStop-primitives","page":"Primitives","title":"OpticSim.InfiniteStop","text":"InfiniteStop{T,P<:StopShape} <: Surface{T}\n\nStop surface with infinite extent (outside of the aperture). P refers to the shape of the aperture.\n\n\n\n\n\n","category":"type"},{"location":"primitives/#OpticSim.FiniteStop-primitives","page":"Primitives","title":"OpticSim.FiniteStop","text":"FiniteStop{T,P<:StopShape,Q<:StopShape} <: Surface{T}\n\nStop surface with finite extent. P refers to the shape of the aperture and Q represents the shape of the bounds of the stop surface.\n\n\n\n\n\n","category":"type"},{"location":"primitives/#OpticSim.RectangularAperture-primitives","page":"Primitives","title":"OpticSim.RectangularAperture","text":"RectangularAperture(aphalfsizeu::T, aphalfsizev::T, surfacenormal::SVector{3,T}, centrepoint::SVector{3,T}; rotationvec::SVector{3,T} = [0.0, 1.0, 0.0])\n\nCreates a rectangular aperture in a plane i.e. InfiniteStop{T,RectangularStopShape}. The rotation of the rectangle around its normal is defined by rotationvec. rotationvec×surfacenormal is taken as the vector along the u axis.\n\n\n\n\n\nRectangularAperture(innerhalfsizeu::T, innerhalfsizev::T, outerhalfsizeu::T, outerhalfsizev::T, surfacenormal::SVector{3,T}, centrepoint::SVector{3,T}; rotationvec::SVector{3,T} = [0.0, 1.0, 0.0])\n\nCreates a rectangular aperture in a rectangle i.e. FiniteStop{T,RectangularStopShape,RectangularStopShape}. The rotation of the rectangle around its normal is defined by rotationvec. rotationvec×surfacenormal is taken as the vector along the u axis.\n\n\n\n\n\n","category":"function"},{"location":"primitives/#OpticSim.CircularAperture-primitives","page":"Primitives","title":"OpticSim.CircularAperture","text":"CircularAperture(radius::T, surfacenormal::SVector{3,T}, centrepoint::SVector{3,T})\n\nCreates a circular aperture in a plane i.e. InfiniteStop{T,CircularStopShape}.\n\n\n\n\n\nCircularAperture(radius::T, outerhalfsizeu::T, outerhalfsizev::T, surfacenormal::SVector{3,T}, centrepoint::SVector{3,T}; rotationvec::SVector{3,T} = [0.0, 1.0, 0.0])\n\nCreates a circular aperture in a rectangle i.e. FiniteStop{T,CircularStopShape,RectangularStopShape}. The rotation of the rectangle around its normal is defined by rotationvec. rotationvec×surfacenormal is taken as the vector along the u axis.\n\n\n\n\n\n","category":"function"},{"location":"primitives/#OpticSim.Annulus-primitives","page":"Primitives","title":"OpticSim.Annulus","text":"Annulus(innerradius::T, outerradius::T, surfacenormal::SVector{3,T}, centrepoint::SVector{3,T})\n\nCreates a circular aperture in a circle i.e. FiniteStop{T,CircularStopShape,CircularStopShape}.\n\n\n\n\n\n","category":"function"},{"location":"primitives/#Parametric-Surfaces","page":"Primitives","title":"Parametric Surfaces","text":"","category":"section"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":"A parametric surface must partition space into two valid half-spaces, i.e. inside and outside. The surface must also be parameterized by two variables, nominally u and v. Typically these surfaces cannot be intersected with a ray analytically and so must be triangulated and an iterative solution found.","category":"page"},{"location":"primitives/#OpticSim.ParametricSurface-primitives","page":"Primitives","title":"OpticSim.ParametricSurface","text":"ParametricSurface{T,N} <: Surface{T}\n\nT is the number type used to represent the surface, e.g., Float64. N is the dimension of the space the surface is embedded in. ParametricSurfaces are valid CSG objects, in some cases (where analytic intersection isn't possible) they must be wrapped in an AcceleratedParametricSurface for use.\n\nMust implement the following:\n\nuv(surface::ParametricSurface{T,N}, p::SVector{N,T}) -> SVector{2,T}\nuvrange(surface::ParametricSurface{T,N}) -> Tuple{Tuple{T,T},Tuple{T,T}}\npoint(surface::ParametricSurface{T,N}, u::T, v::T) -> SVector{N,T}\npartials(surface::ParametricSurface{T,N}, u::T, v::T) -> Tuple{SVector{N,T}, SVector{N,T}}\nnormal(surface::ParametricSurface{T,N}, u::T, v::T) -> SVector{N,T}\ninside(surface::ParametricSurface{T,N}, p: :SVector{N,T}) -> Bool\nonsurface(surface::ParametricSurface{T,N}, p::SVector{N,T}) -> Bool\nsurfaceintersection(surface::ParametricSurface{T,N}, AbstractRay::Ray{T,N}) -> Union{EmptyInterval{T},Interval{T},DisjointUnion{T}}\ninterface(surface::ParametricSurface{T,N}) -> OpticalInterface{T}\n\n\n\n\n\n","category":"type"},{"location":"primitives/#OpticSim.AcceleratedParametricSurface-primitives","page":"Primitives","title":"OpticSim.AcceleratedParametricSurface","text":"AcceleratedParametricSurface{T,N,S} <: ParametricSurface{T,N}\n\nWrapper class for ParametricSurfaces where analytical intersection isn't feasible (e.g. ZernikeSurface, ChebyshevSurface). The surface is instead triangulated and an iterative (newton raphson) process carried out to determine precise ray intersection points. S is the type of the ParametricSurface being wrapped.\n\nAcceleratedParametricSurface(surf::ParametricSurface{T,N}, numsamples::Int = 17; interface::NullOrFresnel{T} = nullinterface(T))\n\n\n\n\n\n","category":"type"},{"location":"primitives/#Parametric-Surface-Types","page":"Primitives","title":"Parametric Surface Types","text":"","category":"section"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":"These are the available types of parametric surfaces which are already implemented, all of which can be used in the creation of CSG objects. New ParametricSurfaces can be added with relative ease providing they follow the interface defined above.","category":"page"},{"location":"primitives/#OpticSim.Cylinder-primitives","page":"Primitives","title":"OpticSim.Cylinder","text":"Cylinder{T,N} <: ParametricSurface{T,N}\n\nCylinder of infinite height centered at the origin, oriented along the z-axis. visheight is used for visualization purposes only, note that this does not fully represent the surface.\n\nCylinder(radius::T, visheight::T = 2.0; interface::NullOrFresnel{T} = nullinterface(T))\n\n\n\n\n\n","category":"type"},{"location":"primitives/#OpticSim.Plane-primitives","page":"Primitives","title":"OpticSim.Plane","text":"Plane{T,N} <: ParametricSurface{T,N}\n\nInfinite planar surface where the positive normal side is outside the surface.\n\nBy default this will not create any geometry for visualization, the optional vishalfsizeu and vishalfsizev arguments can be used to draw the plane as a rectangle for visualization note that this does not fully represent the surface. In this case, the rotation of the rectangle around the normal to the plane is defined by visvec - surfacenormal×visvec is taken as the vector along the u axis.\n\nPlane(surfacenormal::SVector{N,T}, pointonplane::SVector{N,T}; interface::NullOrFresnel{T} = nullinterface(T), vishalfsizeu::T = 0.0, vishalfsizev::T = 0.0, visvec::SVector{N,T} = [0.0, 1.0, 0.0])\nPlane(nx::T, ny::T, nz::T, x::T, y::T, z::T; interface::NullOrFresnel{T} = nullinterface(T), vishalfsizeu::T = 0.0, vishalfsizev::T = 0.0, visvec::SVector{N,T} = [0.0, 1.0, 0.0])\n\n\n\n\n\n","category":"type"},{"location":"primitives/#OpticSim.Sphere-primitives","page":"Primitives","title":"OpticSim.Sphere","text":"Sphere{T,N} <: ParametricSurface{T,N}\n\nSpherical surface centered at the origin.\n\nSphere(radius::T = 1.0; interface::NullOrFresnel{T} = nullinterface(T))\n\n\n\n\n\n","category":"type"},{"location":"primitives/#OpticSim.SphericalCap-primitives","page":"Primitives","title":"OpticSim.SphericalCap","text":"SphericalCap{T} <: ParametricSurface{T}\n\nSpherical cap surface, creates a half-space which is essentially the subtraction of a sphere from an infinite plane. Only the spherical cap itself is visualized, not the plane. The positive normal side is outside the surface.\n\nCan be used as a detector in AbstractOpticalSystems.\n\nSphericalCap(radius::T, ϕmax::T, [surfacenormal::SVector{3,T}, centrepoint::SVector{3,T}]; interface::NullOrFresnel{T} = nullinterface(T))\n\nThe minimal case returns a spherical cap centered at the origin with surfacenormal = [0, 0, 1].\n\n\n\n\n\n","category":"type"},{"location":"primitives/#OpticSim.AsphericSurface-primitives","page":"Primitives","title":"OpticSim.AsphericSurface","text":"AsphericSurface{T,N,Q,M} <: ParametricSurface{T,N}\n\nSurface incorporating an aspheric polynomial - radius, conic and aspherics are defined relative to absolute semi-diameter,. T is the datatype, N is the dimensionality, Q is the number of aspheric terms, and M is the type of aspheric polynomial. \n\nAsphericSurface(semidiameter; radius, conic, aspherics=nothing, normradius = semidiameter)\n\nThe surface is centered at the origin and treated as being the cap of an infinite cylinder, thus creating a true half-space. Outside of 0 <= ρ <= 1 the height of the surface is not necessarily well defined, so NaN may be returned.\n\naspherics  aspherics should be vectors containing tuples of the form (i, v) where i is the polynomial power of the aspheric term. An empty vector is not permitted. Use nothing instead.\n\nThe sag is defined by the equation\n\nz(rphi) = fraccr^21 + sqrt1 - (1+k)c^2r^2 + sum_i^Qalpha_ir^i\n\nwhere rho = fracrtextttnormradius, c = frac1textttradius, and k = textttconic .\n\nThe function checks if the aspheric terms are missing, even, odd or both and uses an efficient polynomial evaluation strategy.\n\n\n\n\n\n","category":"type"},{"location":"primitives/#OpticSim.ZernikeSurface-primitives","page":"Primitives","title":"OpticSim.ZernikeSurface","text":"ZernikeSurface{T,N,P,Q,M} <: ParametricSurface{T,N}\n\nSurface incorporating the Zernike polynomials - radius, conic and aspherics are defined relative to absolute semi-diameter, Zernike terms are normalized according to the normradius parameter. T is the datatype, N is the dimensionality, P is the number of Zernike terms, Q is the number of aspheric terms and M is the Aspheric Type.\n\nThe surface is centered at the origin and treated as being the cap of an infinite cylinder, thus creating a true half-space. Outside of 0 <= ρ <= 1 the height of the surface is not necessarily well defined, so NaN may be returned.\n\nFor convenience the input zcoeff can be indexed using either OSA or Noll convention, indicated using the indexing argument as either ZernikeIndexingOSA or ZernikeIndexingNoll.\n\nZernikeSurface(semidiameter, radius = Inf, conic = 0, zcoeff = nothing, aspherics = nothing, normradius = semidiameter, indexing = ZernikeIndexingOSA)\n\nzcoeff and aspherics should be vectors containing tuples of the form (i, v) where i is either the index of the Zernike term for the corresponding indexing, or the polynomial power of the aspheric term (may be even or odd) and  v is the corresponding coefficient A_i or alpha_i respectively..  M will be determined from the terms entered to optimize the evaluation of the aspheric polynomial.\n\nThe sag is defined by the equation\n\nz(rphi) = fraccr^21 + sqrt1 - (1+k)c^2r^2 + sum_i^Qalpha_ir^2i + sum_i^PA_iZ_i(rho phi)\n\nwhere rho = fracrtextttnormradius, c = frac1textttradius, k = textttconic and Z_n is the nᵗʰ Zernike polynomial.\n\n\n\n\n\n","category":"type"},{"location":"primitives/#OpticSim.BezierSurface-primitives","page":"Primitives","title":"OpticSim.BezierSurface","text":"BezierSurface{P,S,N,M} <: SplineSurface{P,S,N,M}\n\nBezier surface defined by grid of control points.\n\ndanger: Danger\nThis surface does not create a valid half-space, requires updates to function correctly.\n\nBezierSurface{P,S,N,M}(controlpoints::AbstractArray{<:AbstractArray{S,1},2})\n\n\n\n\n\n","category":"type"},{"location":"primitives/#OpticSim.BSplineSurface-primitives","page":"Primitives","title":"OpticSim.BSplineSurface","text":"BSplineSurface{P,S,N,M} <: SplineSurface{P,S,N,M}\n\nCurve order is the same in the u and v direction and fixed over all spans. u and v knot vectors are allowed to be different - may change this to make them both the same.\n\nControl points in the u direction correspond to columns, with the lowest value of u corresponding to row 1. Control points in the v direction correspond to rows, with the lowest value of v corresponding to col 1.\n\ndanger: Danger\nThis surface does not create a valid half-space, requires updates to function correctly.\n\nBSplineSurface{P,S,N,M}(knots::KnotVector{S}, controlpoints::AbstractArray{<:AbstractArray{S,1},2})\nBSplineSurface{P,S,N,M}(uknots::KnotVector{S}, vknots::KnotVector{S}, controlpoints::AbstractArray{<:AbstractArray{S,1},2})\n\n\n\n\n\n","category":"type"},{"location":"primitives/#OpticSim.QTypeSurface-primitives","page":"Primitives","title":"OpticSim.QTypeSurface","text":"QTypeSurface{T,D,M,N} <: ParametricSurface{T,D}\n\nSurface incorporating the QType polynomials - radius and conic are defined relative to absolute semi-diameter, QType terms are normalized according to the normradius parameter. T is the datatype, D is the dimensionality, M and N are the maximum QType terms used.\n\nThe surface is centered at the origin and treated as being the cap of an infinite cylinder, thus creating a true half-space. Outside of 0 <= ρ <= 1 the height of the surface is not necessarily well defined, so NaN may be returned.\n\nQTypeSurface(semidiameter; radius = Inf, conic = 0.0, αcoeffs = nothing, βcoeffs = nothing, normradius = semidiameter)\n\nαcoeffs and βcoeffs should be a vector of tuples of the form (m, n, v) where v is the value of the coefficient α_n^m or β_n^m respectively.\n\nThe sag is defined by the equation\n\nbeginaligned\nz(rphi) =  fraccr^21 + sqrt1 - (1+k)c^2r^2 + fracsqrt1 + kc^2r^2sqrt1-(1+k)c^2r^2 cdot \n              left rho^2(1-rho^2)sum_n=0^Nalpha_n^0 Q_n^0 (rho^2) + sum_m=1^Mrho^msum_n=0^N left alpha_n^mcosmphi +beta_n^msinmphirightQ_n^m(rho^2) right\nendaligned\n\nwhere rho = fracrtextttnormradius, c = frac1textttradius, k = textttconic and Q_n^m is the QType polynomial index m, n.\n\n\n\n\n\n","category":"type"},{"location":"primitives/#OpticSim.ChebyshevSurface-primitives","page":"Primitives","title":"OpticSim.ChebyshevSurface","text":"ChebyshevSurface{T,N,P,Q} <: ParametricSurface{T,N}\n\nRectangular surface incorporating Chebyshev polynomials as well as radius and conic terms. T is the datatype, N is the dimensionality, P is the number of Chebyshev terms in u and Q is the number of Chebyshev terms in v.\n\nThe surface is centered at the origin and treated as being the cap of an infinite rectangular prism, thus creating a true half-space. Note that the surface is vertically offset so that the center (i.e., (u,v) == (0,0)) lies at 0 on the z-axis.\n\nChebyshevSurface(halfsizeu, halfsizev, chebycoeff; radius = Inf, conic = 0)\n\nchebycoeff is a vector containing tuples of the form (i, j, v) where v is the value of the coefficient c_ij.\n\nThe sag is defined by the equation\n\nz(uv) = fracc(u^2 + v^2)^21 + sqrt1 - (1+k)c^2(u^2 + v^2) + sum_i^Psum_j^Qc_ijT_i(u)T_j(v)\n\nwhere c = frac1textttradius, k = textttconic and T_n is the nᵗʰ Chebyshev polynomial of the first kind.\n\n\n\n\n\n","category":"type"},{"location":"primitives/#OpticSim.GridSagSurface-primitives","page":"Primitives","title":"OpticSim.GridSagSurface","text":"GridSagSurface{T,N,S<:Union{ZernikeSurface{T,N},ChebyshevSurface{T,N}},Nu,Nv} <: ParametricSurface{T,N}\n\nEither a Zernike (circular) or Chebyshev (rectangular) surface with grid sag height added to the base sag. The surface shape is determined by either a linear or a bicubic spline interpolation of the Nu×Nv grid of sag values, set by the interpolation argument taking either GridSagLinear or GridSagBicubic.\n\nEach entry in the grid is a vector of the form z fracpartial zpartial x fracpartial zpartial y fracpartial^2 zpartial x partial y. The first data item corresponds to the lower left corner of the surface, that is, the corner defined by the -u and -v limit. Each point that follows is read across the face of the surface from left to right moving upwards. If zero is given for the partials (and using bicubic interpolation) then the partials will be approximated using finite differences.\n\nThe sag grid can be decentered from the surface in uv space, if so the surface may become wild outside of the area over which the grid is defined. It is advised to clip the surface to the valid area using CSG operations in this case.\n\nA surface can also be generated from a .GRD file by passing in the filename as the first and only positional argument. In this case the surface will be rectangular with optional radius and conic.\n\nSee docs for ZernikeSurface and ChebyshevSurface for details of the base surface.\n\nGridSagSurface(basesurface::Union{ZernikeSurface{T,N},ChebyshevSurface{T,N}}, sag_grid::AbstractArray{T,3}; interpolation = GridSagBicubic, decenteruv = (0, 0))\nGridSagSurface{T}(filename::String; radius = Inf, conic = 0, interpolation = GridSagBicubic)\n\n\n\n\n\n","category":"type"},{"location":"primitives/#Functions","page":"Primitives","title":"Functions","text":"","category":"section"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":"These are some useful functions related to Surface objects.","category":"page"},{"location":"primitives/#OpticSim.point-Union{Tuple{T}, Tuple{ParametricSurface{T}, T, T}} where T<:Real-primitives","page":"Primitives","title":"OpticSim.point","text":"point(surf::ParametricSurface{T}, u::T, v::T) -> SVector{3,T}\npoint(surf::ParametricSurface{T}, uv::SVector{2,T}) -> SVector{3,T}\n\nReturns the 3D point on surf at the given uv coordinate.\n\n\n\n\n\n","category":"method"},{"location":"primitives/#OpticSim.normal-primitives","page":"Primitives","title":"OpticSim.normal","text":"normal(surf::ParametricSurface{T}, u::T, v::T) -> SVector{3,T}\nnormal(surf::ParametricSurface{T}, uv::SVector{2,T}) -> SVector{3,T}\n\nReturns the normal to surf at the given uv coordinate.\n\n\n\n\n\n","category":"function"},{"location":"primitives/#OpticSim.partials-Union{Tuple{T}, Tuple{ParametricSurface{T}, T, T}} where T<:Real-primitives","page":"Primitives","title":"OpticSim.partials","text":"partials(surf::ParametricSurface{T}, u::T, v::T) -> (SVector{3,T}, SVector{3,T})\npartials(surf::ParametricSurface{T}, uv::SVector{2,T}) -> (SVector{3,T}, SVector{3,T})\n\nReturns a tuple of the 3D partial derivatives of surf with respect to u and v at the given uv coordinate.\n\n\n\n\n\n","category":"method"},{"location":"primitives/#OpticSim.uvrange-primitives","page":"Primitives","title":"OpticSim.uvrange","text":"uvrange(s::ParametricSurface)\nuvrange(::Type{S}) where {S<:ParametricSurface}\n\nReturns a tuple of the form: ((umin, umax), (vmin, vmax)) specifying the limits of the parameterisation for this surface type. Also implemented for some Surfaces which are not ParametricSurfaces (e.g. Rectangle).\n\n\n\n\n\n","category":"function"},{"location":"primitives/#OpticSim.uv-primitives","page":"Primitives","title":"OpticSim.uv","text":"uv(surf::ParametricSurface{T}, p::SVector{3,T}) -> SVector{2,T}\nuv(surf::ParametricSurface{T}, x::T, y::T, z::T) -> SVector{2,T}\n\nReturns the uv coordinate on surf of a point, p, in 3D space. If onsurface(surf, p) is false then the behavior is undefined, it may return an inorrect uv, an invalid uv, NaN or crash.\n\n\n\n\n\n","category":"function"},{"location":"primitives/#OpticSim.uvtopix-primitives","page":"Primitives","title":"OpticSim.uvtopix","text":"uvtopix(surf::Surface{T}, uv::SVector{2,T}, imsize::Tuple{Int,Int}) -> Tuple{Int,Int}\n\nConverts a uvcoordinate on surf to an integer index to a pixel in an image of size imsize. Not implemented on all Surface objects. Used to determine where in the detector image a ray has hit when in intersects the detector surface of an AbstractOpticalSystem.\n\n\n\n\n\n","category":"function"},{"location":"primitives/#OpticSim.inside-Union{Tuple{T}, Tuple{ParametricSurface{T, 3}, T, T, T}} where T<:Real-primitives","page":"Primitives","title":"OpticSim.inside","text":"inside(surf::ParametricSurface{T}, p::SVector{3,T}) -> Bool\ninside(surf::ParametricSurface{T}, x::T, y::T, z::T) -> Bool\n\nTests whether a 3D point in world space is inside surf.\n\n\n\n\n\n","category":"method"},{"location":"primitives/#OpticSim.onsurface-Union{Tuple{T}, Tuple{ParametricSurface{T, 3}, T, T, T}} where T<:Real-primitives","page":"Primitives","title":"OpticSim.onsurface","text":"onsurface(surf::ParametricSurface{T}, p::SVector{3,T}) -> Bool\nonsurface(surf::ParametricSurface{T}, x::T, y::T, z::T) -> Bool\n\nTests whether a 3D point in world space is on surf.\n\n\n\n\n\n","category":"method"},{"location":"primitives/#OpticSim.interface-primitives","page":"Primitives","title":"OpticSim.interface","text":"interface(surf::Surface{T}) -> OpticalInterface{T}\n\nReturn the OpticalInterface associated with surf.\n\n\n\n\n\n","category":"function"},{"location":"primitives/#OpticSim.surfaceintersection-Union{Tuple{N}, Tuple{S}, Tuple{AcceleratedParametricSurface{S, N, S1} where S1<:ParametricSurface{S, N}, AbstractRay{S, N}}} where {S, N}-primitives","page":"Primitives","title":"OpticSim.surfaceintersection","text":"surfaceintersection(surf::Surface{T}, r::AbstractRay{T}) where {T}\n\nCalculates the intersection of r with a surface of any type, surf. Note that some surfaces cannot be intersected analytically so must be wrapped in an AcceleratedParametricSurface in order to be intersected.\n\nReturns an EmptyInterval if there is no Intersection, an Interval if there is one or two intersections and a DisjointUnion if there are more than two intersections.\n\n\n\n\n\n","category":"method"},{"location":"primitives/#OpticSim.samplesurface-primitives","page":"Primitives","title":"OpticSim.samplesurface","text":"samplesurface(surf::ParametricSurface{T,N}, samplefunction::Function, numsamples::Int = 30)\n\nSample a parametric surface on an even numsamples×numsamples grid in UV space with provided function\n\n\n\n\n\n","category":"function"},{"location":"primitives/#OpticSim.triangulate-primitives","page":"Primitives","title":"OpticSim.triangulate","text":"triangulate(surf::ParametricSurface{S,N}, quads_per_row::Int, extensionu::Bool = false, extensionv::Bool = false, radialu::Bool = false, radialv::Bool = false)\n\nCreate an array of triangles representing the parametric surface where vertices are sampled on an even grid in UV space. The surface can be extended by 1% in u and v separately, and specifying either u or v as being radial - i.e. determining the radius on the surface e.g. rho for zernike - will result in that dimension being sampled using sqwrt so that area of triangles is uniform. The extension will also only apply to the maximum in this case.\n\n\n\n\n\n","category":"function"},{"location":"primitives/#OpticSim.makemesh-primitives","page":"Primitives","title":"OpticSim.makemesh","text":"makemesh(object, subdivisions::Int = 30) -> TriangleMesh\n\nCreates a TriangleMesh from an object, either a ParametricSurface, CSGTree or certain surfaces (e.g. Circle, Rectangle). This is used for visualization purposes only.\n\n\n\n\n\nmakemesh(poly::ConvexPolygon{N, T}, ::Int = 0) where {N, T<:Real} -> TriangleMesh\n\nCreate a triangle mesh that can be rendered by iterating on the polygon's edges and for each edge use the centroid as the third vertex of the triangle.\n\n\n\n\n\n","category":"function"},{"location":"primitives/#Bounding-Boxes","page":"Primitives","title":"Bounding Boxes","text":"","category":"section"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":"Bounding boxes are mostly used internally for efficiency, but are also exposed to the user for visualization (and any other) purposes. All bounding boxes are axis aligned.","category":"page"},{"location":"primitives/#OpticSim.BoundingBox-primitives","page":"Primitives","title":"OpticSim.BoundingBox","text":"BoundingBox{T<:Real}\n\nAxis-aligned three-dimensional bounding box.\n\nBoundingBox(xmin::T, xmax::T, ymin::T, ymax::T, zmin::T, zmax::T)\nBoundingBox(s::Surface{T})\nBoundingBox(s::ParametricSurface{T,3}, transform::Transform{T} = identitytransform(T))\nBoundingBox(c::CSGTree{T})\nBoundingBox(tri::Triangle{T})\nBoundingBox(triangles::AbstractVector{Triangle{T}})\nBoundingBox(points::AbstractArray{SVector{3,T}})\nBoundingBox(la::LensAssembly{T})\n\n\n\n\n\n","category":"type"},{"location":"primitives/#OpticSim.doesintersect-primitives","page":"Primitives","title":"OpticSim.doesintersect","text":"doesintersect(bbox::BoundingBox{T}, r::AbstractRay{T,3}) -> Bool\n\nTests whether r intersects an axis-aligned BoundingBox, bbox.\n\n\n\n\n\n","category":"function"},{"location":"primitives/#OpticSim.surfaceintersection-Union{Tuple{T}, Tuple{BoundingBox{T}, AbstractRay{T, 3}}} where T<:Real-primitives","page":"Primitives","title":"OpticSim.surfaceintersection","text":"surfaceintersection(bbox::BoundingBox{T}, r::AbstractRay{T,3}) -> Union{EmptyInterval{T},Interval{T}}\n\nCalculates the intersection of r with an axis-aligned BoundingBox, bbox.\n\nReturns an EmptyInterval if there is no intersection or an Interval if there is one or two intersections. Note that the uv of the returned intersection is always 0.\n\n\n\n\n\n","category":"method"},{"location":"emitters/#Emitters","page":"Emitters","title":"Emitters","text":"","category":"section"},{"location":"emitters/","page":"Emitters","title":"Emitters","text":"warning: Warning\nThe old emitter implementation is deprecated as of v0.5! See below for the new API.","category":"page"},{"location":"emitters/","page":"Emitters","title":"Emitters","text":"Emitters create rays in a certain pattern, usually controlled by some parameters. Emitters are defined by Pixels and Spatial Layouts, and have a spectrum and an optical power distribution over the hemisphere. These are intrinsic physical properties of the emitter.","category":"page"},{"location":"emitters/","page":"Emitters","title":"Emitters","text":"The basic emitter (Source) is constructed as a combination of 4 basic elements and a 3D Transform. The basic elements include:","category":"page"},{"location":"emitters/","page":"Emitters","title":"Emitters","text":"Spectrum\nAngular Power Distribution\nRays Origins Distribution\nRays Directions Distribution","category":"page"},{"location":"emitters/","page":"Emitters","title":"Emitters","text":"The OpticSim package comes with various implementations of each of these basic elements:","category":"page"},{"location":"emitters/","page":"Emitters","title":"Emitters","text":"Spectrum - the generate interface returns a tuple (power, wavelength)\nEmitters.Spectrum.Uniform - A flat spectrum bounded (default: from 450nm to 680nm). the range is sampled uniformly.\nEmitters.Spectrum.DeltaFunction - Constant wave length.\nEmitters.Spectrum.Measured - measured spectrum to compute emitter power and wavelength (created by reading CSV files – more details will follow).\nAngular Power Distribution - the interface apply returns an OpticalRay with modified power\nEmitters.AngularPower.Lambertian\nEmitters.AngularPower.Cosine\nEmitters.AngularPower.Gaussian\nRays Origins Distribution - the interface length returns the number of samples, and generate returns the n'th sample.\nEmitters.Origins.Point - a single point\nEmitters.Origins.RectUniform - a uniformly sampled rectangle with user defined number of samples\nEmitters.Origins.RectGrid - a rectangle sampled in a grid fashion\nEmitters.Origins.Hexapolar - a circle (or an ellipse) sampled in an hexapolar fashion (rings)\nRays Directions Distribution - the interface length returns the number of samples, and generate returns the n'th sample.\nEmitters.Directions.Constant\nEmitters.Directions.RectGrid\nEmitters.Directions.UniformCone\nEmitters.Directions.HexapolarCone","category":"page"},{"location":"emitters/#basic_emitters","page":"Emitters","title":"Examples of Basic Emitters","text":"","category":"section"},{"location":"emitters/","page":"Emitters","title":"Emitters","text":"Note: All of the examples on this page assume that the following statement was executed:","category":"page"},{"location":"emitters/","page":"Emitters","title":"Emitters","text":"using OpticSim, OpticSim.Geometry, OpticSim.Emitters                                # hide","category":"page"},{"location":"emitters/","page":"Emitters","title":"Emitters","text":"using OpticSim, OpticSim.Geometry, OpticSim.Emitters","category":"page"},{"location":"emitters/#Simple-functions-for-creating-commonly-used-emitters","page":"Emitters","title":"Simple functions for creating commonly used emitters","text":"","category":"section"},{"location":"emitters/","page":"Emitters","title":"Emitters","text":"Many optical systems by convention have their optical axis parallel to the z axis. These utility functions provide a simple interface to the Emitters package to create emitters that direct their rays in the negative z direction, toward the entrance of the optical system.","category":"page"},{"location":"emitters/#OpticSim.Emitters.pointemitter-emitters","page":"Emitters","title":"OpticSim.Emitters.pointemitter","text":"pointemitter(origin::AbstractVector{T}, coneangle; λ::Length = 500nm, numrays = 100) where {T<:Real}\n\nCreates a point source with Lambertian emission power and cone distribution of rays, emitting in the -z direction. λ is a unitful Length quantity, e.g., 550nm.\n\n\n\n\n\n","category":"function"},{"location":"emitters/","page":"Emitters","title":"Emitters","text":"using OpticSim, OpticSim.Geometry, OpticSim.Emitters # hide\npt = Emitters.pointemitter([0.0,0.0,.5],.3)","category":"page"},{"location":"emitters/#OpticSim.Emitters.collimatedemitter-emitters","page":"Emitters","title":"OpticSim.Emitters.collimatedemitter","text":"collimatedemitter(origin::AbstractVector{T}, halfsquaresize; λ::Length = 500nm, numrays = 100) where {T<:Real}\n\nCreates a square collimated emitter, emitting rays in the -z direction. Rays are emitted on a square grid with sqrt(numrays) on a side. λ can be a unitful quantity, e.g., 550nm, or a number. In the latter case the units are implicitly microns.\n\n\n\n\n\n","category":"function"},{"location":"emitters/","page":"Emitters","title":"Emitters","text":"using OpticSim, OpticSim.Geometry, OpticSim.Emitters # hide\npt = Emitters.collimatedemitter([0.0,0.0,1.0],.5)","category":"page"},{"location":"emitters/#Point-origin-with-various-Direction-distributions","page":"Emitters","title":"Point origin with various Direction distributions","text":"","category":"section"},{"location":"emitters/","page":"Emitters","title":"Emitters","text":"using OpticSim, OpticSim.Geometry, OpticSim.Emitters # hide\nsrc = Sources.Source(origins=Origins.Point(), directions=Directions.RectGrid(π/4, π/4, 15, 15))","category":"page"},{"location":"emitters/","page":"Emitters","title":"Emitters","text":"using OpticSim, OpticSim.Geometry, OpticSim.Emitters # hide\nsrc = Sources.Source(origins=Origins.Point(), directions=Directions.UniformCone(π/6, 1000))","category":"page"},{"location":"emitters/","page":"Emitters","title":"Emitters","text":"using OpticSim, OpticSim.Geometry, OpticSim.Emitters # hide\nsrc = Sources.Source(origins=Origins.Point(), directions=Directions.HexapolarCone(π/6, 10))","category":"page"},{"location":"emitters/#Various-origins-distributions","page":"Emitters","title":"Various origins distributions","text":"","category":"section"},{"location":"emitters/","page":"Emitters","title":"Emitters","text":"using OpticSim, OpticSim.Geometry, OpticSim.Emitters # hide\nsrc = Sources.Source(origins=Origins.RectGrid(1.0, 1.0, 10, 10), directions=Directions.Constant())","category":"page"},{"location":"emitters/","page":"Emitters","title":"Emitters","text":"using OpticSim, OpticSim.Geometry, OpticSim.Emitters # hide\nsrc = Sources.Source(origins=Origins.Hexapolar(5, 1.0, 2.0), directions=Directions.Constant())","category":"page"},{"location":"emitters/#Examples-of-Angular-Power-Distribution","page":"Emitters","title":"Examples of Angular Power Distribution","text":"","category":"section"},{"location":"emitters/","page":"Emitters","title":"Emitters","text":"In these example, the arrow width is proportional to the ray power.","category":"page"},{"location":"emitters/","page":"Emitters","title":"Emitters","text":"using OpticSim, OpticSim.Geometry, OpticSim.Emitters # hide\nsrc = Sources.Source(\n    origins=Origins.Hexapolar(1, 8.0, 8.0),             # Hexapolar Origins\n\tdirections=Directions.RectGrid(π/6, π/6, 15, 15),   # RectGrid Directions\n\tpower=AngularPower.Cosine(10.0)                     # Cosine Angular Power \n)","category":"page"},{"location":"emitters/","page":"Emitters","title":"Emitters","text":"using OpticSim, OpticSim.Geometry, OpticSim.Emitters # hide\nsrc = Sources.Source(\n\torigins=Origins.RectGrid(1.0, 1.0, 3, 3),           # RectGrid Origins  \n\tdirections=Directions.HexapolarCone(π/6, 10),       # HexapolarCone Directions\n\tpower=AngularPower.Gaussian(2.0, 2.0)               # Gaussian Angular Power \n)","category":"page"},{"location":"emitters/#Composite-Sources-Display-Example","page":"Emitters","title":"Composite Sources - Display Example","text":"","category":"section"},{"location":"emitters/","page":"Emitters","title":"Emitters","text":"using OpticSim, OpticSim.Geometry, OpticSim.Emitters # hide\n\n# construct the emitter's basic components\nS = Spectrum.Uniform()\nP = AngularPower.Lambertian()\nO = Origins.RectGrid(1.0, 1.0, 3, 3)\nD = Directions.HexapolarCone(deg2rad(5.0), 3)\t\n\t\n# construct the source. in this example a \"pixel\" source will contain only one source as we are simulating a \"b/w\" display. \n# for RGB displays we can combine 3 sources to simulate \"a pixel\".\nTr = Transform(Vec3(0.5, 0.5, 0.0))\nsource1 = Sources.Source(Tr, S, O, D, P)\n\t\n# create a list of pixels - each one is a composite source\npixels = Vector{Sources.CompositeSource{Float64}}(undef, 0)\nfor y in 1:5 # image_height\n    for x in 1:10 # image_width\n        # pixel position relative to the display's origin\n        local pixel_position = Vec3((x-1) * 1.1, (y-1) * 1.5, 0.0)\n        local Tr = Transform(pixel_position)\n\n        # constructing the \"pixel\"\n        pixel = Sources.CompositeSource(Tr, [source1])\n\n        push!(pixels, pixel)\n    end\nend\n\t\nTr = Transform(Vec3(0.0, 0.0, 0.0))\nmy_display = Sources.CompositeSource(Tr, pixels)\n\nrays = AbstractArray{OpticalRay{Float64, 3}}(collect(my_display))   # collect the rays generated by the display                                                   # render the rays ","category":"page"},{"location":"emitters/#spectrum","page":"Emitters","title":"Spectrum","text":"","category":"section"},{"location":"emitters/#OpticSim.Emitters.Spectrum.Uniform-emitters","page":"Emitters","title":"OpticSim.Emitters.Spectrum.Uniform","text":"Uniform{T} <: AbstractSpectrum{T}\n\nEncapsulates a flat spectrum range which is sampled uniformly. Unless stated diferrently, the range used will be 450nm to 680nm.\n\nUniform(low_end::T, high_end::T) where {T<:Real}\nUniform(::Type{T} = Float64) where {T<:Real}\n\n\n\n\n\n","category":"type"},{"location":"emitters/#OpticSim.Emitters.Spectrum.DeltaFunction-emitters","page":"Emitters","title":"OpticSim.Emitters.Spectrum.DeltaFunction","text":"DeltaFunction{T} <: AbstractSpectrum{T}\n\nEncapsulates a constant spectrum.\n\nDeltaFunction{T<:Real}\n\n\n\n\n\n","category":"type"},{"location":"emitters/#OpticSim.Emitters.Spectrum.Measured-emitters","page":"Emitters","title":"OpticSim.Emitters.Spectrum.Measured","text":"Measured{T} <: AbstractSpectrum{T}\n\nEncapsulates a measured spectrum to compute emitter power. Create spectrum by reading CSV files. Assumes spectrum samples are evenly spaced - exception otherwise. Evaluate spectrum at arbitrary wavelength with spectrumpower (more technical details coming soon)\n\nMeasured(samples::DataFrame)\n\n\n\n\n\n","category":"type"},{"location":"emitters/#OpticSim.Emitters.Spectrum.spectrumpower-emitters","page":"Emitters","title":"OpticSim.Emitters.Spectrum.spectrumpower","text":"expects wavelength in nm not um\n\n\n\n\n\n","category":"function"},{"location":"emitters/#angular_power_distribution","page":"Emitters","title":"Angular Power Distribution","text":"","category":"section"},{"location":"emitters/#OpticSim.Emitters.AngularPower.Lambertian-emitters","page":"Emitters","title":"OpticSim.Emitters.AngularPower.Lambertian","text":"Lambertian{T} <: AbstractAngularPowerDistribution{T}\n\nRay power is unaffected by angle.\n\n\n\n\n\n","category":"type"},{"location":"emitters/#OpticSim.Emitters.AngularPower.Cosine-emitters","page":"Emitters","title":"OpticSim.Emitters.AngularPower.Cosine","text":"Cosine{T} <: AbstractAngularPowerDistribution{T}\n\nCosine power distribution. Ray power is calculated by:\n\npower = power * (cosine_angle ^ cosine_exp)\n\n\n\n\n\n","category":"type"},{"location":"emitters/#OpticSim.Emitters.AngularPower.Gaussian-emitters","page":"Emitters","title":"OpticSim.Emitters.AngularPower.Gaussian","text":"Gaussian{T} <: AbstractAngularPowerDistribution{T}\n\nGGaussian power distribution. Ray power is calculated by:\n\npower = power * exp(-(gaussianu * l^2 + gaussianv * m^2)) where l and m are the cos_angles between the two axes respectively.\n\n\n\n\n\n","category":"type"},{"location":"emitters/#rays_origins_distribution","page":"Emitters","title":"Rays Origins Distribution","text":"","category":"section"},{"location":"emitters/#OpticSim.Emitters.Origins.Point-emitters","page":"Emitters","title":"OpticSim.Emitters.Origins.Point","text":"Point{T} <: AbstractOriginDistribution{T}\n\nEncapsulates a single point origin.\n\nPoint(position::Vec3{T}) where {T<:Real}\nPoint(x::T, y::T, z::T) where {T<:Real}\nPoint(::Type{T} = Float64) where {T<:Real}\n\n\n\n\n\n","category":"type"},{"location":"emitters/#OpticSim.Emitters.Origins.RectUniform-emitters","page":"Emitters","title":"OpticSim.Emitters.Origins.RectUniform","text":"RectUniform{T} <: AbstractOriginDistribution{T}\n\nEncapsulates a uniformly sampled rectangle with user defined number of samples.\n\nRectUniform(width::T, height::T, samples_count::Int64) where {T<:Real}\n\n\n\n\n\n","category":"type"},{"location":"emitters/#OpticSim.Emitters.Origins.RectGrid-emitters","page":"Emitters","title":"OpticSim.Emitters.Origins.RectGrid","text":"RectGrid{T} <: AbstractOriginDistribution{T}\n\nEncapsulates a rectangle sampled in a grid fashion.\n\nRectGrid(width::T, height::T, usamples::Int64, vsamples::Int64) where {T<:Real} \n\n\n\n\n\n","category":"type"},{"location":"emitters/#OpticSim.Emitters.Origins.Hexapolar-emitters","page":"Emitters","title":"OpticSim.Emitters.Origins.Hexapolar","text":"Hexapolar{T} <: AbstractOriginDistribution{T}\n\nEncapsulates an ellipse (or a circle where halfsizeu=halfsizev) sampled in an hexapolar fashion (rings).\n\nHexapolar(nrings::Int64, halfsizeu::T, halfsizev::T) where {T<:Real} \n\n\n\n\n\n","category":"type"},{"location":"emitters/#rays_directions_distribution","page":"Emitters","title":"Rays Directions Distribution","text":"","category":"section"},{"location":"emitters/#OpticSim.Emitters.Directions.Constant-emitters","page":"Emitters","title":"OpticSim.Emitters.Directions.Constant","text":"Constant{T} <: AbstractDirectionDistribution{T}\n\nEncapsulates a single ray direction, where the default direction is unitZ3 [0, 0, 1].\n\nConstant(direction::Vec3{T}) where {T<:Real}\nConstant(::Type{T} = Float64) where {T<:Real}\n\n\n\n\n\n","category":"type"},{"location":"emitters/#OpticSim.Emitters.Directions.RectGrid-emitters","page":"Emitters","title":"OpticSim.Emitters.Directions.RectGrid","text":"RectGrid{T} <: AbstractDirectionDistribution{T}\n\nEncapsulates a single ray direction, where the default direction is unitZ3 [0, 0, 1].\n\nConstant(direction::Vec3{T}) where {T<:Real}\nConstant(::Type{T} = Float64) where {T<:Real}\n\n\n\n\n\n","category":"type"},{"location":"emitters/#OpticSim.Emitters.Directions.UniformCone-emitters","page":"Emitters","title":"OpticSim.Emitters.Directions.UniformCone","text":"UniformCone{T} <: AbstractDirectionDistribution{T}\n\nEncapsulates numsamples rays sampled uniformly from a cone with max angle θmax.\n\nUniformCone(direction::Vec3{T}, θmax::T, numsamples::Int64) where {T<:Real}\nUniformCone(θmax::T, numsamples::Int64) where {T<:Real}\n\n\n\n\n\n","category":"type"},{"location":"emitters/#OpticSim.Emitters.Directions.HexapolarCone-emitters","page":"Emitters","title":"OpticSim.Emitters.Directions.HexapolarCone","text":"HexapolarCone{T} <: AbstractDirectionDistribution{T}\n\nRays are generated by sampling a cone with θmax angle in an hexapolar fashion. The number of rays depends on the requested rings and is computed using the following formula: 1 + round(Int64, (nrings * (nrings + 1) / 2) * 6)\n\nHexapolarCone(direction::Vec3{T}, θmax::T, nrings::Int64) where {T<:Real}\nHexapolarCone(θmax::T, nrings::Int64 = 3) where {T<:Real}\n\n\n\n\n\n","category":"type"},{"location":"emitters/#sources","page":"Emitters","title":"Sources","text":"","category":"section"},{"location":"emitters/#OpticSim.Emitters.Sources.Source-emitters","page":"Emitters","title":"OpticSim.Emitters.Sources.Source","text":"Source{T<:Real, Tr<:Transform{T}, S<:Spectrum.AbstractSpectrum{T}, O<:Origins.AbstractOriginDistribution{T}, D<:Directions.AbstractDirectionDistribution{T}, P<:AngularPower.AbstractAngularPowerDistribution{T}} <: AbstractSource{T}\n\nThis data-type represents the basic emitter (Source), which is a combination of a Spectrum, Angular Power Distribution, Origins and Directions distribution and a 3D Transform.\n\nSource(::Type{T} = Float64;\n       transform::Tr = Transform(),\n       spectrum::S = Spectrum.Uniform(),\n       origins::O = Origins.Point(),\n       directions::D = Directions.Constant(),\n       power::P = AngularPower.Lambertian(),\n       sourcenum::Int64 = 0) where {\n            Tr<:Transform,\n            S<:Spectrum.AbstractSpectrum,\n            O<:Origins.AbstractOriginDistribution,\n            D<:Directions.AbstractDirectionDistribution,\n            P<:AngularPower.AbstractAngularPowerDistribution,\n            T<:Real}\n\nSource(transform::Tr, spectrum::S, origins::O, directions::D, power::P, ::Type{T} = Float64; sourcenum::Int64 = 0) where {   \n            Tr<:Transform,\n            S<:Spectrum.AbstractSpectrum,\n            O<:Origins.AbstractOriginDistribution,\n            D<:Directions.AbstractDirectionDistribution,\n            P<:AngularPower.AbstractAngularPowerDistribution,\n            T<:Real}\n\n\n\n\n\n","category":"type"},{"location":"emitters/#OpticSim.Emitters.Sources.CompositeSource-emitters","page":"Emitters","title":"OpticSim.Emitters.Sources.CompositeSource","text":"CompositeSource{T} <: AbstractSource{T}\n\nThis data-type represents the composite emitter (Source) which is constructed with a list of basic or composite emitters and a 3D Transform.\n\nCompositeSource(transform::Transform{T}, sources::Vector{<:AbstractSource}) where {T<:Real} \n\n\n\n\n\n","category":"type"},{"location":"#OpticSim.jl","page":"Home","title":"OpticSim.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"OpticSim.jl is a Julia package for geometric optics (ray tracing) simulation and optimization of complex optical systems.","category":"page"},{"location":"","page":"Home","title":"Home","text":"It is designed to allow optical engineers to create optical systems procedurally and then to simulate them. Unlike Zemax, Code V, or other interactive optical design systems OpticSim.jl has limited support for interactivity.","category":"page"},{"location":"","page":"Home","title":"Home","text":"A large variety of surface types are supported, and these can be composed into complex 3D objects through the use of constructive solid geometry (CSG). A complete catalog of optical materials is provided through the complementary AGFFileReader package.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Run this example to check that everything installed properly:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using OpticSim, AGFFileReader\nSphericalLens(AGFFileReader.Examples_N_BK7, 0.0, 10.0, 10.0, 5.0, 5.0)","category":"page"},{"location":"","page":"Home","title":"Home","text":"AGFFileReader includes these 4 glass types to get you started","category":"page"},{"location":"","page":"Home","title":"Home","text":"Examples_N_BK7\nExamples_N_SF14\nExamples_N_SF2\nExamples_N_SK16","category":"page"},{"location":"","page":"Home","title":"Home","text":"For serious work you will need more glass types. The AGFFileReader package has a function AGFFileReader.initialize_AGFFileReader() to make a local database of glass types generated from publicly available glass catalogs on the web. You must call this function before you execute your code:","category":"page"},{"location":"","page":"Home","title":"Home","text":"module YourModule\nusing OpticSim\nimport AGFFileReader\n\nAGFFileReader.initialize_AGFFileReader()\n\n#your code goes here\n\nend #YourModule","category":"page"},{"location":"","page":"Home","title":"Home","text":"The first call to AGFFileReader.initialize_AGFFileReader() will search for publicly available glass files on the web and install them into a database locally on your machine. This may take a while. Subsequent calls will detect the local database and skip the download step. See the documentation of AGFFileReader for more information.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In previous versions of OpticSim the glass catalog download, visualization, and repeating structures code was included in the OpticSim package. This caused excessive load times. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"These have been broken out into separate packages: AGFFileReader, OpticSimVisualization, and OpticSimRepeatingStructures. The last two packages are not yet working.","category":"page"},{"location":"ref/#Complete-Reference","page":"Reference","title":"Complete Reference","text":"","category":"section"},{"location":"ref/","page":"Reference","title":"Reference","text":"This page contains what should be a complete list of all docstrings in the OpticSim module, and its submodule.","category":"page"},{"location":"ref/#Index","page":"Reference","title":"Index","text":"","category":"section"},{"location":"ref/","page":"Reference","title":"Reference","text":"Pages   = [\"ref.md\"]","category":"page"},{"location":"ref/#OpticSim","page":"Reference","title":"OpticSim","text":"","category":"section"},{"location":"ref/#OpticSim.AbstractOpticalSystem","page":"Reference","title":"OpticSim.AbstractOpticalSystem","text":"AbstractOpticalSystem{T<:Real}\n\nAbstract type for any optical system, must parameterized by the datatype of entities within the system T.\n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.AcceleratedParametricSurface","page":"Reference","title":"OpticSim.AcceleratedParametricSurface","text":"AcceleratedParametricSurface{T,N,S} <: ParametricSurface{T,N}\n\nWrapper class for ParametricSurfaces where analytical intersection isn't feasible (e.g. ZernikeSurface, ChebyshevSurface). The surface is instead triangulated and an iterative (newton raphson) process carried out to determine precise ray intersection points. S is the type of the ParametricSurface being wrapped.\n\nAcceleratedParametricSurface(surf::ParametricSurface{T,N}, numsamples::Int = 17; interface::NullOrFresnel{T} = nullinterface(T))\n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.AsphericSurface","page":"Reference","title":"OpticSim.AsphericSurface","text":"AsphericSurface{T,N,Q,M} <: ParametricSurface{T,N}\n\nSurface incorporating an aspheric polynomial - radius, conic and aspherics are defined relative to absolute semi-diameter,. T is the datatype, N is the dimensionality, Q is the number of aspheric terms, and M is the type of aspheric polynomial. \n\nAsphericSurface(semidiameter; radius, conic, aspherics=nothing, normradius = semidiameter)\n\nThe surface is centered at the origin and treated as being the cap of an infinite cylinder, thus creating a true half-space. Outside of 0 <= ρ <= 1 the height of the surface is not necessarily well defined, so NaN may be returned.\n\naspherics  aspherics should be vectors containing tuples of the form (i, v) where i is the polynomial power of the aspheric term. An empty vector is not permitted. Use nothing instead.\n\nThe sag is defined by the equation\n\nz(rphi) = fraccr^21 + sqrt1 - (1+k)c^2r^2 + sum_i^Qalpha_ir^i\n\nwhere rho = fracrtextttnormradius, c = frac1textttradius, and k = textttconic .\n\nThe function checks if the aspheric terms are missing, even, odd or both and uses an efficient polynomial evaluation strategy.\n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.AxisymmetricOpticalSystem","page":"Reference","title":"OpticSim.AxisymmetricOpticalSystem","text":"AxisymmetricOpticalSystem{T,C<:CSGOpticalSystem{T}} <: AbstractOpticalSystem{T}\n\nOptical system which has lens elements and an image detector, created from a DataFrame containing prescription data.\n\nThese tags are supported for columns: :Radius, :SemiDiameter, :SurfaceType, :Thickness, :Conic, :Parameters, :Reflectance, :Material.\n\nThese tags are supported for entries in a SurfaceType column: Object, Image, Stop. Assumes the Image row will be the last row in the DataFrame.\n\nIn practice a CSGOpticalSystem is generated automatically and stored within this system.\n\nAxisymmetricOpticalSystem{T}(\n    prescription::DataFrame,\n    detectorpixelsx = 1000,\n    detectorpixelsy:: = 1000,\n    ::Type{D} = Float32;\n    temperature = AGFFileReader.TEMP_REF,\n    pressure = AGFFileReader.PRESSURE_REF\n)\n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.BSplineCurve","page":"Reference","title":"OpticSim.BSplineCurve","text":"BSplineCurve{P,S,N,M} <: Spline{P,S,N,M}\n\nN is the spatial dimension of the curve. M is the curve order, i.e., the highest power of the parameterizing variable, u. All curve segments are assumed to be of the same order.\n\nBSplineCurve{P,S,N,M}(knots::KnotVector{S}, controlpoints::AbstractArray{MVector{N,S},1})\n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.BSplineSurface","page":"Reference","title":"OpticSim.BSplineSurface","text":"BSplineSurface{P,S,N,M} <: SplineSurface{P,S,N,M}\n\nCurve order is the same in the u and v direction and fixed over all spans. u and v knot vectors are allowed to be different - may change this to make them both the same.\n\nControl points in the u direction correspond to columns, with the lowest value of u corresponding to row 1. Control points in the v direction correspond to rows, with the lowest value of v corresponding to col 1.\n\ndanger: Danger\nThis surface does not create a valid half-space, requires updates to function correctly.\n\nBSplineSurface{P,S,N,M}(knots::KnotVector{S}, controlpoints::AbstractArray{<:AbstractArray{S,1},2})\nBSplineSurface{P,S,N,M}(uknots::KnotVector{S}, vknots::KnotVector{S}, controlpoints::AbstractArray{<:AbstractArray{S,1},2})\n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.BeamState","page":"Reference","title":"OpticSim.BeamState","text":"ConvergingBeam, DivergingBeam or CollimatedBeam, defines the behavior of a beam in a HologramInterface.\n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.BezierCurve","page":"Reference","title":"OpticSim.BezierCurve","text":"BezierCurve{P,S,N,M} <: Spline{P,S,N,M}\n\nN is the dimension of the curve, M is the curve order\n\nBezierCurve{P,S,N,M}(controlpoints::AbstractArray{<:AbstractArray{S,1},1})\n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.BezierSurface","page":"Reference","title":"OpticSim.BezierSurface","text":"BezierSurface{P,S,N,M} <: SplineSurface{P,S,N,M}\n\nBezier surface defined by grid of control points.\n\ndanger: Danger\nThis surface does not create a valid half-space, requires updates to function correctly.\n\nBezierSurface{P,S,N,M}(controlpoints::AbstractArray{<:AbstractArray{S,1},2})\n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.BoundingBox","page":"Reference","title":"OpticSim.BoundingBox","text":"BoundingBox{T<:Real}\n\nAxis-aligned three-dimensional bounding box.\n\nBoundingBox(xmin::T, xmax::T, ymin::T, ymax::T, zmin::T, zmax::T)\nBoundingBox(s::Surface{T})\nBoundingBox(s::ParametricSurface{T,3}, transform::Transform{T} = identitytransform(T))\nBoundingBox(c::CSGTree{T})\nBoundingBox(tri::Triangle{T})\nBoundingBox(triangles::AbstractVector{Triangle{T}})\nBoundingBox(points::AbstractArray{SVector{3,T}})\nBoundingBox(la::LensAssembly{T})\n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.CSGGenerator","page":"Reference","title":"OpticSim.CSGGenerator","text":"CSGGenerator{T<:Real}\n\nThis is the type you should use when making CSG objects. This type allows for the construction of CSGTree objects with different transforms. When the generator is evaluated, all transforms are propagated down to the LeafNodes and stored there.\n\nExample\n\na = Cylinder(1.0,1.0)\nb = Plane([0.0,0.0,1.0], [0.0,0.0,0.0])\ngenerator = a ∩ b\n# now make a csg object that can be ray traced\ncsgobj = generator(Transform(1.0,1.0,2.0))\n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.CSGOpticalSystem","page":"Reference","title":"OpticSim.CSGOpticalSystem","text":"CSGOpticalSystem{T,D<:Real,S<:Surface{T},L<:LensAssembly{T}} <: AbstractOpticalSystem{T}\n\nAn optical system containing a lens assembly with all optical elements and a detector surface with associated image. The system can be at a specified temperature and pressure.\n\nThere are two number types in the type signature. The T type parameter is the numeric type for geometry in the optical system, the D type parameter is the numeric type of the pixels in the detector image. This way you can have Float64 geometry, where high precision is essential, but the pixels in the detector can be Float32 since precision is much less critical for image data, or Complex if doing wave optic simulations.\n\nThe detector can be any Surface which implements uv, uvtopix and onsurface, typically this is one of Rectangle, Ellipse or SphericalCap.\n\nCSGOpticalSystem(\n    assembly::LensAssembly,\n    detector::Surface,\n    detectorpixelsx = 1000,\n    detectorpixelsy = 1000, ::Type{D} = Float32;\n    temperature = AGFFileReader.TEMP_REF,\n    pressure = AGFFileReader.PRESSURE_REF\n)\n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.CSGTree","page":"Reference","title":"OpticSim.CSGTree","text":"Abstract type representing any evaluated CSG structure.\n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.ChebyshevSurface","page":"Reference","title":"OpticSim.ChebyshevSurface","text":"ChebyshevSurface{T,N,P,Q} <: ParametricSurface{T,N}\n\nRectangular surface incorporating Chebyshev polynomials as well as radius and conic terms. T is the datatype, N is the dimensionality, P is the number of Chebyshev terms in u and Q is the number of Chebyshev terms in v.\n\nThe surface is centered at the origin and treated as being the cap of an infinite rectangular prism, thus creating a true half-space. Note that the surface is vertically offset so that the center (i.e., (u,v) == (0,0)) lies at 0 on the z-axis.\n\nChebyshevSurface(halfsizeu, halfsizev, chebycoeff; radius = Inf, conic = 0)\n\nchebycoeff is a vector containing tuples of the form (i, j, v) where v is the value of the coefficient c_ij.\n\nThe sag is defined by the equation\n\nz(uv) = fracc(u^2 + v^2)^21 + sqrt1 - (1+k)c^2(u^2 + v^2) + sum_i^Psum_j^Qc_ijT_i(u)T_j(v)\n\nwhere c = frac1textttradius, k = textttconic and T_n is the nᵗʰ Chebyshev polynomial of the first kind.\n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.ConvexPolygon","page":"Reference","title":"OpticSim.ConvexPolygon","text":"ConvexPolygon{N, T<:Real} <: PlanarShape{T}\n\nGeneral Convex Polygon surface, not a valid CSG object. The rotation of the polygon around its normal is defined by rotationvec. rotationvec×surfacenormal is taken as the vector along the u axis.\n\nConvexPolygon(local_frame::Transform{T}, local_polygon_points::Vector{SVector{2, T}}, interface::NullOrFresnel{T} = nullinterface(T))\n\nThe local frame defines the plane (spans by the right and up vectors) with the plane normal given by the forward vector. the localpolygonpoints are given with respect to the local frame and are 2D points. NOTE: This class uses static vectors to hold the points which will lead to more efficient performance, but should not be used with polygons with more than 20-30 points.\n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.CurveType","page":"Reference","title":"OpticSim.CurveType","text":"Either Rational or Euclidean, used for Splines and SplineSurfaces.\n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.Cylinder","page":"Reference","title":"OpticSim.Cylinder","text":"Cylinder{T,N} <: ParametricSurface{T,N}\n\nCylinder of infinite height centered at the origin, oriented along the z-axis. visheight is used for visualization purposes only, note that this does not fully represent the surface.\n\nCylinder(radius::T, visheight::T = 2.0; interface::NullOrFresnel{T} = nullinterface(T))\n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.DisjointUnion","page":"Reference","title":"OpticSim.DisjointUnion","text":"Datatype representing an ordered series of disjoint intervals on a ray. An arbitrary array of Intervals can be input to the constructor and they will automatically be processed into a valid DisjointUnion (or a single Interval if appropriate).\n\nDisjointUnion(intervals::AbstractVector{Interval{R}})\n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.Ellipse","page":"Reference","title":"OpticSim.Ellipse","text":"Ellipse{T} <: Surface{T}\n\nElliptical surface, not a valid CSG object. The rotation of the rectangle around its normal is defined by rotationvec. rotationvec×surfacenormal is taken as the vector along the u axis.\n\nCan be used as a detector in AbstractOpticalSystems.\n\nEllipse(halfsizeu::T, halfsizev::T, [surfacenormal::SVector{3,T}, centrepoint::SVector{3,T}]; interface::NullOrFresnel{T} = nullinterface(T))\n\nThe minimal case returns an ellipse centered at the origin with surfacenormal = [0, 0, 1].\n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.EmptyInterval","page":"Reference","title":"OpticSim.EmptyInterval","text":"EmptyInterval{T} <: AbstractRayInterval{T}\n\nAn interval with no Intersections which is also not infinite.\n\nEmptyInterval(T = Float64)\nEmptyInterval{T}()\n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.FiniteStop","page":"Reference","title":"OpticSim.FiniteStop","text":"FiniteStop{T,P<:StopShape,Q<:StopShape} <: Surface{T}\n\nStop surface with finite extent. P refers to the shape of the aperture and Q represents the shape of the bounds of the stop surface.\n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.FresnelInterface","page":"Reference","title":"OpticSim.FresnelInterface","text":"FresnelInterface{T} <: OpticalInterface{T}\n\nInterface between two materials with behavior defined according to the Fresnel equations, with a specified reflectance and transmission. Assumes unpolarized light.\n\nFresnelInterface{T}(insidematerial, outsidematerial; reflectance = 0, transmission = 1, interfacemode = ReflectOrTransmit)\n\nThe interfacemode can be used to trace rays deterministically. Valid values are defined in the InterfaceMode enum. Reflect means that all values are reflected, Transmit means that all values are transmitted. ReflectOrTransmit will randomly reflect and transmit rays with the distribution given by the reflection and transmission arguments. This is also the default. In all cases the power recorded with the ray is correctly updated. This can be used to fake sequential raytracing. For example a beamsplitter surface may be set to either Reflect or Transmit to switch between the two outgoing ray paths.\n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.GeometricRayGenerator","page":"Reference","title":"OpticSim.GeometricRayGenerator","text":"GeometricRayGenerator{T,O<:RayOriginGenerator{T}} <: AbstractRayGenerator{T}\n\nGenerates geometric Rays according to the specific implementation of the subclass.\n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.GridSagInterpolation","page":"Reference","title":"OpticSim.GridSagInterpolation","text":"Either GridSagLinear or GridSagBicubic - determines the interpolation between sample points in the grid for a GridSagSurface.\n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.GridSagSurface","page":"Reference","title":"OpticSim.GridSagSurface","text":"GridSagSurface{T,N,S<:Union{ZernikeSurface{T,N},ChebyshevSurface{T,N}},Nu,Nv} <: ParametricSurface{T,N}\n\nEither a Zernike (circular) or Chebyshev (rectangular) surface with grid sag height added to the base sag. The surface shape is determined by either a linear or a bicubic spline interpolation of the Nu×Nv grid of sag values, set by the interpolation argument taking either GridSagLinear or GridSagBicubic.\n\nEach entry in the grid is a vector of the form z fracpartial zpartial x fracpartial zpartial y fracpartial^2 zpartial x partial y. The first data item corresponds to the lower left corner of the surface, that is, the corner defined by the -u and -v limit. Each point that follows is read across the face of the surface from left to right moving upwards. If zero is given for the partials (and using bicubic interpolation) then the partials will be approximated using finite differences.\n\nThe sag grid can be decentered from the surface in uv space, if so the surface may become wild outside of the area over which the grid is defined. It is advised to clip the surface to the valid area using CSG operations in this case.\n\nA surface can also be generated from a .GRD file by passing in the filename as the first and only positional argument. In this case the surface will be rectangular with optional radius and conic.\n\nSee docs for ZernikeSurface and ChebyshevSurface for details of the base surface.\n\nGridSagSurface(basesurface::Union{ZernikeSurface{T,N},ChebyshevSurface{T,N}}, sag_grid::AbstractArray{T,3}; interpolation = GridSagBicubic, decenteruv = (0, 0))\nGridSagSurface{T}(filename::String; radius = Inf, conic = 0, interpolation = GridSagBicubic)\n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.Hexagon","page":"Reference","title":"OpticSim.Hexagon","text":"Hexagon{T} <: Surface{T}\n\nHexagonal surface, not a valid CSG object. The rotation of the hexagon around its normal is defined by rotationvec. rotationvec×surfacenormal is taken as the vector along the u axis.\n\nHexagon(side_length::T, [surfacenormal::SVector{3,T}, centrepoint::SVector{3,T}]; rotationvec::SVector{3,T} = [0.0, 1.0, 0.0], interface::NullOrFresnel{T} = nullinterface(T))\n\nThe minimal case returns a rectangle centered at the origin with surfacenormal = [0, 0, 1].\n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.HierarchicalImage","page":"Reference","title":"OpticSim.HierarchicalImage","text":"HierarchicalImage{T<:Number} <: AbstractArray{T,2}\n\nImage type which dynamically allocated memory for pixels when their value is set, the value of unset pixels is assumed to be zero.\n\nThis is used for the detector image of AbstractOpticalSystems which can typically be very high resolution, but often have a large proportion of the image blank.\n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.HologramInterface","page":"Reference","title":"OpticSim.HologramInterface","text":"HologramInterface{T} <: OpticalInterface{T}\n\nInterface representing a thick hologram (though geometrically thin). The efficiency, η, is calculated using Kogelnik's coupled wave theory so is only valid for the first order. If the zero order is included then it has efficiency 1 - η. Also assumes that the HOE was recorded under similar conditions to the playback conditions, thickness is in microns.\n\nBeatState arguments can be one of ConvergingBeam, DivergingBeam and CollimatedBeam. In the first two cases signalpointordir and referencepointordir are 3D point in global coordinate space. For CollimatedBeam they are normalized direction vectors.\n\nFor reference, see:\n\nCoupled Wave Theory for Thick Hologram Gratings - H Kogelnik, 1995\nSequential and non-sequential simulation of volume holographic gratings - M Kick et al, 2018\n\nHologramInterface(signalpointordir::SVector{3,T}, signalbeamstate::BeamState, referencepointordir::SVector{3,T}, referencebeamstate::BeamState, recordingλ::T, thickness::T, beforematerial, substratematerial, aftermaterial, signalrecordingmaterial, referencerecordingmaterial, RImodulation::T, include0order  = false)\n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.HologramSurface","page":"Reference","title":"OpticSim.HologramSurface","text":"HologramSurface{T,S} <: WrapperSurface{T,S}\n\nSurface type for use with HologramInterface.\n\nHologramSurface(surface::Surface{T}, interface::HologramInterface{T})\n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.InfiniteStop","page":"Reference","title":"OpticSim.InfiniteStop","text":"InfiniteStop{T,P<:StopShape} <: Surface{T}\n\nStop surface with infinite extent (outside of the aperture). P refers to the shape of the aperture.\n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.Infinity","page":"Reference","title":"OpticSim.Infinity","text":"Infinity{T} <: IntervalPoint{T}\n\nPoint representing ∞ within an Interval.\n\nInfinity(T = Float64)\nInfinity{T}()\n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.InterfaceMode","page":"Reference","title":"OpticSim.InterfaceMode","text":"Valid modes for deterministic raytracing\n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.Intersection","page":"Reference","title":"OpticSim.Intersection","text":"Intersection{T,N} <: IntervalPoint{T}\n\nRepresents the point at which an Ray hits a Surface. This consists of the distance along the ray, the intersection point in world space, the normal in world space, the UV on the surface and the OpticalInterface hit.\n\nHas the following accessor methods:\n\npoint(a::Intersection{T,N}) -> SVector{N,T}\nnormal(a::Intersection{T,N}) -> SVector{N,T}\nuv(a::Intersection{T,N}) -> SVector{2,T}\nu(a::Intersection{T,N}) -> T\nv(a::Intersection{T,N}) -> T\nα(a::Intersection{T,N}) -> T\ninterface(a::Intersection{T,N}) -> OpticalInterface{T}\nflippednormal(a::Intersection{T,N}) -> Bool\n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.Interval","page":"Reference","title":"OpticSim.Interval","text":"Interval{T} <: AbstractRayInterval{T}\n\nDatatype representing an interval between two IntervalPoints on a ray.\n\nThe lower element can either be RayOrigin or an Intersection. The upper element can either be an Intersection or Infinity.\n\npositivehalfspace(int::Intersection) -> Interval with lower = int, upper = Infinity\nrayorigininterval(int::Intersection) -> Interval with lower = RayOrigin, upper = int\nInterval(low, high)\n\nHas the following accessor methods:\n\nlower(a::Interval{T}) -> Union{RayOrigin{T},Intersection{T,3}}\nupper(a::Interval{T}) -> Union{Intersection{T,3},Infinity{T}}\n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.KnotVector","page":"Reference","title":"OpticSim.KnotVector","text":"KnotVector{T<:Number}\n\nVector to define knots used for BSplineCurve and BSplineSurface.\n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.LensAssembly","page":"Reference","title":"OpticSim.LensAssembly","text":"LensAssembly{T<:Real}\n\nStructure which contains the elements of the optical system, these can be CSGTree or Surface objects.\n\nIn order to prevent type ambiguities bespoke structs are created for each possible number of elements e.g. LensAssembly3. These are parameterized by the types of the elements to prevent ambiguities. Basic surface types such as Rectangle (which can occur in large numbers) are stored independently in Vectors, so type parameters are only needed for CSG objects.\n\nEach struct looks like this:\n\nstruct LensAssemblyN{T,T1,T2,...,TN} <: LensAssembly{T}\n    axis::SVector{3,T}\n    rectangles::Vector{Rectangle{T}}\n    ellipses::Vector{Ellipse{T}}\n    hexagons::Vector{Hexagon{T}}\n    paraxials::Vector{ParaxialLens{T}}\n    E1::T1\n    E2::T2\n    ...\n    EN::TN\nend\n\nWhere Ti <: Union{Surface{T},CSGTree{T}}.\n\nTo create a LensAssembly object the following functions can be used:\n\nLensAssembly(elements::Vararg{Union{Surface{T},CSGTree{T},LensAssembly{T}}}; axis = SVector(0.0, 0.0, 1.0)) where {T<:Real}\n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.LensTrace","page":"Reference","title":"OpticSim.LensTrace","text":"LensTrace{T<:Real,N}\n\nContains an intersection point and the ray segment leading to it from within an optical trace. The ray carries the path length, power, wavelength, number of intersections and source number, all of which are accessible directly on this class too.\n\nHas the following accessor methods:\n\nray(a::LensTrace{T,N}) -> OpticalRay{T,N}\nintersection(a::LensTrace{T,N}) -> Intersection{T,N}\npower(a::LensTrace{T,N}) -> T\nwavelength(a::LensTrace{T,N}) -> T\npathlength(a::LensTrace{T,N}) -> T\npoint(a::LensTrace{T,N}) -> SVector{N,T}\nuv(a::LensTrace{T,N}) -> SVector{2,T}\nsourcenum(a::LensTrace{T,N}) -> Int\nnhits(a::LensTrace{T,N}) -> Int\n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.NullInterface","page":"Reference","title":"OpticSim.NullInterface","text":"NullInterface{T} <: OpticalInterface{T}\n\nInterface which will be ignored totally by any rays, used only in construction of CSG objects.\n\nNullInterface(T = Float64)\nNullInterface{T}()\n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.OpticalInterface","page":"Reference","title":"OpticSim.OpticalInterface","text":"OpticalInterface{T<:Real}\n\nAny subclass of OpticalInterface must implement the following:\n\nprocessintersection(opticalinterface::OpticalInterface{T}, point::SVector{N,T}, normal::SVector{N,T}, incidentray::OpticalRay{T,N}, temperature::T, pressure::T, ::Bool, firstray::Bool = false) -> Tuple{SVector{N,T}, T, T}\ninsidematerial(i::OpticalInterface{T}) -> AGFFileReader.AbstractGlass\noutsidematerial(i::OpticalInterface{T}) -> AGFFileReader.AbstractGlass\nreflectance(i::OpticalInterface{T}) -> T\ntransmission(i::OpticalInterface{T}) -> T\n\nSee documentation for processintersection for details.\n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.OpticalRay","page":"Reference","title":"OpticSim.OpticalRay","text":"OpticalRay{T,N} <: AbstractRay{T,N}\n\nRay with power, wavelength and optical path length.\n\nNOTE: we use monte carlo integration to get accurate results on the detector, this means that all rays essentially hit the detector with power = 1 and some rays are thrown away at any interface to correctly match the reflection/transmission at that interface. For inspection purposes we also track the 'instantaneous' power of the ray in the power field of the OpticalRay.\n\nOpticalRay(ray::Ray{T,N}, power::T, wavelength::T, opl=zero(T))\nOpticalRay(origin::SVector{N,T}, direction::SVector{N,T}, power::T, wavelength::T, opl=zero(T))\n\nHas the following accessor methods:\n\nray(r::OpticalRay{T,N}) -> Ray{T,N}\ndirection(r::OpticalRay{T,N}) -> SVector{N,T}\norigin(r::OpticalRay{T,N}) -> SVector{N,T}\npower(r::OpticalRay{T,N}) -> T\nwavelength(r::OpticalRay{T,N}) -> T\npathlength(r::OpticalRay{T,N}) -> T\nsourcepower(r::OpticalRay{T,N}) -> T\nnhits(r::OpticalRay{T,N}) -> Int\nsourcenum(r::OpticalRay{T,N}) -> Int\n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.OpticalRayGenerator","page":"Reference","title":"OpticSim.OpticalRayGenerator","text":"OpticalRayGenerator{T} <: AbstractRayGenerator{T}\n\nGenerates OpticalRays according to the specific implementation of the subclass.\n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.ParametricSurface","page":"Reference","title":"OpticSim.ParametricSurface","text":"ParametricSurface{T,N} <: Surface{T}\n\nT is the number type used to represent the surface, e.g., Float64. N is the dimension of the space the surface is embedded in. ParametricSurfaces are valid CSG objects, in some cases (where analytic intersection isn't possible) they must be wrapped in an AcceleratedParametricSurface for use.\n\nMust implement the following:\n\nuv(surface::ParametricSurface{T,N}, p::SVector{N,T}) -> SVector{2,T}\nuvrange(surface::ParametricSurface{T,N}) -> Tuple{Tuple{T,T},Tuple{T,T}}\npoint(surface::ParametricSurface{T,N}, u::T, v::T) -> SVector{N,T}\npartials(surface::ParametricSurface{T,N}, u::T, v::T) -> Tuple{SVector{N,T}, SVector{N,T}}\nnormal(surface::ParametricSurface{T,N}, u::T, v::T) -> SVector{N,T}\ninside(surface::ParametricSurface{T,N}, p: :SVector{N,T}) -> Bool\nonsurface(surface::ParametricSurface{T,N}, p::SVector{N,T}) -> Bool\nsurfaceintersection(surface::ParametricSurface{T,N}, AbstractRay::Ray{T,N}) -> Union{EmptyInterval{T},Interval{T},DisjointUnion{T}}\ninterface(surface::ParametricSurface{T,N}) -> OpticalInterface{T}\n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.ParaxialInterface","page":"Reference","title":"OpticSim.ParaxialInterface","text":"ParaxialInterface{T} <: OpticalInterface{T}\n\nInterface describing an idealized planar lens, i.e. one that is thin and with no aberrations.\n\nIn general this interface should not be constructed directly, the ParaxialLensEllipse and ParaxialLensRect functions should be used to create a ParaxialLens object directly.\n\nParaxialInterface(focallength::T, centroid::SVector{3,T}, outsidematerial::Y)\n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.ParaxialLens","page":"Reference","title":"OpticSim.ParaxialLens","text":"ParaxialLens{T} <: Surface{T}\n\nsurfacenormal is the output direction of the lens. Paraxial lens cannot act as the interface between two materials, hence only a single outside material is specified, by default Air.\n\nCreate with the following functions\n\nParaxialLensEllipse(focaldistance, halfsizeu, halfsizev, surfacenormal, centrepoint; rotationvec = [0.0, 1.0, 0.0], outsidematerial = AGFFileReader.Air, decenteruv = (0.0, 0.0))\nParaxialLensRect(focaldistance, halfsizeu, halfsizev, surfacenormal, centrepoint; rotationvec = [0.0, 1.0, 0.0], outsidematerial = AGFFileReader.Air, decenteruv = (0.0, 0.0))\nParaxialLensHex(focaldistance, side_length, surfacenormal, centrepoint; rotationvec = [0.0, 1.0, 0.0], outsidematerial = AGFFileReader.Air, decenteruv = (0.0, 0.0))\nParaxialLensConvexPoly(focaldistance, local_frame, local_polygon_points, local_center_point; outsidematerial = AGFFileReader.Air)\n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.Plane","page":"Reference","title":"OpticSim.Plane","text":"Plane{T,N} <: ParametricSurface{T,N}\n\nInfinite planar surface where the positive normal side is outside the surface.\n\nBy default this will not create any geometry for visualization, the optional vishalfsizeu and vishalfsizev arguments can be used to draw the plane as a rectangle for visualization note that this does not fully represent the surface. In this case, the rotation of the rectangle around the normal to the plane is defined by visvec - surfacenormal×visvec is taken as the vector along the u axis.\n\nPlane(surfacenormal::SVector{N,T}, pointonplane::SVector{N,T}; interface::NullOrFresnel{T} = nullinterface(T), vishalfsizeu::T = 0.0, vishalfsizev::T = 0.0, visvec::SVector{N,T} = [0.0, 1.0, 0.0])\nPlane(nx::T, ny::T, nz::T, x::T, y::T, z::T; interface::NullOrFresnel{T} = nullinterface(T), vishalfsizeu::T = 0.0, vishalfsizev::T = 0.0, visvec::SVector{N,T} = [0.0, 1.0, 0.0])\n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.QTypeSurface","page":"Reference","title":"OpticSim.QTypeSurface","text":"QTypeSurface{T,D,M,N} <: ParametricSurface{T,D}\n\nSurface incorporating the QType polynomials - radius and conic are defined relative to absolute semi-diameter, QType terms are normalized according to the normradius parameter. T is the datatype, D is the dimensionality, M and N are the maximum QType terms used.\n\nThe surface is centered at the origin and treated as being the cap of an infinite cylinder, thus creating a true half-space. Outside of 0 <= ρ <= 1 the height of the surface is not necessarily well defined, so NaN may be returned.\n\nQTypeSurface(semidiameter; radius = Inf, conic = 0.0, αcoeffs = nothing, βcoeffs = nothing, normradius = semidiameter)\n\nαcoeffs and βcoeffs should be a vector of tuples of the form (m, n, v) where v is the value of the coefficient α_n^m or β_n^m respectively.\n\nThe sag is defined by the equation\n\nbeginaligned\nz(rphi) =  fraccr^21 + sqrt1 - (1+k)c^2r^2 + fracsqrt1 + kc^2r^2sqrt1-(1+k)c^2r^2 cdot \n              left rho^2(1-rho^2)sum_n=0^Nalpha_n^0 Q_n^0 (rho^2) + sum_m=1^Mrho^msum_n=0^N left alpha_n^mcosmphi +beta_n^msinmphirightQ_n^m(rho^2) right\nendaligned\n\nwhere rho = fracrtextttnormradius, c = frac1textttradius, k = textttconic and Q_n^m is the QType polynomial index m, n.\n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.Ray","page":"Reference","title":"OpticSim.Ray","text":"Ray{T,N} <: AbstractRay{T,N}\n\nPurely geometric ray, defined as origin + alpha * direction.\n\nRay(origin::SVector{N,T}, direction::SVector{N,T})\n\nHas the following accessor methods:\n\ndirection(ray::Ray{T,N}) -> SVector{N,T}\norigin(ray::Ray{T,N}) -> SVector{N,T}\n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.RayOrigin","page":"Reference","title":"OpticSim.RayOrigin","text":"RayOrigin{T} <: IntervalPoint{T}\n\nPoint representing 0 within an Interval, i.e. the start of the ray.\n\nRayOrigin(T = Float64)\nRayOrigin{T}()\n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.Rectangle","page":"Reference","title":"OpticSim.Rectangle","text":"Rectangle{T} <: Surface{T}\n\nRectangular surface, not a valid CSG object. The rotation of the rectangle around its normal is defined by rotationvec. rotationvec×surfacenormal is taken as the vector along the u axis.\n\nCan be used as a detector in AbstractOpticalSystems.\n\nRectangle(halfsizeu::T, halfsizev::T, [surfacenormal::SVector{3,T}, centrepoint::SVector{3,T}]; rotationvec::SVector{3,T} = [0.0, 1.0, 0.0], interface::NullOrFresnel{T} = nullinterface(T))\n\nThe minimal case returns a rectangle centered at the origin with surfacenormal = [0, 0, 1].\n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.Sphere","page":"Reference","title":"OpticSim.Sphere","text":"Sphere{T,N} <: ParametricSurface{T,N}\n\nSpherical surface centered at the origin.\n\nSphere(radius::T = 1.0; interface::NullOrFresnel{T} = nullinterface(T))\n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.SphericalCap","page":"Reference","title":"OpticSim.SphericalCap","text":"SphericalCap{T} <: ParametricSurface{T}\n\nSpherical cap surface, creates a half-space which is essentially the subtraction of a sphere from an infinite plane. Only the spherical cap itself is visualized, not the plane. The positive normal side is outside the surface.\n\nCan be used as a detector in AbstractOpticalSystems.\n\nSphericalCap(radius::T, ϕmax::T, [surfacenormal::SVector{3,T}, centrepoint::SVector{3,T}]; interface::NullOrFresnel{T} = nullinterface(T))\n\nThe minimal case returns a spherical cap centered at the origin with surfacenormal = [0, 0, 1].\n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.SphericalPolygon","page":"Reference","title":"OpticSim.SphericalPolygon","text":"SphericalPolygon uses StaticArrays to represent vertices. Expect performance degradation for polygons with large numbers of vertices. Performance appears to be good up to perhaps 100 vertices, perhaps as much as 1000 vertices. By 10,000 vertices performance is terrible.\n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.Spline","page":"Reference","title":"OpticSim.Spline","text":"Spline{P<:CurveType,S<:Number,N,M}\n\nM is the curve order, i.e., the highest power of the parameterizing variable, u. P determines the CurveType.\n\nAll Spline types must implement:\n\npoint(curve,u)\n\nand have field controlpolygon\n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.SplineSurface","page":"Reference","title":"OpticSim.SplineSurface","text":"SplineSurface{P,S,N,M} <: ParametricSurface{S,N}\n\nCurve order, M, is the same in the u and v direction and fixed over all spans. P determines the CurveType.\n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.Surface","page":"Reference","title":"OpticSim.Surface","text":"Surface{T<:Real}\n\nT is the number type used to represent the surface, e.g., Float64. Basic Surfaces are not valid CSG objects, they function only in a stand-alone capacity.\n\nMust implement the following:\n\nsurfaceintersection(surface::Surface{T}, ray::AbstractRay{T,3}) -> Union{EmptyInterval{T},Interval{T}}\nnormal(surface::Surface{T}) -> SVector{3,T}\ninterface(surface::Surface{T}) -> OpticalInterface{T}\nmakemesh(surface::Surface{T}) -> TriangleMesh{T}\n\nIn a conventional ray tracer the surface intersection function would only return the first surface the ray intersects. Because our ray tracer does CSG operations the surface intersection function intersects the ray with all leaf surfaces which are part of the CSG tree. \n\nEach leaf surface returns one or more 1D intervals along the ray. These intervals contain the part of the ray which is inside the surface. The intervals computed at the leaves are propagated upward through the CSG tree and the CSG operations of union, intersection, and difference are applied to generate new intervals which are themselves propagated upward.\n\nThe result is a union of 1D intervals, which may be disjoint, a single interval, or empty. The union of intervals represents the parts of the ray which are inside the CSG object.\n\nInside is well defined for halfspaces such as cylinders and spheres which divide space into two parts, but not for Bezier or NURBS patches which generally do not enclose a volume.  For surfaces which are not halfspaces the notion of inside is defined locally by computing the angle between the incoming ray and the normal of the surface at the point of intersection. All surfaces must be defined so that the normal points to the outside of the surface. \n\nA negative dot product between the incoming ray and the normal indicates the ray is coming from the outside of the surface and heading toward the inside. A positive dot product indicates the ray is coming from the inside of the surface and heading toward the outside.\n\nIntervals are defined along the ray which is being intersected with the surface, so they are one dimensional. For example, assume we have a ray with origin o on the outside of a plane and an intersection with the plane at point int = o + td where t is a scalar and d is the unit direction of the ray. The inside interval will be (Intersection(t),Infinity). This interval begins at the intersection point on the plane and continues to positive infinity. The Intersection struct stores both the parametric value t and the 3D point of intersection to make various operations more efficient. But the interval operations only depend on the parametric value t.\n\nIf the origin o is on the inside of the plane then the inside interval will be (RayOrigin,Intersection(t)). Only the part of the ray from the ray origin to the intersection point is inside the plane. \n\nIt is the programmer's responsibility to return Interval results from surfaceintersection that maintain these properties.\n\nThe following must be implemented only if the surface is being used as a detector\n\nuv(surface::Surface{T}, p::SVector{3,T}) -> SVector{2,T}\nuvtopix(surface::Surface{T}, uv::SVector{2,T}, imsize::Tuple{Int,Int}) -> Tuple{Int,Int}\nonsurface(surface::Surface{T}, p::SVector{3,T}) -> Bool\n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.ThinGratingInterface","page":"Reference","title":"OpticSim.ThinGratingInterface","text":"ThinGratingInterface{T} <: OpticalInterface{T}\n\nInterface representing an idealized thin grating. period is in microns, vector should lie in the plane of the surface. Transmission and reflectance can be specified for an arbitrary number of orders up to 10, selected using the maxorder and minorder parameters. If nothing then reflectance is assumed to be 0 and transmission is assumed to be 1.\n\nThinGratingInterface(vector, period, insidematerial, outsidematerial; maxorder = 1, minorder = -1, reflectance = nothing, transmission = nothing)\n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.ThinGratingSurface","page":"Reference","title":"OpticSim.ThinGratingSurface","text":"ThinGratingSurface{T,S} <: WrapperSurface{T,S}\n\nSurface type for use with ThinGratingInterface.\n\nThinGratingSurface(surface::Surface{T}, interface::ThinGratingInterface{T})\n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.Triangle","page":"Reference","title":"OpticSim.Triangle","text":"Triangle{T} <: Surface{T}\n\nTriangular surface, not a valid CSG object. Primarily used as a component part of TriangleMesh or to enable intersection of AcceleratedParametricSurfaces. Can never be used directly as an optical surface as it doesn't have an OpticalInterface.\n\nTriangle(v1::SVector{3,T}, v2::SVector{3,T}, v3::SVector{3,T}, [uv1::SVector{2,T}, uv2::SVector{2,T}, uv3::SVector{2,T}])\n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.TriangleMesh","page":"Reference","title":"OpticSim.TriangleMesh","text":"TriangleMesh{T} <: Surface{T}\n\nAn array of Triangles forming a mesh. Used for visualization purposes only.\n\nTriangleMesh(tris::Vector{Triangle{T}})\n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.WrapperSurface","page":"Reference","title":"OpticSim.WrapperSurface","text":"WrapperSurface{T,S<:Surface{T}} <: Surface{T}\n\nA generic surface type which serves as a basis for extension of Surfaces for custom OpticalInterface subclasses. Essentially just forwards all Surface and ParametricSurface methods to a field of the WrapperSurface named surface. Also provides a generic implementation of surfaceintersection which tests for an intersection with the underlying surface and returns either an EmptyInterval or a half space (never a closed interval).\n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.ZernikeIndexType","page":"Reference","title":"OpticSim.ZernikeIndexType","text":"Either ZernikeIndexingOSA or ZernikeIndexingNoll, see Zernike polynomials wikipedia entry for details.\n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.ZernikeSurface","page":"Reference","title":"OpticSim.ZernikeSurface","text":"ZernikeSurface{T,N,P,Q,M} <: ParametricSurface{T,N}\n\nSurface incorporating the Zernike polynomials - radius, conic and aspherics are defined relative to absolute semi-diameter, Zernike terms are normalized according to the normradius parameter. T is the datatype, N is the dimensionality, P is the number of Zernike terms, Q is the number of aspheric terms and M is the Aspheric Type.\n\nThe surface is centered at the origin and treated as being the cap of an infinite cylinder, thus creating a true half-space. Outside of 0 <= ρ <= 1 the height of the surface is not necessarily well defined, so NaN may be returned.\n\nFor convenience the input zcoeff can be indexed using either OSA or Noll convention, indicated using the indexing argument as either ZernikeIndexingOSA or ZernikeIndexingNoll.\n\nZernikeSurface(semidiameter, radius = Inf, conic = 0, zcoeff = nothing, aspherics = nothing, normradius = semidiameter, indexing = ZernikeIndexingOSA)\n\nzcoeff and aspherics should be vectors containing tuples of the form (i, v) where i is either the index of the Zernike term for the corresponding indexing, or the polynomial power of the aspheric term (may be even or odd) and  v is the corresponding coefficient A_i or alpha_i respectively..  M will be determined from the terms entered to optimize the evaluation of the aspheric polynomial.\n\nThe sag is defined by the equation\n\nz(rphi) = fraccr^21 + sqrt1 - (1+k)c^2r^2 + sum_i^Qalpha_ir^2i + sum_i^PA_iZ_i(rho phi)\n\nwhere rho = fracrtextttnormradius, c = frac1textttradius, k = textttconic and Z_n is the nᵗʰ Zernike polynomial.\n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.Annulus-Union{Tuple{T}, Tuple{T, T, StaticArraysCore.SVector{3, T}, StaticArraysCore.SVector{3, T}}} where T<:Real","page":"Reference","title":"OpticSim.Annulus","text":"Annulus(innerradius::T, outerradius::T, surfacenormal::SVector{3,T}, centrepoint::SVector{3,T})\n\nCreates a circular aperture in a circle i.e. FiniteStop{T,CircularStopShape,CircularStopShape}.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.AsphericLens-Union{Tuple{S}, Tuple{T}, Tuple{Q}, Tuple{R}, Tuple{T, S, S, S, Union{Nothing, Array{Pair{Int64, S}, 1}}, S, S, Union{Nothing, Array{Pair{Int64, S}, 1}}, S, S}} where {R<:AbstractGlass, Q<:AbstractGlass, T<:AbstractGlass, S<:Real}","page":"Reference","title":"OpticSim.AsphericLens","text":"AsphericLens(insidematerial, frontvertex, frontradius, frontconic, frontaspherics, backradius, backconic, backaspherics, thickness, semidiameter;  lastmaterial = AGFFileReader.Air, nextmaterial = AGFFileReader.Air, frontsurfacereflectance = 0.0, backsurfacereflectance = 0.0, frontdecenter = (0, 0), backdecenter = (0, 0), interfacemode = ReflectOrTransmit)\n\nCosntructs a simple cylindrical lens with front and back surfaces with a radius, conic and apsheric terms. The side walls of the lens are absorbing.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.BoundedCylinder-Union{Tuple{T}, Tuple{T, T}} where T<:Real","page":"Reference","title":"OpticSim.BoundedCylinder","text":"BoundedCylinder(radius::T, height::T; interface::NullOrFresnel{T} = nullinterface(T)) -> CSGGenerator{T}\n\nCreate a cylinder with planar caps on both ends centered at (0, 0, 0) with axis (0, 0, 1).\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.Circle-Union{Tuple{T}, Tuple{T, StaticArraysCore.SVector{3, T}, StaticArraysCore.SVector{3, T}}} where T<:Real","page":"Reference","title":"OpticSim.Circle","text":"Circle(radius, [surfacenormal, centrepoint]; interface = nullinterface(T))\n\nShortcut method to create a circle. The minimal case returns a circle centered at the origin with normal = [0, 0, 1].\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.CircularAperture-Union{Tuple{T}, Tuple{T, StaticArraysCore.SVector{3, T}, StaticArraysCore.SVector{3, T}}} where T<:Real","page":"Reference","title":"OpticSim.CircularAperture","text":"CircularAperture(radius::T, surfacenormal::SVector{3,T}, centrepoint::SVector{3,T})\n\nCreates a circular aperture in a plane i.e. InfiniteStop{T,CircularStopShape}.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.CircularAperture-Union{Tuple{T}, Tuple{T, T, T, StaticArraysCore.SVector{3, T}, StaticArraysCore.SVector{3, T}}} where T<:Real","page":"Reference","title":"OpticSim.CircularAperture","text":"CircularAperture(radius::T, outerhalfsizeu::T, outerhalfsizev::T, surfacenormal::SVector{3,T}, centrepoint::SVector{3,T}; rotationvec::SVector{3,T} = [0.0, 1.0, 0.0])\n\nCreates a circular aperture in a rectangle i.e. FiniteStop{T,CircularStopShape,RectangularStopShape}. The rotation of the rectangle around its normal is defined by rotationvec. rotationvec×surfacenormal is taken as the vector along the u axis.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.ConicLens-Union{Tuple{S}, Tuple{T}, Tuple{Q}, Tuple{R}, Tuple{T, Vararg{S, 7}}} where {R<:AbstractGlass, Q<:AbstractGlass, T<:AbstractGlass, S<:Real}","page":"Reference","title":"OpticSim.ConicLens","text":"ConicLens(insidematerial, frontvertex, frontradius, frontconic, backradius, backconic, thickness, semidiameter;  lastmaterial = AGFFileReader.Air, nextmaterial = AGFFileReader.Air, frontsurfacereflectance = 0.0, backsurfacereflectance = 0.0, frontdecenter = (0, 0), backdecenter = (0, 0), interfacemode = ReflectOrTransmit)\n\nConstructs a simple cylindrical lens with front and back surfaces with a radius and conic term. The side walls of the lens are absorbing.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.Cuboid-Union{Tuple{T}, Tuple{T, T, T}} where T<:Real","page":"Reference","title":"OpticSim.Cuboid","text":"Cuboid(halfsizex::T, halfsizey::T, halfsizez::T; interface::NullOrFresnel{T} = nullinterface(T)) -> CSGGenerator{T}\n\nCreate a cuboid centered at (0, 0, 0).\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.EvenAsphericSurface-Union{Tuple{T}, Tuple{T, T, T, Vector{T}}} where T<:Real","page":"Reference","title":"OpticSim.EvenAsphericSurface","text":"EvenAsphericSurface(semidiameter, curvature::T, conic::T, aspherics::Vector{T}; normradius::T=semidiameter)\n\nSurface incorporating an aspheric polynomial - radius, conic and aspherics are defined relative to absolute semi-diameter.\n\naspherics should be an array of the even coefficients of the aspheric polynomial starting with A2\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.FresnelLens-Union{Tuple{H}, Tuple{G}, Tuple{T}, Tuple{G, Vararg{T, 5}}} where {T<:Real, G<:AbstractGlass, H<:AbstractGlass}","page":"Reference","title":"OpticSim.FresnelLens","text":"Code does not work.\n\nFresnelLens(insidematerial, frontvertex, radius, thickness, semidiameter, groovedepth; conic = 0.0, aspherics = nothing, outsidematerial = AGFFileReader.Air)\n\nCreate a Fresnel lens as a CSG object, can be concave or convex. Groove positions are found iteratively based on groovedepth. For negative radii the vertex on the central surface is at frontvertex, so the total thickness of the lens is thickness + groovedepth. Aspherics currently not supported.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.HexagonalPrism-Union{Tuple{T}, Tuple{T, T}} where T<:Real","page":"Reference","title":"OpticSim.HexagonalPrism","text":"HexagonalPrism(side_length::T, visheight::T = 2.0; interface::NullOrFresnel{T} = nullinterface(T)) -> CSGGenerator{T}\n\nCreate an infinitely tall hexagonal prism with axis (0, 0, 1), the longer hexagon diameter is along the x axis. For visualization visheight is used, note that this does not fully represent the surface.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.OddAsphericSurface-Union{Tuple{T}, Tuple{T, T, T, Vector{T}}} where T<:Real","page":"Reference","title":"OpticSim.OddAsphericSurface","text":"OddAsphericSurface(semidiameter, curvature::T, conic::T, aspherics::Vector{T}; normradius::T=semidiameter)\n\nSurface incorporating an aspheric polynomial - radius, conic and aspherics are defined relative to absolute semi-diameter.\n\naspherics  should be an array of the odd coefficients of the aspheric polynomial starting with A1\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.OddEvenAsphericSurface-Union{Tuple{T}, Tuple{T, T, T, Vector{T}}} where T<:Real","page":"Reference","title":"OpticSim.OddEvenAsphericSurface","text":"OddEvenAsphericSurface(semidiameter, curvature::T, conic::T, aspherics::Vector{T}; normradius::T=semidiameter)\n\nSurface incorporating an aspheric polynomial - radius, conic and aspherics are defined relative to absolute semi-diameter.\n\naspherics should be an array of the both odd and even coefficients of the aspheric polynomial starting with A1\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.RectangularAperture-Union{Tuple{T}, Tuple{T, T, StaticArraysCore.SVector{3, T}, StaticArraysCore.SVector{3, T}}} where T<:Real","page":"Reference","title":"OpticSim.RectangularAperture","text":"RectangularAperture(aphalfsizeu::T, aphalfsizev::T, surfacenormal::SVector{3,T}, centrepoint::SVector{3,T}; rotationvec::SVector{3,T} = [0.0, 1.0, 0.0])\n\nCreates a rectangular aperture in a plane i.e. InfiniteStop{T,RectangularStopShape}. The rotation of the rectangle around its normal is defined by rotationvec. rotationvec×surfacenormal is taken as the vector along the u axis.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.RectangularAperture-Union{Tuple{T}, Tuple{T, T, T, T, StaticArraysCore.SVector{3, T}, StaticArraysCore.SVector{3, T}}} where T<:Real","page":"Reference","title":"OpticSim.RectangularAperture","text":"RectangularAperture(innerhalfsizeu::T, innerhalfsizev::T, outerhalfsizeu::T, outerhalfsizev::T, surfacenormal::SVector{3,T}, centrepoint::SVector{3,T}; rotationvec::SVector{3,T} = [0.0, 1.0, 0.0])\n\nCreates a rectangular aperture in a rectangle i.e. FiniteStop{T,RectangularStopShape,RectangularStopShape}. The rotation of the rectangle around its normal is defined by rotationvec. rotationvec×surfacenormal is taken as the vector along the u axis.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.RectangularPrism-Union{Tuple{T}, Tuple{T, T}, Tuple{T, T, T}} where T<:Real","page":"Reference","title":"OpticSim.RectangularPrism","text":"RectangularPrism(halfsizex::T, halfsizey::T, visheight::T=2.0; interface::NullOrFresnel{T} = nullinterface(T)) -> CSGGenerator{T}\n\nCreate an infinitely tall rectangular prism with axis (0, 0, 1). For visualization visheight is used, note that this does not fully represent the surface.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.SphericalLens-Union{Tuple{S}, Tuple{T}, Tuple{Q}, Tuple{R}, Tuple{T, Vararg{S, 5}}} where {R<:AbstractGlass, Q<:AbstractGlass, T<:AbstractGlass, S<:Real}","page":"Reference","title":"OpticSim.SphericalLens","text":"SphericalLens(insidematerial, frontvertex, frontradius, backradius, thickness, semidiameter;  lastmaterial = AGFFileReader.Air, nextmaterial = AGFFileReader.Air, frontsurfacereflectance = 0.0, backsurfacereflectance = 0.0, frontdecenter = (0, 0), backdecenter = (0, 0), interfacemode = ReflectOrTransmit)\n\nConstructs a simple cylindrical lens with spherical front and back surfaces. The side walls of the lens are absorbing.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.Spider-Union{Tuple{T}, Tuple{Int64, T, T}, Tuple{Int64, T, T, StaticArraysCore.SVector{3, T}}, Tuple{Int64, T, T, StaticArraysCore.SVector{3, T}, StaticArraysCore.SVector{3, T}}} where T<:Real","page":"Reference","title":"OpticSim.Spider","text":"Spider(narms::Int, armwidth::T, radius::T, origin::SVector{3,T} = SVector{3,T}(0.0, 0.0, 0.0), normal::SVector{3,T} = SVector{3,T}(0.0, 0.0, 1.0)) -> Vector{Rectangle{T}}\n\nCreates a 'spider' obscuration with narms rectangular arms evenly spaced around a circle defined by origin and normal. Each arm is a rectangle armwidth×radius.\n\ne.g. for 3 and 4 arms we get:\n\n   |         _|_\n  / \\         |\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.TriangularPrism-Union{Tuple{T}, Tuple{T, T}} where T<:Real","page":"Reference","title":"OpticSim.TriangularPrism","text":"TriangularPrism(side_length::T, visheight::T = 2.0; interface::NullOrFresnel{T} = nullinterface(T)) -> CSGGenerator{T}\n\nCreate an infinitely tall triangular prism with axis (0, 0, 1). For visualization visheight is used, note that this does not fully represent the surface.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.asphericType-Union{Tuple{AsphericSurface{T, 3, Q, M}}, Tuple{M}, Tuple{Q}, Tuple{T}} where {T<:Real, Q, M}","page":"Reference","title":"OpticSim.asphericType","text":"asphericType(surf::AsphericSurface)\n\nQuery the polynomial type of `asp.  Returns CONIC, ODD, EVEN, or ODDEVEN. CONIC corresponds to no aspheric terms, ODD  means it only has odd aspheric terms, EVEN means only even aspheric terms and ODDEVEN means both even and odd terms. \n\nThis function is to enable proper interpretation of surf.aspherics by any optimization routines that directly query the aspheric coefficients.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.assembly-Union{Tuple{CSGOpticalSystem{T, D, S, L} where {D<:Number, S<:Surface{T}, L<:LensAssembly{T}}}, Tuple{T}} where T<:Real","page":"Reference","title":"OpticSim.assembly","text":"assembly(system::AbstractOpticalSystem{T}) -> LensAssembly{T}\n\nGet the LensAssembly of system.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.closestintersection","page":"Reference","title":"OpticSim.closestintersection","text":"closestintersection(a::Union{EmptyInterval{T},Interval{T},DisjointUnion{T}}, ignorenull::Bool = true) -> Union{Nothing,Intersection{T,3}}\n\nReturns the closest Intersection from an Interval or DisjointUnion. Ignores intersection with null interfaces if ignorenull is true. Will return nothing if there is no valid intersection.\n\n\n\n\n\n","category":"function"},{"location":"ref/#OpticSim.closestpointonray-Union{Tuple{N}, Tuple{T}, Tuple{AbstractRay{T, N}, StaticArraysCore.SVector{N, T}}} where {T, N}","page":"Reference","title":"OpticSim.closestpointonray","text":"closestpointonray(r::Ray{T,N}, point::SVector{N,T}) -> SVector{T,N\n\nReturns the point on the ray closest to point.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.detectorimage-Tuple{CSGOpticalSystem}","page":"Reference","title":"OpticSim.detectorimage","text":"detectorimage(system::AbstractOpticalSystem{T}) -> HierarchicalImage{D}\n\nGet the detector image of system. D is the datatype of the detector image and is not necessarily the same as the datatype of the system T.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.distancefromplane-Tuple{OpticSim.PlanarShape, StaticArraysCore.SVector{3}}","page":"Reference","title":"OpticSim.distancefromplane","text":"All planar shapes lie on a plane. This function computes the distance from a point to that plane. This is a signed distance. If the point is on the positive side of the plane (the side the normal points toward) the distance will be positive, otherwise negative or 0 if the point lies in the plane.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.doesintersect-Union{Tuple{T}, Tuple{BoundingBox{T}, AbstractRay{T, 3}}} where T<:Real","page":"Reference","title":"OpticSim.doesintersect","text":"doesintersect(bbox::BoundingBox{T}, r::AbstractRay{T,3}) -> Bool\n\nTests whether r intersects an axis-aligned BoundingBox, bbox.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.inside-Union{Tuple{T}, Tuple{CSGTree{T}, T, T, T}} where T<:Real","page":"Reference","title":"OpticSim.inside","text":"inside(obj::CSGTree{T}, point::SVector{3,T}) -> Bool\ninside(obj::CSGTree{T}, x::T, y::T, z::T) -> Bool\n\nTests whether a 3D point in world space is inside obj.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.inside-Union{Tuple{T}, Tuple{ParametricSurface{T, 3}, T, T, T}} where T<:Real","page":"Reference","title":"OpticSim.inside","text":"inside(surf::ParametricSurface{T}, p::SVector{3,T}) -> Bool\ninside(surf::ParametricSurface{T}, x::T, y::T, z::T) -> Bool\n\nTests whether a 3D point in world space is inside surf.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.interface-Union{Tuple{AcceleratedParametricSurface{T, N, S} where {N, S<:ParametricSurface{T, N}}}, Tuple{T}} where T<:Real","page":"Reference","title":"OpticSim.interface","text":"interface(surf::Surface{T}) -> OpticalInterface{T}\n\nReturn the OpticalInterface associated with surf.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.intersections-Union{Tuple{N}, Tuple{T}, Tuple{AbstractRay{T, N}, Matrix{T}}} where {T<:Real, N}","page":"Reference","title":"OpticSim.intersections","text":"returns an array of intersection points. Each element in the array is ([x,y,...],alpha,theta) where [x,y,...] is the n-dimensional intersection point, alpha is the line parameter value at the intersection point, and theta is the curve parameter value at the intersection point\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.leaf-Union{Tuple{ParametricSurface{T}}, Tuple{T}, Tuple{ParametricSurface{T}, OpticSim.Geometry.Transform{T}}} where T<:Real","page":"Reference","title":"OpticSim.leaf","text":"leaf(surf::ParametricSurface{T}, transform::Transform{T} = identitytransform(T)) -> CSGGenerator{T}\n\nCreate a leaf node from a parametric surface with a given transform.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.makemesh-Union{Tuple{ConvexPolygon{N, T}}, Tuple{T}, Tuple{N}, Tuple{ConvexPolygon{N, T}, Int64}} where {N, T<:Real}","page":"Reference","title":"OpticSim.makemesh","text":"makemesh(poly::ConvexPolygon{N, T}, ::Int = 0) where {N, T<:Real} -> TriangleMesh\n\nCreate a triangle mesh that can be rendered by iterating on the polygon's edges and for each edge use the centroid as the third vertex of the triangle.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.makemesh-Union{Tuple{ParametricSurface{S, N}}, Tuple{N}, Tuple{S}, Tuple{ParametricSurface{S, N}, Int64}} where {S, N}","page":"Reference","title":"OpticSim.makemesh","text":"makemesh(object, subdivisions::Int = 30) -> TriangleMesh\n\nCreates a TriangleMesh from an object, either a ParametricSurface, CSGTree or certain surfaces (e.g. Circle, Rectangle). This is used for visualization purposes only.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.normal-Union{Tuple{T}, Tuple{ParametricSurface{T}, T, T}} where T<:Real","page":"Reference","title":"OpticSim.normal","text":"normal(surf::ParametricSurface{T}, u::T, v::T) -> SVector{3,T}\nnormal(surf::ParametricSurface{T}, uv::SVector{2,T}) -> SVector{3,T}\n\nReturns the normal to surf at the given uv coordinate.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.onsurface-Union{Tuple{T}, Tuple{CSGTree{T}, T, T, T}} where T<:Real","page":"Reference","title":"OpticSim.onsurface","text":"onsurface(obj::CSGTree{T}, point::SVector{3,T}) -> Bool\nonsurface(obj::CSGTree{T}, x::T, y::T, z::T) -> Bool\n\nTests whether a 3D point in world space is on the surface (i.e. shell) of obj.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.onsurface-Union{Tuple{T}, Tuple{ParametricSurface{T, 3}, T, T, T}} where T<:Real","page":"Reference","title":"OpticSim.onsurface","text":"onsurface(surf::ParametricSurface{T}, p::SVector{3,T}) -> Bool\nonsurface(surf::ParametricSurface{T}, x::T, y::T, z::T) -> Bool\n\nTests whether a 3D point in world space is on surf.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.partials-Union{Tuple{T}, Tuple{ParametricSurface{T}, T, T}} where T<:Real","page":"Reference","title":"OpticSim.partials","text":"partials(surf::ParametricSurface{T}, u::T, v::T) -> (SVector{3,T}, SVector{3,T})\npartials(surf::ParametricSurface{T}, uv::SVector{2,T}) -> (SVector{3,T}, SVector{3,T})\n\nReturns a tuple of the 3D partial derivatives of surf with respect to u and v at the given uv coordinate.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.point-Tuple{OpticSim.VirtualPoint}","page":"Reference","title":"OpticSim.point","text":"This will return (Inf,Inf,Inf) if the point is at infinity. In this case you probably should be using the direction of the VirtualPoint rather than its position\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.point-Union{Tuple{T}, Tuple{N}, Tuple{AbstractRay{T, N}, T}} where {N, T<:Real}","page":"Reference","title":"OpticSim.point","text":"point(ray::AbstractRay{T,N}, alpha::T) -> SVector{T, N}\n\nReturns a point on the ray at origin + alpha * direction. Alpha must be >= 0.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.point-Union{Tuple{T}, Tuple{N}, Tuple{Rectangle{T}, StaticArraysCore.SMatrix{2, N, T}}} where {N, T<:Real}","page":"Reference","title":"OpticSim.point","text":"returns a 3D point. This takes into account the offset of centerpoint and the rotation vector used to construct the Rectangle. u and v are scaled by the size of the rectangle so that u=0,v=0 is one corner and u=v=1 is the diagonal corner. This function should go away once we have a sensible object transform hierarchy system.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.point-Union{Tuple{T}, Tuple{ParametricSurface{T}, T, T}} where T<:Real","page":"Reference","title":"OpticSim.point","text":"point(surf::ParametricSurface{T}, u::T, v::T) -> SVector{3,T}\npoint(surf::ParametricSurface{T}, uv::SVector{2,T}) -> SVector{3,T}\n\nReturns the 3D point on surf at the given uv coordinate.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.point-Union{Tuple{T}, Tuple{Rectangle{T}, T, T}} where T<:Real","page":"Reference","title":"OpticSim.point","text":"returns a 3D point in the plane of the rectangle. This takes into account the offset of centerpoint and the rotation vector used to construct the Rectangle. u and v are scaled by the size of the rectangle so that u=0,v=0 is one corner and u=v=1 is the diagonal corner. This function should go away once we have a sensible object transform hierarchy system.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.pressure-Union{Tuple{CSGOpticalSystem{T, D, S, L} where {D<:Number, S<:Surface{T}, L<:LensAssembly{T}}}, Tuple{T}} where T<:Real","page":"Reference","title":"OpticSim.pressure","text":"pressure(system::AbstractOpticalSystem{T}) -> T\n\nGet the pressure of system in Atm.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.reset!-Union{Tuple{HierarchicalImage{T}}, Tuple{T}} where T","page":"Reference","title":"OpticSim.reset!","text":"reset!(a::HierarchicalImage{T})\n\nResets the pixels in the image to zero(T). Do this rather than image .= zero(T) because that will cause every pixel to be accessed, and therefore allocated. For large images this can cause huge memory traffic.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.resetdetector!-Union{Tuple{CSGOpticalSystem{T, D, S, L} where {D<:Number, S<:Surface{T}, L<:LensAssembly{T}}}, Tuple{T}} where T<:Real","page":"Reference","title":"OpticSim.resetdetector!","text":"resetdetector!(system::AbstractOpticalSystem{T})\n\nReset the deterctor image of system to zero.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.samplesurface-Union{Tuple{N}, Tuple{T}, Tuple{ParametricSurface{T, N}, Function}, Tuple{ParametricSurface{T, N}, Function, Int64}} where {T<:Real, N}","page":"Reference","title":"OpticSim.samplesurface","text":"samplesurface(surf::ParametricSurface{T,N}, samplefunction::Function, numsamples::Int = 30)\n\nSample a parametric surface on an even numsamples×numsamples grid in UV space with provided function\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.semidiameter-Tuple{AxisymmetricOpticalSystem}","page":"Reference","title":"OpticSim.semidiameter","text":"semidiameter(system::AxisymmetricOpticalSystem{T}) -> T\n\nGet the semidiameter of system, that is the semidiameter of the entrance pupil (i.e. first surface) of the system.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.sphericalcircle","page":"Reference","title":"OpticSim.sphericalcircle","text":"creates a circular polygon that subtends a half angle of θ\n\n\n\n\n\n","category":"function"},{"location":"ref/#OpticSim.sum!-Union{Tuple{T}, Tuple{HierarchicalImage{T}, HierarchicalImage{T}}} where T","page":"Reference","title":"OpticSim.sum!","text":"sum!(a::HierarchicalImage{T}, b::HierarchicalImage{T})\n\nAdd the contents of b to a in an efficient way.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.surfaceintersection-Union{Tuple{N}, Tuple{T}, Tuple{AcceleratedParametricSurface{T, N, S} where S<:ParametricSurface{T, N}, AbstractRay{T, N}}} where {T, N}","page":"Reference","title":"OpticSim.surfaceintersection","text":"surfaceintersection(surf::Surface{T}, r::AbstractRay{T}) where {T}\n\nCalculates the intersection of r with a surface of any type, surf. Note that some surfaces cannot be intersected analytically so must be wrapped in an AcceleratedParametricSurface in order to be intersected.\n\nReturns an EmptyInterval if there is no Intersection, an Interval if there is one or two intersections and a DisjointUnion if there are more than two intersections.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.surfaceintersection-Union{Tuple{N}, Tuple{T}, Tuple{CSGTree{T}, AbstractRay{T, N}}} where {T<:Real, N}","page":"Reference","title":"OpticSim.surfaceintersection","text":"surfaceintersection(obj::CSGTree{T}, r::AbstractRay{T,N})\n\nCalculates the intersection of r with CSG object, obj.\n\nReturns an EmptyInterval if there is no intersection, an Interval if there is one or two intersections and a DisjointUnion if there are more than two intersections.\n\nThe ray is intersected with the LeafNodes that make up the CSG object and the resulting Intervals and DisjointUnions are composed with the same boolean operations to give a final result. The ray is transformed by the inverse of the transform associated with the leaf node to put it in object space for that node before the intersection is carried out, typically this object space is centered at the origin, but may differ for each primitive.\n\nSome intersections are culled without actually evaluating them by first checking if the ray intersects the BoundingBox of each node in the CSGTree, this can substantially improve performance in some cases.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.surfaceintersection-Union{Tuple{T}, Tuple{BoundingBox{T}, AbstractRay{T, 3}}} where T<:Real","page":"Reference","title":"OpticSim.surfaceintersection","text":"surfaceintersection(bbox::BoundingBox{T}, r::AbstractRay{T,3}) -> Union{EmptyInterval{T},Interval{T}}\n\nCalculates the intersection of r with an axis-aligned BoundingBox, bbox.\n\nReturns an EmptyInterval if there is no intersection or an Interval if there is one or two intersections. Note that the uv of the returned intersection is always 0.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.temperature-Union{Tuple{CSGOpticalSystem{T, D, S, L} where {D<:Number, S<:Surface{T}, L<:LensAssembly{T}}}, Tuple{T}} where T<:Real","page":"Reference","title":"OpticSim.temperature","text":"temperature(system::AbstractOpticalSystem{T}) -> T\n\nGet the temperature of system in °C.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.trace-Union{Tuple{D}, Tuple{N}, Tuple{T}, Tuple{CSGOpticalSystem{T, D, S, L} where {S<:Surface{T}, L<:LensAssembly{T}}, OpticalRay{T, N}}} where {T<:Real, N, D<:Number}","page":"Reference","title":"OpticSim.trace","text":"trace(system::AbstractOpticalSystem{T}, ray::OpticalRay{T}; trackrays = nothing, test = false)\n\nTraces system with ray, if test is enabled then fresnel reflections are disabled and the power distribution will not be correct. Returns either a LensTrace if the ray hits the detector or nothing otherwise.\n\ntrackrays can be passed an empty vector to accumulate the LensTrace objects at each intersection of ray with a surface in the system.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.trace-Union{Tuple{N}, Tuple{T}, Tuple{LensAssembly{T}, OpticalRay{T, N}}, Tuple{LensAssembly{T}, OpticalRay{T, N}, T}, Tuple{LensAssembly{T}, OpticalRay{T, N}, T, T}} where {T<:Real, N}","page":"Reference","title":"OpticSim.trace","text":"trace(assembly::LensAssembly{T}, r::OpticalRay{T}, temperature::T = 20.0, pressure::T = 1.0; trackrays = nothing, test = false)\n\nReturns the ray as it exits the assembly in the form of a LensTrace object if it hits any element in the assembly, otherwise nothing. Recursive rays are offset by a small amount (RAY_OFFSET) to prevent it from immediately reintersecting the same lens element.\n\ntrackrays can be passed an empty vector to accumulate the LensTrace objects at each intersection of ray with a surface in the assembly.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.trace-Union{Tuple{T}, Tuple{CSGOpticalSystem{T, D, S, L} where {D<:Number, S<:Surface{T}, L<:LensAssembly{T}}, OpticalRayGenerator{T}}} where T<:Real","page":"Reference","title":"OpticSim.trace","text":"trace(system::AbstractOpticalSystem{T}, raygenerator::OpticalRayGenerator{T}; printprog = true, test = false)\n\nTraces system with rays generated by raygenerator on a single thread. Optionally the progress can be printed to the REPL. If test is enabled then fresnel reflections are disabled and the power distribution will not be correct. If outpath is specified then the result will be saved to this path.\n\nReturns the detector image of the system.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.traceMT-Union{Tuple{S}, Tuple{T}, Tuple{CSGOpticalSystem{T, S, S1, L} where {S1<:Surface{T}, L<:LensAssembly{T}}, OpticalRayGenerator{T}}} where {T<:Real, S<:Number}","page":"Reference","title":"OpticSim.traceMT","text":"traceMT(system::AbstractOpticalSystem{T}, raygenerator::OpticalRayGenerator{T}; printprog = true, test = false)\n\nTraces system with rays generated by raygenerator using as many threads as possible. Optionally the progress can be printed to the REPL. If test is enabled then fresnel reflections are disabled and the power distribution will not be correct. If outpath is specified then the result will be saved to this path.\n\nReturns the accumulated detector image from all threads.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.tracehits-Union{Tuple{T}, Tuple{CSGOpticalSystem{T, D, S, L} where {D<:Number, S<:Surface{T}, L<:LensAssembly{T}}, OpticalRayGenerator{T}}} where T<:Real","page":"Reference","title":"OpticSim.tracehits","text":"tracehits(system::AbstractOpticalSystem{T}, raygenerator::OpticalRayGenerator{T}; printprog = true, test = false)\n\nTraces system with rays generated by raygenerator on a single thread. Optionally the progress can be printed to the REPL. If test is enabled then fresnel reflections are disabled and the power distribution will not be correct.\n\nReturns a list of LensTraces which hit the detector.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.tracehitsMT-Union{Tuple{T}, Tuple{CSGOpticalSystem{T, D, S, L} where {D<:Number, S<:Surface{T}, L<:LensAssembly{T}}, OpticalRayGenerator{T}}} where T<:Real","page":"Reference","title":"OpticSim.tracehitsMT","text":"tracehitsMT(system::AbstractOpticalSystem{T}, raygenerator::OpticalRayGenerator{T}; printprog = true, test = false)\n\nTraces system with rays generated by raygenerator using as many threads as possible. Optionally the progress can be printed to the REPL. If test is enabled then fresnel reflections are disabled and the power distribution will not be correct.\n\nReturns a list of LensTraces which hit the detector, accumulated from all threads.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.triangulate-Union{Tuple{N}, Tuple{T}, Tuple{ParametricSurface{T, N}, Int64}, Tuple{ParametricSurface{T, N}, Int64, Bool}, Tuple{ParametricSurface{T, N}, Int64, Bool, Bool}, Tuple{ParametricSurface{T, N}, Int64, Bool, Bool, Bool}, Tuple{ParametricSurface{T, N}, Int64, Vararg{Bool, 4}}} where {T, N}","page":"Reference","title":"OpticSim.triangulate","text":"triangulate(surf::ParametricSurface{S,N}, quads_per_row::Int, extensionu::Bool = false, extensionv::Bool = false, radialu::Bool = false, radialv::Bool = false)\n\nCreate an array of triangles representing the parametric surface where vertices are sampled on an even grid in UV space. The surface can be extended by 1% in u and v separately, and specifying either u or v as being radial - i.e. determining the radius on the surface e.g. rho for zernike - will result in that dimension being sampled using sqwrt so that area of triangles is uniform. The extension will also only apply to the maximum in this case.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.uv-Union{Tuple{T}, Tuple{ParametricSurface{T, 3}, T, T, T}} where T<:Real","page":"Reference","title":"OpticSim.uv","text":"uv(surf::ParametricSurface{T}, p::SVector{3,T}) -> SVector{2,T}\nuv(surf::ParametricSurface{T}, x::T, y::T, z::T) -> SVector{2,T}\n\nReturns the uv coordinate on surf of a point, p, in 3D space. If onsurface(surf, p) is false then the behavior is undefined, it may return an inorrect uv, an invalid uv, NaN or crash.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.uvrange-Tuple{S} where S<:ParametricSurface","page":"Reference","title":"OpticSim.uvrange","text":"uvrange(s::ParametricSurface)\nuvrange(::Type{S}) where {S<:ParametricSurface}\n\nReturns a tuple of the form: ((umin, umax), (vmin, vmax)) specifying the limits of the parameterisation for this surface type. Also implemented for some Surfaces which are not ParametricSurfaces (e.g. Rectangle).\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.vertices-Tuple{OpticSim.PlanarShape}","page":"Reference","title":"OpticSim.vertices","text":"The vertices of planar shapes are defined in a plane so they are two dimensional. In the local coordinate frame this is the x,y plane, so the implied z coordinate is 0\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.vertices-Tuple{ParaxialLens}","page":"Reference","title":"OpticSim.vertices","text":"returns the 2 dimensional vertex points of the shape defining the lens aperture. These points lie in the plane of the shape\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.vertices-Union{Tuple{Rectangle{T}}, Tuple{T}, Tuple{Rectangle{T}, Int64}} where T<:Real","page":"Reference","title":"OpticSim.vertices","text":"returns the 2D vertices in the plane of the rectangle\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.vertices3d-Union{Tuple{Hexagon{T}}, Tuple{T}} where T<:Real","page":"Reference","title":"OpticSim.vertices3d","text":"Returns the vertices of the Hexagon represented in the local coordinate frame. The vertices lie in the z = 0 plane and are 2D\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.vertices3d-Union{Tuple{Rectangle{T}}, Tuple{T}, Tuple{Rectangle{T}, Int64}} where T<:Real","page":"Reference","title":"OpticSim.vertices3d","text":"returns the vertices of the rectangle in 3D\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.virtualpoint-Union{Tuple{T}, Tuple{ParaxialLens{T}, AbstractVector{T}}} where T","page":"Reference","title":"OpticSim.virtualpoint","text":"computes the virtual point position corresponding to the input point, or returns nothing for points at infinity. point is specified in the lens coordinate frame\n\n\n\n\n\n","category":"method"},{"location":"ref/#Optical-Emitters","page":"Reference","title":"Optical Emitters","text":"","category":"section"},{"location":"ref/#OpticSim.Emitters.apply","page":"Reference","title":"OpticSim.Emitters.apply","text":"apply(???)\n\n[TODO] Returns ray power\n\n\n\n\n\n","category":"function"},{"location":"ref/#OpticSim.Emitters.collimatedemitter-Union{Tuple{T}, Tuple{AbstractVector{T}, Any}} where T<:Real","page":"Reference","title":"OpticSim.Emitters.collimatedemitter","text":"collimatedemitter(origin::AbstractVector{T}, halfsquaresize; λ::Length = 500nm, numrays = 100) where {T<:Real}\n\nCreates a square collimated emitter, emitting rays in the -z direction. Rays are emitted on a square grid with sqrt(numrays) on a side. λ can be a unitful quantity, e.g., 550nm, or a number. In the latter case the units are implicitly microns.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.Emitters.generate","page":"Reference","title":"OpticSim.Emitters.generate","text":"generate(???)\n\n[TODO]\n\n\n\n\n\n","category":"function"},{"location":"ref/#OpticSim.Emitters.pointemitter-Union{Tuple{T}, Tuple{AbstractVector{T}, Any}} where T<:Real","page":"Reference","title":"OpticSim.Emitters.pointemitter","text":"pointemitter(origin::AbstractVector{T}, coneangle; λ::Length = 500nm, numrays = 100) where {T<:Real}\n\nCreates a point source with Lambertian emission power and cone distribution of rays, emitting in the -z direction. λ is a unitful Length quantity, e.g., 550nm.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.Emitters.visual_size","page":"Reference","title":"OpticSim.Emitters.visual_size","text":"visual_size(???)\n\n[TODO]\n\n\n\n\n\n","category":"function"},{"location":"ref/#OpticSim.Emitters.AngularPower.Cosine","page":"Reference","title":"OpticSim.Emitters.AngularPower.Cosine","text":"Cosine{T} <: AbstractAngularPowerDistribution{T}\n\nCosine power distribution. Ray power is calculated by:\n\npower = power * (cosine_angle ^ cosine_exp)\n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.Emitters.AngularPower.Gaussian","page":"Reference","title":"OpticSim.Emitters.AngularPower.Gaussian","text":"Gaussian{T} <: AbstractAngularPowerDistribution{T}\n\nGGaussian power distribution. Ray power is calculated by:\n\npower = power * exp(-(gaussianu * l^2 + gaussianv * m^2)) where l and m are the cos_angles between the two axes respectively.\n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.Emitters.AngularPower.Lambertian","page":"Reference","title":"OpticSim.Emitters.AngularPower.Lambertian","text":"Lambertian{T} <: AbstractAngularPowerDistribution{T}\n\nRay power is unaffected by angle.\n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.Emitters.Directions.Constant","page":"Reference","title":"OpticSim.Emitters.Directions.Constant","text":"Constant{T} <: AbstractDirectionDistribution{T}\n\nEncapsulates a single ray direction, where the default direction is unitZ3 [0, 0, 1].\n\nConstant(direction::Vec3{T}) where {T<:Real}\nConstant(::Type{T} = Float64) where {T<:Real}\n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.Emitters.Directions.HexapolarCone","page":"Reference","title":"OpticSim.Emitters.Directions.HexapolarCone","text":"HexapolarCone{T} <: AbstractDirectionDistribution{T}\n\nRays are generated by sampling a cone with θmax angle in an hexapolar fashion. The number of rays depends on the requested rings and is computed using the following formula: 1 + round(Int64, (nrings * (nrings + 1) / 2) * 6)\n\nHexapolarCone(direction::Vec3{T}, θmax::T, nrings::Int64) where {T<:Real}\nHexapolarCone(θmax::T, nrings::Int64 = 3) where {T<:Real}\n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.Emitters.Directions.RectGrid","page":"Reference","title":"OpticSim.Emitters.Directions.RectGrid","text":"RectGrid{T} <: AbstractDirectionDistribution{T}\n\nEncapsulates a single ray direction, where the default direction is unitZ3 [0, 0, 1].\n\nConstant(direction::Vec3{T}) where {T<:Real}\nConstant(::Type{T} = Float64) where {T<:Real}\n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.Emitters.Directions.UniformCone","page":"Reference","title":"OpticSim.Emitters.Directions.UniformCone","text":"UniformCone{T} <: AbstractDirectionDistribution{T}\n\nEncapsulates numsamples rays sampled uniformly from a cone with max angle θmax.\n\nUniformCone(direction::Vec3{T}, θmax::T, numsamples::Int64) where {T<:Real}\nUniformCone(θmax::T, numsamples::Int64) where {T<:Real}\n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.Emitters.Origins.Hexapolar","page":"Reference","title":"OpticSim.Emitters.Origins.Hexapolar","text":"Hexapolar{T} <: AbstractOriginDistribution{T}\n\nEncapsulates an ellipse (or a circle where halfsizeu=halfsizev) sampled in an hexapolar fashion (rings).\n\nHexapolar(nrings::Int64, halfsizeu::T, halfsizev::T) where {T<:Real} \n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.Emitters.Origins.Point","page":"Reference","title":"OpticSim.Emitters.Origins.Point","text":"Point{T} <: AbstractOriginDistribution{T}\n\nEncapsulates a single point origin.\n\nPoint(position::Vec3{T}) where {T<:Real}\nPoint(x::T, y::T, z::T) where {T<:Real}\nPoint(::Type{T} = Float64) where {T<:Real}\n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.Emitters.Origins.RectGrid","page":"Reference","title":"OpticSim.Emitters.Origins.RectGrid","text":"RectGrid{T} <: AbstractOriginDistribution{T}\n\nEncapsulates a rectangle sampled in a grid fashion.\n\nRectGrid(width::T, height::T, usamples::Int64, vsamples::Int64) where {T<:Real} \n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.Emitters.Origins.RectJitterGrid","page":"Reference","title":"OpticSim.Emitters.Origins.RectJitterGrid","text":"RectJitterGrid{T} <: AbstractOriginDistribution{T}\n\nEncapsulates a rectangle sampled in a grid fashion with jitter.\n\nRectGrid(width::T, height::T, ures::Int64, vres::Int64, samplesPerRegion::Int64) where {T<:Real} \n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.Emitters.Origins.RectUniform","page":"Reference","title":"OpticSim.Emitters.Origins.RectUniform","text":"RectUniform{T} <: AbstractOriginDistribution{T}\n\nEncapsulates a uniformly sampled rectangle with user defined number of samples.\n\nRectUniform(width::T, height::T, samples_count::Int64) where {T<:Real}\n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.Emitters.Sources.CompositeSource","page":"Reference","title":"OpticSim.Emitters.Sources.CompositeSource","text":"CompositeSource{T} <: AbstractSource{T}\n\nThis data-type represents the composite emitter (Source) which is constructed with a list of basic or composite emitters and a 3D Transform.\n\nCompositeSource(transform::Transform{T}, sources::Vector{<:AbstractSource}) where {T<:Real} \n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.Emitters.Sources.Source","page":"Reference","title":"OpticSim.Emitters.Sources.Source","text":"Source{T<:Real, Tr<:Transform{T}, S<:Spectrum.AbstractSpectrum{T}, O<:Origins.AbstractOriginDistribution{T}, D<:Directions.AbstractDirectionDistribution{T}, P<:AngularPower.AbstractAngularPowerDistribution{T}} <: AbstractSource{T}\n\nThis data-type represents the basic emitter (Source), which is a combination of a Spectrum, Angular Power Distribution, Origins and Directions distribution and a 3D Transform.\n\nSource(::Type{T} = Float64;\n       transform::Tr = Transform(),\n       spectrum::S = Spectrum.Uniform(),\n       origins::O = Origins.Point(),\n       directions::D = Directions.Constant(),\n       power::P = AngularPower.Lambertian(),\n       sourcenum::Int64 = 0) where {\n            Tr<:Transform,\n            S<:Spectrum.AbstractSpectrum,\n            O<:Origins.AbstractOriginDistribution,\n            D<:Directions.AbstractDirectionDistribution,\n            P<:AngularPower.AbstractAngularPowerDistribution,\n            T<:Real}\n\nSource(transform::Tr, spectrum::S, origins::O, directions::D, power::P, ::Type{T} = Float64; sourcenum::Int64 = 0) where {   \n            Tr<:Transform,\n            S<:Spectrum.AbstractSpectrum,\n            O<:Origins.AbstractOriginDistribution,\n            D<:Directions.AbstractDirectionDistribution,\n            P<:AngularPower.AbstractAngularPowerDistribution,\n            T<:Real}\n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.Emitters.Spectrum.DeltaFunction","page":"Reference","title":"OpticSim.Emitters.Spectrum.DeltaFunction","text":"DeltaFunction{T} <: AbstractSpectrum{T}\n\nEncapsulates a constant spectrum.\n\nDeltaFunction{T<:Real}\n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.Emitters.Spectrum.Measured","page":"Reference","title":"OpticSim.Emitters.Spectrum.Measured","text":"Measured{T} <: AbstractSpectrum{T}\n\nEncapsulates a measured spectrum to compute emitter power. Create spectrum by reading CSV files. Assumes spectrum samples are evenly spaced - exception otherwise. Evaluate spectrum at arbitrary wavelength with spectrumpower (more technical details coming soon)\n\nMeasured(samples::DataFrame)\n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.Emitters.Spectrum.Uniform","page":"Reference","title":"OpticSim.Emitters.Spectrum.Uniform","text":"Uniform{T} <: AbstractSpectrum{T}\n\nEncapsulates a flat spectrum range which is sampled uniformly. Unless stated diferrently, the range used will be 450nm to 680nm.\n\nUniform(low_end::T, high_end::T) where {T<:Real}\nUniform(::Type{T} = Float64) where {T<:Real}\n\n\n\n\n\n","category":"type"},{"location":"ref/#Geometry","page":"Reference","title":"Geometry","text":"","category":"section"},{"location":"ref/#OpticSim.Geometry.Transform","page":"Reference","title":"OpticSim.Geometry.Transform","text":"Transform{S<:Real}\n\nTransform encapsulating rotation, translation and scale in 3D space. Translation happens after rotation.\n\nTransform{S}(θ::T, ϕ::T, ψ::T, x::T, y::T, z::T)\nTransform(rotation::SMatrix{3,3,S}, translation::SVector{3,S})\nTransform(rotation::AbstractArray{S,2}, translation::AbstractArray{S,1})\n\nθ, ϕ and ψ in first constructor are in radians.\n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.Geometry.Transform-Union{Tuple{StaticArraysCore.SVector{3, T}}, Tuple{T}, Tuple{StaticArraysCore.SVector{3, T}, StaticArraysCore.SVector{3, T}}} where T<:Real","page":"Reference","title":"OpticSim.Geometry.Transform","text":"Transform(origin, forward) -> Transform{S}\n\nReturns the Transform of type S (default Float64) representing the local frame with origin and forward direction. the other 2 axes are computed automatically.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.Geometry.Transform-Union{Tuple{T}, NTuple{4, StaticArraysCore.SVector{4, T}}} where T<:Real","page":"Reference","title":"OpticSim.Geometry.Transform","text":"Transform(colx::Vec3{T}, coly::Vec3{T},colz::Vec3{T}, colw::Vec3{T}, ::Type{T} = Float64) where {T<:Real}\n\nConstruct a transform from the input columns.     \n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.Geometry.Transform-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{T}}} where T<:Real","page":"Reference","title":"OpticSim.Geometry.Transform","text":"Transform(rotation::AbstractArray{T,2}, translation::AbstractArray{T,1}) where {T<:Real} -> Transform{S}\n\nReturns the Transform of type S (default Float64) created by a rotation matrix (3x3) and translation vector of length 3.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.Geometry.Transform-Union{Tuple{T}, Tuple{StaticArraysCore.SMatrix{3, 3, T}, StaticArraysCore.SVector{3, T}}} where T<:Real","page":"Reference","title":"OpticSim.Geometry.Transform","text":"Transform(rotation::SMatrix{3,3,T}, translation::SVector{3,T}) where {T<:Real} -> Transform{S}\n\nReturns the Transform of type S (default Float64) created by a rotation matrix and translation vector.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.Geometry.Transform-Union{Tuple{T}, Tuple{StaticArraysCore.SVector{3, T}, StaticArraysCore.SVector{3, T}, StaticArraysCore.SVector{3, T}}, NTuple{4, StaticArraysCore.SVector{3, T}}} where T<:Real","page":"Reference","title":"OpticSim.Geometry.Transform","text":"Transform(colx::Vec3{T}, coly::Vec3{T},colz::Vec3{T}, colw::Vec3{T}, ::Type{T} = Float64) where {T<:Real}\n\nConstruct a transform from the input columns.     \n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.Geometry.Transform-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T<:Real","page":"Reference","title":"OpticSim.Geometry.Transform","text":"Transform([S::Type]) -> Transform{S}\n\nReturns the Transform of type S (default Float64) representing the identity transform.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.Geometry.Vec3","page":"Reference","title":"OpticSim.Geometry.Vec3","text":"Vec3{T} provides an immutable vector of fixed length 3 and type T.\n\nVec3 defines a series of convenience constructors, so you can just type e.g. Vec3(1, 2, 3) or Vec3([1.0, 2.0, 3.0]).  It also supports comprehensions, and the zeros(), ones(), fill(), rand() and randn() functions, such as Vec3(rand(3)).\n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.Geometry.Vec4","page":"Reference","title":"OpticSim.Geometry.Vec4","text":"Vec4{T} provides an immutable vector of fixed length 4 and type T.\n\nVec4 defines a series of convenience constructors, so you can just type e.g. Vec3(1, 2, 3, 4) or Vec3([1.0, 2.0, 3.0, 4.0]).  It also supports comprehensions, and the zeros(), ones(), fill(), rand() and randn() functions, such as Vec4(rand(4)).\n\n\n\n\n\n","category":"type"},{"location":"ref/#OpticSim.Geometry.Vec4-Union{Tuple{StaticArraysCore.SMatrix{3, N, T}}, Tuple{T}, Tuple{N}} where {N, T<:Real}","page":"Reference","title":"OpticSim.Geometry.Vec4","text":"Vec4(m::SMatrix{3,N,T} where{N,T<:Real} -> SMatrix{3,N,T})\n\nInput is matrix of 3d points, each column is one point. Returns matrix of 3d points with 1 appended in the last row.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.Geometry.Vec4-Union{Tuple{StaticArraysCore.SVector{3, T}}, Tuple{T}} where T<:Real","page":"Reference","title":"OpticSim.Geometry.Vec4","text":"Vec4(v::SVector{3, T}) where {T<:Real} -> Vec4{T}\n\nAccept SVector and create a Vec4 type [v[1], v[2], v[3], 1]\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.Geometry.decomposeRTS-Union{Tuple{OpticSim.Geometry.Transform{T}}, Tuple{T}} where T<:Real","page":"Reference","title":"OpticSim.Geometry.decomposeRTS","text":"decomposeRTS(tr::Transform{T}) where {T<:Real}\n\nreturn a tuple containing the rotation matrix, the translation vector and the scale vecto represnting the transform.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.Geometry.forward-Tuple{OpticSim.Geometry.Transform{<:Real}}","page":"Reference","title":"OpticSim.Geometry.forward","text":"forward(t::Transform{<:Real}) -> Vec3\n\nAssuming t is a 3D rigid transform representing a local left-handed coordinate system, this function will return the third column, representing the \"Z\" axis.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.Geometry.identitytransform-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T<:Real","page":"Reference","title":"OpticSim.Geometry.identitytransform","text":"identitytransform([S::Type]) -> Transform{S}\n\nReturns the Transform of type S (default Float64) representing the identity transform.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.Geometry.local2world-Union{Tuple{OpticSim.Geometry.Transform{T}}, Tuple{T}} where T<:Real","page":"Reference","title":"OpticSim.Geometry.local2world","text":"local2world(t::Transform{T}) where {T<:Real}\n\nreturn the transform matrix that takes a point in the local coordinate system to the global one\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.Geometry.right-Tuple{OpticSim.Geometry.Transform{<:Real}}","page":"Reference","title":"OpticSim.Geometry.right","text":"right(t::Transform{<:Real}) -> Vec3\n\nAssuming t is a 3D rigid transform representing a local left-handed coordinate system, this function will return the first column, representing the \"X\" axis.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.Geometry.rotation-Union{Tuple{OpticSim.Geometry.Transform{T}}, Tuple{T}} where T<:Real","page":"Reference","title":"OpticSim.Geometry.rotation","text":"rotation(t::Transform{T}) where {T<:Real} -> SMatrix{3,3,T}\n\nreturns the rotation part of the transform t - a 3x3 matrix.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.Geometry.rotation-Union{Tuple{T}, Tuple{T, T, T}} where T<:Number","page":"Reference","title":"OpticSim.Geometry.rotation","text":"rotation([S::Type], θ::T, ϕ::T, ψ::T) -> Transform{S}\n\nReturns the Transform of type S (default Float64) representing the rotation by θ, ϕ and ψ around the x, y and z axes respectively in radians.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.Geometry.rotationX-Tuple{T} where T<:Real","page":"Reference","title":"OpticSim.Geometry.rotationX","text":"rotationX(angle::T) where {T<:Real} -> Transform\n\nBuilds a rotation matrix for a rotation around the x-axis.  Parameters:     The counter-clockwise angle in radians.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.Geometry.rotationY-Tuple{T} where T<:Real","page":"Reference","title":"OpticSim.Geometry.rotationY","text":"rotationY(angle::T) where {T<:Real} -> Transform\n\nBuilds a rotation matrix for a rotation around the y-axis.  Parameters:     The counter-clockwise angle in radians.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.Geometry.rotationZ-Tuple{T} where T<:Real","page":"Reference","title":"OpticSim.Geometry.rotationZ","text":"rotationZ(angle::T) where {T<:Real} -> Transform\n\nBuilds a rotation matrix for a rotation around the z-axis.  Parameters:     The counter-clockwise angle in radians.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.Geometry.rotationd-Union{Tuple{T}, Tuple{T, T, T}} where T<:Number","page":"Reference","title":"OpticSim.Geometry.rotationd","text":"rotationd([S::Type], θ::T, ϕ::T, ψ::T) -> Transform{S}\n\nReturns the Transform of type S (default Float64) representing the rotation by θ, ϕ and ψ around the x, y and z axes respectively in degrees.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.Geometry.rotmat-Union{Tuple{T}, Tuple{T, T, T}} where T<:Number","page":"Reference","title":"OpticSim.Geometry.rotmat","text":"rotmat([S::Type], θ::T, ϕ::T, ψ::T) -> SMatrix{3,3,S}\n\nReturns the rotation matrix of type S (default Float64) representing the rotation by θ, ϕ and ψ around the x, y and z axes respectively in radians.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.Geometry.rotmatd-Union{Tuple{T}, Tuple{T, T, T}} where T<:Number","page":"Reference","title":"OpticSim.Geometry.rotmatd","text":"rotmatd([S::Type], θ::T, ϕ::T, ψ::T) -> SMatrix{3,3,S}\n\nReturns the rotation matrix of type S (default Float64) representing the rotation by θ, ϕ and ψ around the x, y and z axes respectively in degrees.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.Geometry.scale-Tuple{T} where T<:Real","page":"Reference","title":"OpticSim.Geometry.scale","text":"scale(s::T) where {T<:Real}\n\nCreates a uniform scaling transform\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.Geometry.scale-Union{Tuple{StaticArraysCore.SVector{3, T}}, Tuple{T}} where T<:Real","page":"Reference","title":"OpticSim.Geometry.scale","text":"scale(t::Vec3{T}) where {T<:Real}\n\nCreates a scaling transform\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.Geometry.scale-Union{Tuple{T}, Tuple{T, T, T}} where T<:Real","page":"Reference","title":"OpticSim.Geometry.scale","text":"scale(x::T, y::T, z::T) where {T<:Real}\n\nCreates a scaling transform\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.Geometry.translation-Union{Tuple{StaticArraysCore.SVector{3, T}}, Tuple{T}} where T<:Real","page":"Reference","title":"OpticSim.Geometry.translation","text":"translation(x::T, y::T, z::T) where {T<:Real}\n\nCreates a translation transform\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.Geometry.translation-Union{Tuple{S}, Tuple{T}, Tuple{Type{S}, T, T, T}} where {T<:Number, S<:Real}","page":"Reference","title":"OpticSim.Geometry.translation","text":"translation(x::T, y::T, z::T) where {T<:Real}\n\nCreates a translation transform\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.Geometry.unitW4-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T<:Real","page":"Reference","title":"OpticSim.Geometry.unitW4","text":"returns the unit vector [0, 0, 0, 1]\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.Geometry.unitX3-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T<:Real","page":"Reference","title":"OpticSim.Geometry.unitX3","text":"returns the unit vector [1, 0, 0]\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.Geometry.unitX4-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T<:Real","page":"Reference","title":"OpticSim.Geometry.unitX4","text":"returns the unit vector [1, 0, 0, 0]\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.Geometry.unitY3-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T<:Real","page":"Reference","title":"OpticSim.Geometry.unitY3","text":"returns the unit vector [0, 1, 0]\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.Geometry.unitY4-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T<:Real","page":"Reference","title":"OpticSim.Geometry.unitY4","text":"returns the unit vector [0, 1, 0, 0]\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.Geometry.unitZ3-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T<:Real","page":"Reference","title":"OpticSim.Geometry.unitZ3","text":"returns the unit vector [0, 0, 1]\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.Geometry.unitZ4-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T<:Real","page":"Reference","title":"OpticSim.Geometry.unitZ4","text":"returns the unit vector [0, 0, 1, 0]\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.Geometry.up-Tuple{OpticSim.Geometry.Transform{<:Real}}","page":"Reference","title":"OpticSim.Geometry.up","text":"up(t::Transform{<:Real}) -> Vec3\n\nAssuming t is a 3D rigid transform representing a local left-handed coordinate system, this function will return the second column, representing the \"Y\" axis.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.Geometry.world2local-Union{Tuple{OpticSim.Geometry.Transform{T}}, Tuple{T}} where T<:Real","page":"Reference","title":"OpticSim.Geometry.world2local","text":"world2local(t::Transform{T}) where {T<:Real}\n\nreturn the transform matrix that takes a point in the global coordinate system to the local one\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.origin-Tuple{OpticSim.Geometry.Transform{<:Real}}","page":"Reference","title":"OpticSim.origin","text":"origin(t::Transform{<:Real}) -> Vec3\n\nAssuming t is a 3D rigid transform representing a local left-handed coordinate system, this function will return the fourth column, containing the translation part of the transform in 3D.\n\n\n\n\n\n","category":"method"},{"location":"ref/#Zernike","page":"Reference","title":"Zernike","text":"","category":"section"},{"location":"ref/#OpticSim.Zernike","page":"Reference","title":"OpticSim.Zernike","text":"Module to enclose Zernike polynomial specific functionality.\n\n\n\n\n\n","category":"module"},{"location":"ref/#QType","page":"Reference","title":"QType","text":"","category":"section"},{"location":"ref/#OpticSim.QType","page":"Reference","title":"OpticSim.QType","text":"Module to enclose QType polynomial specific functionality. For reference see:\n\nRobust, efficient computational methods for axially symmetric optical aspheres - G. W. Forbes, 2010\nCharacterizing the shape of freeform optics - G. W. Forbes, 2012\n\n\n\n\n\n","category":"module"},{"location":"ref/#Chebyshev","page":"Reference","title":"Chebyshev","text":"","category":"section"},{"location":"ref/#OpticSim.Chebyshev","page":"Reference","title":"OpticSim.Chebyshev","text":"Module to enclose Chebyshev polynomial specific functionality.\n\n\n\n\n\n","category":"module"},{"location":"ref/#Data","page":"Reference","title":"Data","text":"","category":"section"},{"location":"ref/#OpticSim.Data.ArizonaEye-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T<:Real","page":"Reference","title":"OpticSim.Data.ArizonaEye","text":"ArizonaEye(::Type{T} = Float64; accommodation::T = 0.0)\n\nThe popular Arizona eye model taken from this definition. The accommodation of the eye can be varied in this model. Returns a DataFrame specifying the prescription of the eye model.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.Data.ModelEye-Union{Tuple{LensAssembly{T}}, Tuple{D}, Tuple{T}} where {T<:Real, D<:Real}","page":"Reference","title":"OpticSim.Data.ModelEye","text":"ModelEye(assembly::LensAssembly{T}, nsamples::Int = 17; pupil_radius::T = 3.0, detpixels::Int = 1000, transform::Transform{T} = identitytransform(T))\n\nGeometrically accurate model of the human eye focused at infinity with variable pupil_radius. The eye is added to the provided assembly to create a CSGOpticalSystem with the retina of the eye as the detector.\n\nThe eye can be positioned in the scene using the transform argument and the resolution of the detector specified with detpixels. By default the eye is directed along the positive z-axis with the vertex of the cornea at the origin.\n\nnsamples determines the resolution at which accelerated surfaces within the eye are triangulated.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.Data.comfortable_entrance_pupil_translation-Tuple{}","page":"Reference","title":"OpticSim.Data.comfortable_entrance_pupil_translation","text":"Average one sided translation of the entrance pupil associated with comfortable eye rotation. If you are using this to define an eyebox multiply this value by 2\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.Data.cornea_to_eyecenter-Tuple{}","page":"Reference","title":"OpticSim.Data.cornea_to_eyecenter","text":"distance from vertex of cornea to center of rotation\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.Data.entrancepupil_to_eyecenter-Tuple{}","page":"Reference","title":"OpticSim.Data.entrancepupil_to_eyecenter","text":"distance from entrance pupil to center of rotation.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.Data.eyefocallength-Tuple{}","page":"Reference","title":"OpticSim.Data.eyefocallength","text":"Posterior focal length, i.e., optical distance from entrance pupil to the retina. Focal length will change depending on accommodation. This value is for focus at ∞. When the eye is focused at 25cm focal length will be ≈ 22mm. Because the index of refraction of the vitreous humor is approximately 1.33 the physical distance from the entrance pupil to the retina will be 24mm/1.33 = 18mm.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OpticSim.Data.𝐃sd-Tuple{Any, Any}","page":"Reference","title":"OpticSim.Data.𝐃sd","text":"computes pupil diameter as a function of scene luminance L, in cd/m², and the angular area, a, over which this luminance is presented to the eye.\n\n\n\n\n\n","category":"method"}]
}

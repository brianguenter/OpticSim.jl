<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>CSG · OpticSim.jl</title><meta name="title" content="CSG · OpticSim.jl"/><meta property="og:title" content="CSG · OpticSim.jl"/><meta property="twitter:title" content="CSG · OpticSim.jl"/><meta name="description" content="Documentation for OpticSim.jl."/><meta property="og:description" content="Documentation for OpticSim.jl."/><meta property="twitter:description" content="Documentation for OpticSim.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/logo.svg" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img class="docs-light-only" src="../assets/logo.svg" alt="OpticSim.jl logo"/><img class="docs-dark-only" src="../assets/logo-dark.svg" alt="OpticSim.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">OpticSim.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Geometry</span><ul><li><a class="tocitem" href="../primitives/">Primitives</a></li><li><a class="tocitem" href="../transforms_and_vectors/">Transforms and Vectors</a></li><li class="is-active"><a class="tocitem" href>CSG</a><ul class="internal"><li><a class="tocitem" href="#CSG-Operations"><span>CSG Operations</span></a></li><li><a class="tocitem" href="#Pre-made-CSG-Shapes"><span>Pre-made CSG Shapes</span></a></li><li><a class="tocitem" href="#CSG-Types"><span>CSG Types</span></a></li><li><a class="tocitem" href="#Additional-Functions-and-Types"><span>Additional Functions and Types</span></a></li></ul></li></ul></li><li><span class="tocitem">Optical</span><ul><li><a class="tocitem" href="../systems/">Systems</a></li><li><a class="tocitem" href="../emitters/">Emitters</a></li><li><a class="tocitem" href="../interfaces/">Interfaces</a></li><li><a class="tocitem" href="../lenses/">Lenses</a></li></ul></li><li><a class="tocitem" href="../ref/">Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Geometry</a></li><li class="is-active"><a href>CSG</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>CSG</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/brianguenter/OpticSim.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/brianguenter/OpticSim.jl/blob/main/docs/src/csg.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="CSG"><a class="docs-heading-anchor" href="#CSG">CSG</a><a id="CSG-1"></a><a class="docs-heading-anchor-permalink" href="#CSG" title="Permalink"></a></h1><h2 id="CSG-Operations"><a class="docs-heading-anchor" href="#CSG-Operations">CSG Operations</a><a id="CSG-Operations-1"></a><a class="docs-heading-anchor-permalink" href="#CSG-Operations" title="Permalink"></a></h2><p>OpticSim represents objects as boolean combinations of halfspaces, a method of constructing solid objects known as Constructive Solid Geometry (CSG). A halfspace is a surface which divides 3D space into 3 regions: inside the halfspace,outside the halfspace, on the surface dividing inside from outside. </p><p>A simple example of a halfspace is an infinite oriented plane, where oriented means we have defined a direction for the normal to the plane surface. Another simple example is a sphere, or a cylinder.</p><p>If the halfspaces have mathematically well difined inside and outside functions then except for edge cases, which are unlikely to occur in an optics setting, then any boolean combination of halfspaces will also have a well defined inside and outside.</p><p>You can define optical elements by combining the basic halfspace types defined for you in OpticSim:</p><ul><li>sphere</li><li>infinite cylinder</li><li>plane</li><li>prism</li><li>spherical cap</li></ul><p>Many of the surfaces already defined for you in OpticSim, such as sphere, prism,plane, cylinder, describe well defined solid objects, i.e., there is a mathematically defined inside and outside. </p><p>Unfortunately, many of the surfaces common in optics do not by themselves define solid objects. None of the parametric surfaces, which includes all the optical asphere types, define solid objects. </p><p>Parametric surfaces do have a positive and negative side though determined by the direction of the surface normal. You can create a well defined solid object by taking the intersection of a cylinder with an asphere.</p><p>There are three binary csg operations which can construct extremely complex objects from very simple primitives: union (<span>$\cup$</span>), intersection (<span>$\cap$</span>) and subtraction (i.e. difference).</p><p>This diagram shows the basic idea: <img src="https://upload.wikimedia.org/wikipedia/commons/8/8b/Csg_tree.png" alt="CSG Tree visualization"/></p><p>The code for this in our system would look this this:</p><pre><code class="language-julia hljs">cyl = Cylinder(0.7)
cyl_cross = cyl ∪ leaf(cyl, Geometry.rotationd(90, 0, 0)) ∪ leaf(cyl, Geometry.rotationd(0, 90, 0))

cube = Cuboid(1.0, 1.0, 1.0)
sph = Sphere(1.3)
rounded_cube = cube ∩ sph

result = rounded_cube - cyl_cross</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">CSGGenerator{Float64}(OpticSim.var&quot;#81#82&quot;{CSGGenerator{Float64}, CSGGenerator{Float64}}(CSGGenerator{Float64}(OpticSim.var&quot;#75#76&quot;{CSGGenerator{Float64}, CSGGenerator{Float64}}(CSGGenerator{Float64}(OpticSim.var&quot;#75#76&quot;{CSGGenerator{Float64}, CSGGenerator{Float64}}(CSGGenerator{Float64}(OpticSim.var&quot;#75#76&quot;{CSGGenerator{Float64}, CSGGenerator{Float64}}(CSGGenerator{Float64}(OpticSim.var&quot;#75#76&quot;{CSGGenerator{Float64}, CSGGenerator{Float64}}(CSGGenerator{Float64}(OpticSim.var&quot;#75#76&quot;{CSGGenerator{Float64}, CSGGenerator{Float64}}(CSGGenerator{Float64}(OpticSim.var&quot;#75#76&quot;{CSGGenerator{Float64}, CSGGenerator{Float64}}(CSGGenerator{Float64}(OpticSim.var&quot;#leaf##0#leaf##1&quot;{Plane{Float64, 3}, OpticSim.Geometry.Transform{Float64}}(Plane{Float64}([-1.0, 0.0, 0.0], [-1.0, 0.0, 0.0], NullInterface{Float64}()), OpticSim.Geometry.Transform{Float64}([1.0 0.0 0.0 0.0; 0.0 1.0 0.0 0.0; 0.0 0.0 1.0 0.0; 0.0 0.0 0.0 1.0]))), CSGGenerator{Float64}(OpticSim.var&quot;#leaf##0#leaf##1&quot;{Plane{Float64, 3}, OpticSim.Geometry.Transform{Float64}}(Plane{Float64}([1.0, 0.0, 0.0], [1.0, 0.0, 0.0], NullInterface{Float64}()), OpticSim.Geometry.Transform{Float64}([1.0 0.0 0.0 0.0; 0.0 1.0 0.0 0.0; 0.0 0.0 1.0 0.0; 0.0 0.0 0.0 1.0]))))), CSGGenerator{Float64}(OpticSim.var&quot;#leaf##0#leaf##1&quot;{Plane{Float64, 3}, OpticSim.Geometry.Transform{Float64}}(Plane{Float64}([0.0, -1.0, 0.0], [0.0, -1.0, 0.0], NullInterface{Float64}()), OpticSim.Geometry.Transform{Float64}([1.0 0.0 0.0 0.0; 0.0 1.0 0.0 0.0; 0.0 0.0 1.0 0.0; 0.0 0.0 0.0 1.0]))))), CSGGenerator{Float64}(OpticSim.var&quot;#leaf##0#leaf##1&quot;{Plane{Float64, 3}, OpticSim.Geometry.Transform{Float64}}(Plane{Float64}([0.0, 1.0, 0.0], [0.0, 1.0, 0.0], NullInterface{Float64}()), OpticSim.Geometry.Transform{Float64}([1.0 0.0 0.0 0.0; 0.0 1.0 0.0 0.0; 0.0 0.0 1.0 0.0; 0.0 0.0 0.0 1.0]))))), CSGGenerator{Float64}(OpticSim.var&quot;#leaf##0#leaf##1&quot;{Plane{Float64, 3}, OpticSim.Geometry.Transform{Float64}}(Plane{Float64}([0.0, 0.0, -1.0], [0.0, 0.0, -1.0], NullInterface{Float64}()), OpticSim.Geometry.Transform{Float64}([1.0 0.0 0.0 0.0; 0.0 1.0 0.0 0.0; 0.0 0.0 1.0 0.0; 0.0 0.0 0.0 1.0]))))), CSGGenerator{Float64}(OpticSim.var&quot;#leaf##0#leaf##1&quot;{Plane{Float64, 3}, OpticSim.Geometry.Transform{Float64}}(Plane{Float64}([0.0, 0.0, 1.0], [0.0, 0.0, 1.0], NullInterface{Float64}()), OpticSim.Geometry.Transform{Float64}([1.0 0.0 0.0 0.0; 0.0 1.0 0.0 0.0; 0.0 0.0 1.0 0.0; 0.0 0.0 0.0 1.0]))))), CSGGenerator{Float64}(OpticSim.var&quot;#leaf##0#leaf##1&quot;{Sphere{Float64, 3}, OpticSim.Geometry.Transform{Float64}}(Sphere{Float64, 3}(1.3, NullInterface{Float64}()), OpticSim.Geometry.Transform{Float64}([1.0 0.0 0.0 0.0; 0.0 1.0 0.0 0.0; 0.0 0.0 1.0 0.0; 0.0 0.0 0.0 1.0]))))), CSGGenerator{Float64}(OpticSim.var&quot;#78#79&quot;{CSGGenerator{Float64}, CSGGenerator{Float64}}(CSGGenerator{Float64}(OpticSim.var&quot;#78#79&quot;{CSGGenerator{Float64}, CSGGenerator{Float64}}(CSGGenerator{Float64}(OpticSim.var&quot;#leaf##0#leaf##1&quot;{Cylinder{Float64, 3}, OpticSim.Geometry.Transform{Float64}}(Cylinder{Float64}(0.7, NullInterface{Float64}()), OpticSim.Geometry.Transform{Float64}([1.0 0.0 0.0 0.0; 0.0 1.0 0.0 0.0; 0.0 0.0 1.0 0.0; 0.0 0.0 0.0 1.0]))), CSGGenerator{Float64}(OpticSim.var&quot;#leaf##0#leaf##1&quot;{Cylinder{Float64, 3}, OpticSim.Geometry.Transform{Float64}}(Cylinder{Float64}(0.7, NullInterface{Float64}()), OpticSim.Geometry.Transform{Float64}([1.0 0.0 0.0 0.0; 0.0 6.123233995736766e-17 -1.0 0.0; -0.0 1.0 6.123233995736766e-17 0.0; 0.0 0.0 0.0 1.0]))))), CSGGenerator{Float64}(OpticSim.var&quot;#leaf##0#leaf##1&quot;{Cylinder{Float64, 3}, OpticSim.Geometry.Transform{Float64}}(Cylinder{Float64}(0.7, NullInterface{Float64}()), OpticSim.Geometry.Transform{Float64}([6.123233995736766e-17 0.0 1.0 0.0; 0.0 1.0 0.0 0.0; -1.0 0.0 6.123233995736766e-17 0.0; 0.0 0.0 0.0 1.0])))))))</code></pre><article><details class="docstring" open="true"><summary id="OpticSim.leaf-csg"><a class="docstring-binding" href="#OpticSim.leaf-csg"><code>OpticSim.leaf</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">leaf(surf::ParametricSurface{T}, transform::Transform{T} = identitytransform(T)) -&gt; CSGGenerator{T}</code></pre><p>Create a leaf node from a parametric surface with a given transform.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/789c78664dac2b05dc89b34d8f81286139c4e45a/src/Geometry/CSG/CSG.jl#L121-L125">source</a></div></details></article><article><details class="docstring" open="true"><summary id="Base.:∪-csg"><a class="docstring-binding" href="#Base.:∪-csg"><code>Base.:∪</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">∪(a::Union{CSGGenerator{T},ParametricSurface{T}}, b::Union{CSGGenerator{T},ParametricSurface{T}}) where {T&lt;:Real}</code></pre><p>Create a binary node in the CSG tree representing a union between <code>a</code> and <code>b</code>.</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/4/4a/Boolean_union.PNG" alt="Union Image"/></p><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/789c78664dac2b05dc89b34d8f81286139c4e45a/src/Geometry/CSG/CSG.jl#L165-L171">source</a></div></details></article><article><details class="docstring" open="true"><summary id="Base.:∩-csg"><a class="docstring-binding" href="#Base.:∩-csg"><code>Base.:∩</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">∩(a::Union{CSGGenerator{T},ParametricSurface{T}}, b::Union{CSGGenerator{T},ParametricSurface{T}}) where {T&lt;:Real}</code></pre><p>Create a binary node in the CSG tree representing an intersection between <code>a</code> and <code>b</code>.</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/0/0b/Boolean_intersect.PNG" alt="Intersect Image"/></p><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/789c78664dac2b05dc89b34d8f81286139c4e45a/src/Geometry/CSG/CSG.jl#L146-L152">source</a></div></details></article><article><details class="docstring" open="true"><summary id="Base.:--csg"><a class="docstring-binding" href="#Base.:--csg"><code>Base.:-</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">-(a::Union{CSGGenerator{T},ParametricSurface{T}}, b::Union{CSGGenerator{T},ParametricSurface{T}}) where {T&lt;:Real}</code></pre><p>Create a binary node in the CSG tree representing the difference of <code>a</code> and <code>b</code>, essentially <code>a - b</code>.</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/8/86/Boolean_difference.PNG" alt="Difference Image"/></p><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/789c78664dac2b05dc89b34d8f81286139c4e45a/src/Geometry/CSG/CSG.jl#L184-L190">source</a></div></details></article><h2 id="Pre-made-CSG-Shapes"><a class="docs-heading-anchor" href="#Pre-made-CSG-Shapes">Pre-made CSG Shapes</a><a id="Pre-made-CSG-Shapes-1"></a><a class="docs-heading-anchor-permalink" href="#Pre-made-CSG-Shapes" title="Permalink"></a></h2><p>There are also some shortcut methods available to create common CSG objects more easily:</p><article><details class="docstring" open="true"><summary id="OpticSim.BoundedCylinder-csg"><a class="docstring-binding" href="#OpticSim.BoundedCylinder-csg"><code>OpticSim.BoundedCylinder</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">BoundedCylinder(radius::T, height::T; interface::NullOrFresnel{T} = nullinterface(T)) -&gt; CSGGenerator{T}</code></pre><p>Create a cylinder with planar caps on both ends centered at <code>(0, 0, 0)</code> with axis <code>(0, 0, 1)</code>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/789c78664dac2b05dc89b34d8f81286139c4e45a/src/Geometry/Geometry.jl#L67-L71">source</a></div></details></article><article><details class="docstring" open="true"><summary id="OpticSim.Cuboid-csg"><a class="docstring-binding" href="#OpticSim.Cuboid-csg"><code>OpticSim.Cuboid</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">Cuboid(halfsizex::T, halfsizey::T, halfsizez::T; interface::NullOrFresnel{T} = nullinterface(T)) -&gt; CSGGenerator{T}</code></pre><p>Create a cuboid centered at <code>(0, 0, 0)</code>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/789c78664dac2b05dc89b34d8f81286139c4e45a/src/Geometry/Geometry.jl#L79-L83">source</a></div></details></article><article><details class="docstring" open="true"><summary id="OpticSim.HexagonalPrism-csg"><a class="docstring-binding" href="#OpticSim.HexagonalPrism-csg"><code>OpticSim.HexagonalPrism</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">HexagonalPrism(side_length::T, visheight::T = 2.0; interface::NullOrFresnel{T} = nullinterface(T)) -&gt; CSGGenerator{T}</code></pre><p>Create an infinitely tall hexagonal prism with axis <code>(0, 0, 1)</code>, the longer hexagon diameter is along the x axis. For visualization <code>visheight</code> is used, <strong>note that this does not fully represent the surface</strong>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/789c78664dac2b05dc89b34d8f81286139c4e45a/src/Geometry/Geometry.jl#L94-L99">source</a></div></details></article><article><details class="docstring" open="true"><summary id="OpticSim.RectangularPrism-csg"><a class="docstring-binding" href="#OpticSim.RectangularPrism-csg"><code>OpticSim.RectangularPrism</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">RectangularPrism(halfsizex::T, halfsizey::T, visheight::T=2.0; interface::NullOrFresnel{T} = nullinterface(T)) -&gt; CSGGenerator{T}</code></pre><p>Create an infinitely tall rectangular prism with axis <code>(0, 0, 1)</code>. For visualization <code>visheight</code> is used, <strong>note that this does not fully represent the surface</strong>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/789c78664dac2b05dc89b34d8f81286139c4e45a/src/Geometry/Geometry.jl#L115-L120">source</a></div></details></article><article><details class="docstring" open="true"><summary id="OpticSim.TriangularPrism-csg"><a class="docstring-binding" href="#OpticSim.TriangularPrism-csg"><code>OpticSim.TriangularPrism</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">TriangularPrism(side_length::T, visheight::T = 2.0; interface::NullOrFresnel{T} = nullinterface(T)) -&gt; CSGGenerator{T}</code></pre><p>Create an infinitely tall triangular prism with axis <code>(0, 0, 1)</code>. For visualization <code>visheight</code> is used, <strong>note that this does not fully represent the surface</strong>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/789c78664dac2b05dc89b34d8f81286139c4e45a/src/Geometry/Geometry.jl#L130-L135">source</a></div></details></article><article><details class="docstring" open="true"><summary id="OpticSim.Spider-csg"><a class="docstring-binding" href="#OpticSim.Spider-csg"><code>OpticSim.Spider</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">Spider(narms::Int, armwidth::T, radius::T, origin::SVector{3,T} = SVector{3,T}(0.0, 0.0, 0.0), normal::SVector{3,T} = SVector{3,T}(0.0, 0.0, 1.0)) -&gt; Vector{Rectangle{T}}</code></pre><p>Creates a &#39;spider&#39; obscuration with <code>narms</code> rectangular arms evenly spaced around a circle defined by <code>origin</code> and <code>normal</code>. Each arm is a rectangle <code>armwidth</code>×<code>radius</code>.</p><p>e.g. for 3 and 4 arms we get:</p><pre><code class="language-julia hljs">   |         _|_
  / \         |</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/789c78664dac2b05dc89b34d8f81286139c4e45a/src/Geometry/Geometry.jl#L157-L168">source</a></div></details></article><h2 id="CSG-Types"><a class="docs-heading-anchor" href="#CSG-Types">CSG Types</a><a id="CSG-Types-1"></a><a class="docs-heading-anchor-permalink" href="#CSG-Types" title="Permalink"></a></h2><p>These are the types of the primary CSG elements, i.e. the nodes in the CSG tree.</p><article><details class="docstring" open="true"><summary id="OpticSim.CSGTree-csg"><a class="docstring-binding" href="#OpticSim.CSGTree-csg"><code>OpticSim.CSGTree</code></a> — <span class="docstring-category">Type</span></summary><div><p>Abstract type representing any evaluated CSG structure.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/789c78664dac2b05dc89b34d8f81286139c4e45a/src/Geometry/CSG/CSG.jl#L7">source</a></div></details></article><article><details class="docstring" open="true"><summary id="OpticSim.CSGGenerator-csg"><a class="docstring-binding" href="#OpticSim.CSGGenerator-csg"><code>OpticSim.CSGGenerator</code></a> — <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">CSGGenerator{T&lt;:Real}</code></pre><p>This is the type you should use when making CSG objects. This type allows for the construction of <a href="../ref/#OpticSim.CSGTree"><code>CSGTree</code></a> objects with different transforms. When the generator is evaluated, all transforms are propagated down to the <a href="#OpticSim.LeafNode-csg"><code>LeafNode</code></a>s and stored there.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">a = Cylinder(1.0,1.0)
b = Plane([0.0,0.0,1.0], [0.0,0.0,0.0])
generator = a ∩ b
# now make a csg object that can be ray traced
csgobj = generator(Transform(1.0,1.0,2.0))</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/789c78664dac2b05dc89b34d8f81286139c4e45a/src/Geometry/CSG/CSG.jl#L94-L109">source</a></div></details></article><article><details class="docstring" open="true"><summary id="OpticSim.ComplementNode-csg"><a class="docstring-binding" href="#OpticSim.ComplementNode-csg"><code>OpticSim.ComplementNode</code></a> — <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">ComplementNode{T,C&lt;:CSGTree{T}} &lt;: CSGTree{T}</code></pre><p>An evaluated complement node within the CSG tree, must be the second child of a <a href="#OpticSim.IntersectionNode-csg"><code>IntersectionNode</code></a> forming a subtraction.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/789c78664dac2b05dc89b34d8f81286139c4e45a/src/Geometry/CSG/CSG.jl#L10-L15">source</a></div></details></article><article><details class="docstring" open="true"><summary id="OpticSim.UnionNode-csg"><a class="docstring-binding" href="#OpticSim.UnionNode-csg"><code>OpticSim.UnionNode</code></a> — <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">UnionNode{T,L&lt;:CSGTree{T},R&lt;:CSGTree{T}} &lt;: CSGTree{T}</code></pre><p>An evaluated union node within the CSG tree.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/789c78664dac2b05dc89b34d8f81286139c4e45a/src/Geometry/CSG/CSG.jl#L26-L30">source</a></div></details></article><article><details class="docstring" open="true"><summary id="OpticSim.IntersectionNode-csg"><a class="docstring-binding" href="#OpticSim.IntersectionNode-csg"><code>OpticSim.IntersectionNode</code></a> — <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">IntersectionNode{T,L&lt;:CSGTree{T},R&lt;:CSGTree{T}} &lt;: CSGTree{T}</code></pre><p>An evaluated intersection node within the CSG tree.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/789c78664dac2b05dc89b34d8f81286139c4e45a/src/Geometry/CSG/CSG.jl#L43-L47">source</a></div></details></article><article><details class="docstring" open="true"><summary id="OpticSim.LeafNode-csg"><a class="docstring-binding" href="#OpticSim.LeafNode-csg"><code>OpticSim.LeafNode</code></a> — <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">LeafNode{T,S&lt;:ParametricSurface{T}} &lt;: CSGTree{T}</code></pre><p>An evaluated leaf node in the CSG tree, <code>geometry</code> attribute which contains a <a href="../ref/#OpticSim.ParametricSurface"><code>ParametricSurface</code></a> of type <code>S</code>. The leaf node also has a transform associated which is the composition of all nodes above it in the tree. As such, transforming points from the geometry using this transform puts them in world space, and transforming rays by the inverse transform puts them in object space.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/789c78664dac2b05dc89b34d8f81286139c4e45a/src/Geometry/CSG/CSG.jl#L65-L72">source</a></div></details></article><h2 id="Additional-Functions-and-Types"><a class="docs-heading-anchor" href="#Additional-Functions-and-Types">Additional Functions and Types</a><a id="Additional-Functions-and-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Additional-Functions-and-Types" title="Permalink"></a></h2><p>These are the internal types and functions used for geometric/CSG operations.</p><h3 id="Functions"><a class="docs-heading-anchor" href="#Functions">Functions</a><a id="Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Functions" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="OpticSim.surfaceintersection-Union{Tuple{N}, Tuple{T}, Tuple{CSGTree{T}, AbstractRay{T, N}}} where {T&lt;:Real, N}-csg"><a class="docstring-binding" href="#OpticSim.surfaceintersection-Union{Tuple{N}, Tuple{T}, Tuple{CSGTree{T}, AbstractRay{T, N}}} where {T&lt;:Real, N}-csg"><code>OpticSim.surfaceintersection</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">surfaceintersection(obj::CSGTree{T}, r::AbstractRay{T,N})</code></pre><p>Calculates the intersection of <code>r</code> with CSG object, <code>obj</code>.</p><p>Returns an <a href="../ref/#OpticSim.EmptyInterval"><code>EmptyInterval</code></a> if there is no intersection, an <a href="../ref/#OpticSim.Interval"><code>Interval</code></a> if there is one or two intersections and a <a href="../ref/#OpticSim.DisjointUnion"><code>DisjointUnion</code></a> if there are more than two intersections.</p><p>The ray is intersected with the <a href="#OpticSim.LeafNode-csg"><code>LeafNode</code></a>s that make up the CSG object and the resulting <code>Interval</code>s and <code>DisjointUnion</code>s are composed with the same boolean operations to give a final result. The ray is transformed by the inverse of the transform associated with the leaf node to put it in <em>object space</em> for that node before the intersection is carried out, typically this <em>object space</em> is centered at the origin, but may differ for each primitive.</p><p>Some intersections are culled without actually evaluating them by first checking if the ray intersects the <a href="../ref/#OpticSim.BoundingBox"><code>BoundingBox</code></a> of each node in the <a href="../ref/#OpticSim.CSGTree"><code>CSGTree</code></a>, this can substantially improve performance in some cases.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/789c78664dac2b05dc89b34d8f81286139c4e45a/src/Geometry/CSG/CSG.jl#L285-L301">source</a></div></details></article><article><details class="docstring" open="true"><summary id="OpticSim.inside-Union{Tuple{T}, Tuple{CSGTree{T}, T, T, T}} where T&lt;:Real-csg"><a class="docstring-binding" href="#OpticSim.inside-Union{Tuple{T}, Tuple{CSGTree{T}, T, T, T}} where T&lt;:Real-csg"><code>OpticSim.inside</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">inside(obj::CSGTree{T}, point::SVector{3,T}) -&gt; Bool
inside(obj::CSGTree{T}, x::T, y::T, z::T) -&gt; Bool</code></pre><p>Tests whether a 3D point in world space is <em>inside</em> <code>obj</code>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/789c78664dac2b05dc89b34d8f81286139c4e45a/src/Geometry/CSG/CSG.jl#L333-L338">source</a></div></details></article><article><details class="docstring" open="true"><summary id="OpticSim.onsurface-Union{Tuple{T}, Tuple{CSGTree{T}, T, T, T}} where T&lt;:Real-csg"><a class="docstring-binding" href="#OpticSim.onsurface-Union{Tuple{T}, Tuple{CSGTree{T}, T, T, T}} where T&lt;:Real-csg"><code>OpticSim.onsurface</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">onsurface(obj::CSGTree{T}, point::SVector{3,T}) -&gt; Bool
onsurface(obj::CSGTree{T}, x::T, y::T, z::T) -&gt; Bool</code></pre><p>Tests whether a 3D point in world space is <em>on</em> the surface (i.e. shell) of <code>obj</code>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/789c78664dac2b05dc89b34d8f81286139c4e45a/src/Geometry/CSG/CSG.jl#L311-L316">source</a></div></details></article><h3 id="Intervals"><a class="docs-heading-anchor" href="#Intervals">Intervals</a><a id="Intervals-1"></a><a class="docs-heading-anchor-permalink" href="#Intervals" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="OpticSim.Interval-csg"><a class="docstring-binding" href="#OpticSim.Interval-csg"><code>OpticSim.Interval</code></a> — <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">Interval{T} &lt;: AbstractRayInterval{T}</code></pre><p>Datatype representing an interval between two <a href="#OpticSim.IntervalPoint-csg"><code>IntervalPoint</code></a>s on a ray.</p><p>The lower element can either be <a href="../ref/#OpticSim.RayOrigin"><code>RayOrigin</code></a> or an <a href="../ref/#OpticSim.Intersection"><code>Intersection</code></a>. The upper element can either be an <a href="../ref/#OpticSim.Intersection"><code>Intersection</code></a> or <a href="../ref/#OpticSim.Infinity"><code>Infinity</code></a>.</p><pre><code class="language-julia hljs">positivehalfspace(int::Intersection) -&gt; Interval with lower = int, upper = Infinity
rayorigininterval(int::Intersection) -&gt; Interval with lower = RayOrigin, upper = int
Interval(low, high)</code></pre><p>Has the following accessor methods:</p><pre><code class="language-julia hljs">lower(a::Interval{T}) -&gt; Union{RayOrigin{T},Intersection{T,3}}
upper(a::Interval{T}) -&gt; Union{Intersection{T,3},Infinity{T}}</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/789c78664dac2b05dc89b34d8f81286139c4e45a/src/Geometry/CSG/Interval.jl#L23-L42">source</a></div></details></article><article><details class="docstring" open="true"><summary id="OpticSim.EmptyInterval-csg"><a class="docstring-binding" href="#OpticSim.EmptyInterval-csg"><code>OpticSim.EmptyInterval</code></a> — <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">EmptyInterval{T} &lt;: AbstractRayInterval{T}</code></pre><p>An interval with no <a href="../ref/#OpticSim.Intersection"><code>Intersection</code></a>s which is also not infinite.</p><pre><code class="language-julia hljs">EmptyInterval(T = Float64)
EmptyInterval{T}()</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/789c78664dac2b05dc89b34d8f81286139c4e45a/src/Geometry/CSG/Interval.jl#L7-L16">source</a></div></details></article><article><details class="docstring" open="true"><summary id="OpticSim.DisjointUnion-csg"><a class="docstring-binding" href="#OpticSim.DisjointUnion-csg"><code>OpticSim.DisjointUnion</code></a> — <span class="docstring-category">Type</span></summary><div><p>Datatype representing an ordered series of disjoint intervals on a ray. An arbitrary array of <code>Interval</code>s can be input to the constructor and they will automatically be processed into a valid <code>DisjointUnion</code> (or a single <a href="../ref/#OpticSim.Interval"><code>Interval</code></a> if appropriate).</p><pre><code class="language-julia hljs">DisjointUnion(intervals::AbstractVector{Interval{R}})</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/789c78664dac2b05dc89b34d8f81286139c4e45a/src/Geometry/CSG/Interval.jl#L151-L158">source</a></div></details></article><article><details class="docstring" open="true"><summary id="OpticSim.isemptyinterval-csg"><a class="docstring-binding" href="#OpticSim.isemptyinterval-csg"><code>OpticSim.isemptyinterval</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">isemptyinterval(a) -&gt; Bool</code></pre><p>Returns true if <code>a</code> is an <a href="../ref/#OpticSim.EmptyInterval"><code>EmptyInterval</code></a>. In performance critical contexts use <code>a isa EmptyInterval{T}</code>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/789c78664dac2b05dc89b34d8f81286139c4e45a/src/Geometry/CSG/Interval.jl#L221-L226">source</a></div></details></article><article><details class="docstring" open="true"><summary id="OpticSim.ispositivehalfspace-csg"><a class="docstring-binding" href="#OpticSim.ispositivehalfspace-csg"><code>OpticSim.ispositivehalfspace</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">ispositivehalfspace(a) -&gt; Bool</code></pre><p>Returns true if <code>upper(a)</code> is <a href="../ref/#OpticSim.Infinity"><code>Infinity</code></a>. In performance critical contexts check directly i.e. <code>upper(a) isa Infinity{T}</code>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/789c78664dac2b05dc89b34d8f81286139c4e45a/src/Geometry/CSG/Interval.jl#L231-L236">source</a></div></details></article><article><details class="docstring" open="true"><summary id="OpticSim.israyorigininterval-csg"><a class="docstring-binding" href="#OpticSim.israyorigininterval-csg"><code>OpticSim.israyorigininterval</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">israyorigininterval(a) -&gt; Bool</code></pre><p>Returns true if <code>lower(a)</code> is <a href="../ref/#OpticSim.RayOrigin"><code>RayOrigin</code></a>. In performance critical contexts check directly i.e. <code>lower(a) isa RayOrigin{T}</code>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/789c78664dac2b05dc89b34d8f81286139c4e45a/src/Geometry/CSG/Interval.jl#L239-L244">source</a></div></details></article><article><details class="docstring" open="true"><summary id="OpticSim.halfspaceintersection-csg"><a class="docstring-binding" href="#OpticSim.halfspaceintersection-csg"><code>OpticSim.halfspaceintersection</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">halfspaceintersection(a::Interval{T}) -&gt; Intersection{T,3}</code></pre><p>Returns the <a href="../ref/#OpticSim.Intersection"><code>Intersection</code></a> from a half space <a href="../ref/#OpticSim.Interval"><code>Interval</code></a>, throws an error if not a half space.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/789c78664dac2b05dc89b34d8f81286139c4e45a/src/Geometry/CSG/Interval.jl#L256-L260">source</a></div></details></article><article><details class="docstring" open="true"><summary id="OpticSim.closestintersection-csg"><a class="docstring-binding" href="#OpticSim.closestintersection-csg"><code>OpticSim.closestintersection</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">closestintersection(a::Union{EmptyInterval{T},Interval{T},DisjointUnion{T}}, ignorenull::Bool = true) -&gt; Union{Nothing,Intersection{T,3}}</code></pre><p>Returns the closest <a href="../ref/#OpticSim.Intersection"><code>Intersection</code></a> from an <a href="../ref/#OpticSim.Interval"><code>Interval</code></a> or <a href="../ref/#OpticSim.DisjointUnion"><code>DisjointUnion</code></a>. Ignores intersection with null interfaces if <code>ignorenull</code> is true. Will return <code>nothing</code> if there is no valid intersection.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/789c78664dac2b05dc89b34d8f81286139c4e45a/src/Geometry/CSG/Interval.jl#L274-L279">source</a></div></details></article><article><details class="docstring" open="true"><summary id="OpticSim.IntervalPool-csg"><a class="docstring-binding" href="#OpticSim.IntervalPool-csg"><code>OpticSim.IntervalPool</code></a> — <span class="docstring-category">Type</span></summary><div><p>To prevent allocations we have a manually managed pool of arrays of <a href="../ref/#OpticSim.Interval"><code>Interval</code></a>s which are used to store values during execution. The memory is kept allocated and reused across runs of functions like <a href="../systems/#OpticSim.trace-systems"><code>trace</code></a>.</p><p><code>threadedintervalpool</code> is a global threadsafe pool which is accessed through the functions:</p><pre><code class="language-julia hljs">newinintervalpool!(::Type{T} = Float64, tid::Int = Threads.threadid()) -&gt; Vector{Interval{T}}
indexednewinintervalpool!(::Type{T} = Float64, tid::Int = Threads.threadid()) -&gt; Tuple{Int,Vector{Interval{T}}}
emptyintervalpool!(::Type{T} = Float64, tid::Int = Threads.threadid())
getfromintervalpool([::Type{T} = Float64], id::Int, tid::Int = Threads.threadid()) -&gt; Vector{Interval{T}}</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/789c78664dac2b05dc89b34d8f81286139c4e45a/src/Geometry/CSG/Interval.jl#L67-L78">source</a></div></details></article><h3 id="Intersections"><a class="docs-heading-anchor" href="#Intersections">Intersections</a><a id="Intersections-1"></a><a class="docs-heading-anchor-permalink" href="#Intersections" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="OpticSim.IntervalPoint-csg"><a class="docstring-binding" href="#OpticSim.IntervalPoint-csg"><code>OpticSim.IntervalPoint</code></a> — <span class="docstring-category">Type</span></summary><div><p>Each <a href="../ref/#OpticSim.Interval"><code>Interval</code></a> consists of two <code>IntervalPoint</code>s, one of <a href="../ref/#OpticSim.RayOrigin"><code>RayOrigin</code></a>, <a href="../ref/#OpticSim.Intersection"><code>Intersection</code></a> or <a href="../ref/#OpticSim.Infinity"><code>Infinity</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/789c78664dac2b05dc89b34d8f81286139c4e45a/src/Geometry/CSG/Intersection.jl#L5-L7">source</a></div></details></article><article><details class="docstring" open="true"><summary id="OpticSim.RayOrigin-csg"><a class="docstring-binding" href="#OpticSim.RayOrigin-csg"><code>OpticSim.RayOrigin</code></a> — <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">RayOrigin{T} &lt;: IntervalPoint{T}</code></pre><p>Point representing 0 within an <a href="../ref/#OpticSim.Interval"><code>Interval</code></a>, i.e. the start of the ray.</p><pre><code class="language-julia hljs">RayOrigin(T = Float64)
RayOrigin{T}()</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/789c78664dac2b05dc89b34d8f81286139c4e45a/src/Geometry/CSG/Intersection.jl#L96-L105">source</a></div></details></article><article><details class="docstring" open="true"><summary id="OpticSim.Infinity-csg"><a class="docstring-binding" href="#OpticSim.Infinity-csg"><code>OpticSim.Infinity</code></a> — <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">Infinity{T} &lt;: IntervalPoint{T}</code></pre><p>Point representing ∞ within an <a href="../ref/#OpticSim.Interval"><code>Interval</code></a>.</p><pre><code class="language-julia hljs">Infinity(T = Float64)
Infinity{T}()</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/789c78664dac2b05dc89b34d8f81286139c4e45a/src/Geometry/CSG/Intersection.jl#L82-L91">source</a></div></details></article><article><details class="docstring" open="true"><summary id="OpticSim.Intersection-csg"><a class="docstring-binding" href="#OpticSim.Intersection-csg"><code>OpticSim.Intersection</code></a> — <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">Intersection{T,N} &lt;: IntervalPoint{T}</code></pre><p>Represents the point at which an <a href="../ref/#OpticSim.Ray"><code>Ray</code></a> hits a <a href="../ref/#OpticSim.Surface"><code>Surface</code></a>. This consists of the distance along the ray, the intersection point in world space, the normal in world space, the UV on the surface and the <a href="../ref/#OpticSim.OpticalInterface"><code>OpticalInterface</code></a> hit.</p><p>Has the following accessor methods:</p><pre><code class="language-julia hljs">point(a::Intersection{T,N}) -&gt; SVector{N,T}
normal(a::Intersection{T,N}) -&gt; SVector{N,T}
uv(a::Intersection{T,N}) -&gt; SVector{2,T}
u(a::Intersection{T,N}) -&gt; T
v(a::Intersection{T,N}) -&gt; T
α(a::Intersection{T,N}) -&gt; T
interface(a::Intersection{T,N}) -&gt; OpticalInterface{T}
flippednormal(a::Intersection{T,N}) -&gt; Bool</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/789c78664dac2b05dc89b34d8f81286139c4e45a/src/Geometry/CSG/Intersection.jl#L14-L31">source</a></div></details></article><article><details class="docstring" open="true"><summary id="OpticSim.isinfinity-csg"><a class="docstring-binding" href="#OpticSim.isinfinity-csg"><code>OpticSim.isinfinity</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">isinfinity(a) -&gt; Bool</code></pre><p>Returns true if <code>a</code> is <a href="../ref/#OpticSim.Infinity"><code>Infinity</code></a>. In performance critical contexts use <code>a isa Infinity{T}</code>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/789c78664dac2b05dc89b34d8f81286139c4e45a/src/Geometry/CSG/Intersection.jl#L145-L150">source</a></div></details></article><article><details class="docstring" open="true"><summary id="OpticSim.israyorigin-csg"><a class="docstring-binding" href="#OpticSim.israyorigin-csg"><code>OpticSim.israyorigin</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">israyorigin(a) -&gt; Bool</code></pre><p>Returns true if <code>a</code> is <a href="../ref/#OpticSim.RayOrigin"><code>RayOrigin</code></a>. In performance critical contexts use <code>a isa RayOrigin{T}</code>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/brianguenter/OpticSim.jl/blob/789c78664dac2b05dc89b34d8f81286139c4e45a/src/Geometry/CSG/Intersection.jl#L157-L162">source</a></div></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../transforms_and_vectors/">« Transforms and Vectors</a><a class="docs-footer-nextpage" href="../systems/">Systems »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.0 on <span class="colophon-date" title="Friday 14 November 2025 19:40">Friday 14 November 2025</span>. Using Julia version 1.12.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
